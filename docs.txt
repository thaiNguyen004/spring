Contents
Chaper 01- Getting started
with Spring
1.1 What is Spring?
1.2 Initializing a Spring application
1.2.1 Initializing a Spring project with Spring Tool Suite
1.2.2 Examining the Spring project structure
EXPLORING THE BUILD SPECIFICATION
BOOTSTRAPPING THE APPLICATION
TESTING THE APPLICATION
1.3 Writing a Spring application
1.3.1 Handling web requests
1.3.2 Defining the view
1.3.3 Testing the controller
1.3.4 Building and running the application
1.3.5 Getting to know Spring Boot DevTools
AUTOMATIC APPLICATION RESTART
AUTOMATIC BROWSER REFRESH AND TEMPLATE CACHE DISABLE
BUILT-IN H2 CONSOLE
1.3.6 Let’s review
1.4 Surveying the Spring landscape
1.4.1 The core Spring Framework
1.4.2 Spring Boot
1.4.3 Spring Data
1.4.4 Spring Security
1.4.5 Spring Integration and Spring Batch
1.4.6 Spring Cloud
1.4.7 Spring Native
Summary
Chapter 02 - Developing web
Applications
2.1 Displaying information
2.1.1 Establishing the domain
2.1.2 Creating a controller class
HANDLING A GET REQUEST
2.1.3 Designing the view
2.2 Processing form submission
2.3 Validating form input
2.3.1 Declaring validation rules
2.3.2 Performing validation at form binding
2.3.3 Displaying validation errors
2.4 Working with view controllers
2.5 Choosing a view template library
2.5.1 Caching templates
Summary
Chapter 03 -Working with data
3.3 Persisting data with Spring Data JPA
3.3.1 Adding Spring Data JPA to the project
3.3.2 Annotating the domain as entities
3.3.3 Declaring JPA repositories
3.3.4 Customizing repositories
Chapter 04 - Working with
nonrelational data
4.1 Working with Cassandra repositories
4.1.1 Enabling Spring Data Cassandra
4.1.2 Understanding Cassandra data modeling
4.1.3 Mapping domain types for Cassandra persistence
4.1.4 Writing Cassandra repositories
Chapter05 - Securing Spring
5.1 Enabling Spring Security
5.2 Configuring authentication
5.2.1 In-memory user details service
5.2.2 Customizing user authentication
DEFINING THE USER DOMAIN AND PERSISTENCE
CREATING A USER DETAILS SERVICE
REGISTERING USERS
5.3 Securing web requests
5.3.1 Securing requests
5.3.2 Creating a custom login page
5.3.3 Enabling third-party authentication
5.3.4 Preventing cross-site request forgery
5.4 Applying method-level security
5.5 Knowing your user
Chapter 06 - Working with
configuration properties
6.1 Fine-tuning autoconfiguration
6.1.1 Understanding Spring’s environment abstraction
6.1.2 Configuring a data source
6.1.3 Configuring the embedded server
6.1.4 Configuring logging
6.2 Creating your own configuration properties
6.2.1 Defining configuration property holders
6.2.2 Declaring configuration property metadata
6.3 Configuring with profiles
6.3.1 Defining profile-specific properties
6.3.2 Activating profiles
6.3.3 Conditionally creating beans with profiles
Chapter 07-Creating REST services
7.1 Writing RESTful controllers
7.1.1 Retrieving data from the server
7.1.2 Sending data to the server
7.1.3 Updating data on the server
7.1.4 Deleting data from the server
7.2 Enabling data-backed services
7.2.1 Adjusting resource paths and relation names
7.3 Consuming REST services
7.3.1 GETting resources
7.3.2 PUTting resources
7.3.3 DELETEing resources
7.3.4 POSTing resource data
Chapter 8 -Securing REST
8.1 Introducing OAuth 2
8.2 Creating an authorization server
8.4 Developing the client
Chapter 09 - Sending messages
9.1 Sending messages with JMS
9.1.1 Setting up JMS
9.1.2 Sending messages with JmsTemplate
CONVERTING MESSAGES BEFORE SENDING
CONFIGURING A MESSAGE CONVERTER
POSTPROCESSING MESSAGES
9.1.3 Receiving JMS messages
RECEIVING WITH JMSTEMPLATE
DECLARING MESSAGE LISTENERS
9.3 Messaging with Kafka
9.3.1 Setting up Spring for Kafka messaging
9.3.2 Sending messages with KafkaTemplate
9.3.3 Writing Kafka listeners
Chapter 10 -Integrating Spring
10.1 Declaring a simple integration flow
10.1.1 Defining integration flows with XML
10.1.2 Configuring integration flows in Java
10.1.3 Using Spring Integration’s DSL configuration
10.2 Surveying the Spring Integration landscape
10.2.1 Message channels
10.2.2 Filters
10.2.3 Transformers
10.2.4 Routers
10.2.5 Splitters
10.2.6 Service activators
10.2.7 Gateways
10.2.8 Channel adapters
10.3 Creating an email integration flow
Chapter 11- Introducing Reactor
11.1 Understanding reactive programming
11.2 Getting started with Reactor
11.2.1 Diagramming reactive flows
11.2.2 Adding Reactor dependencies
11.3 Applying common reactive operations
11.3.1 Creating reactive types
CREATING FROM OBJECTS
GENERATING FLUX DATA
11.3.2 Combining reactive types
MERGING REACTIVE TYPES
SELECTING THE FIRST REACTIVE TYPE TO PUBLISH
11.3.3 Transforming and filtering reactive streams
FILTERING DATA FROM REACTIVE TYPES
MAPPING REACTIVE DATA
11.3.4 Performing logic operations on reactive types
Chapter 12 - Developing reactive APIs
12.1.1 Introducing Spring WebFlux
REACTIVE SPRING MVC?
12.1.2 Writing reactive controllers
RETURNING SINGLE VALUES
12.2 Defining functional request handlers
12.3 Testing reactive controllers
12.3.1 Testing GET requests
12.3.2 Testing POST requests
12.3.3 Testing with a live server
12.4 Consuming REST APIs reactively
12.4.1 GETting resources
12.4.2 Sending resources
12.4.4 Handling errors
12.5 Securing reactive web APIs
12.5.1 Configuring reactive web security
12.5.2 Configuring a reactive user details service
Chapter 13- Persisting data reactively
13.1 Working with R2DBC
13.1.1 Defining domain entities for R2DBC
13.1.2 Defining reactive repositories
13.1.3 Testing R2DBC repositories
13.1.4 Defining an OrderRepository aggregate root service
13.3.1 Defining domain classes for Cassandra persistence
13.3.2 Creating reactive Cassandra repositories
13.3.3 Testing reactive Cassandra repositories
Chapter 14 - Working with Rsocket
14.1 Introducing RSocket
14.2 Creating a simple RSocket server and client
14.2.1 Working with request-response
14.2.2 Handling request-stream messaging
14.2.3 Sending fire-and-forget messages
14.2.4 Sending messages bidirectionally
14.3 Transporting RSocket over WebSocket

Chaper 01- Getting started
with Spring

This chapter covers
- Spring and Spring Boot essentials
- Initializing a Spring project
- An overview of the Spring landscape


1.1 What is Spring?
Tôi biết bạn chắc chắn muốn bắt đầu viết một ứng dụng Spring, và tôi đảm bảo rằng trước khi chương này kết thúc, bạn sẽ đã phát triển được một ứng dụng đơn giản. Nhưng trước tiên, hãy để tôi giới thiệu một số khái niệm cơ bản về Spring sẽ giúp bạn hiểu rõ hơn về cách Spring hoạt động.

Mọi ứng dụng phức tạp bao gồm nhiều thành phần - components, mỗi thành phần đảm nhận một phần của chức năng tổng thể của ứng dụng, phối hợp với các thành phần khác để hoàn thành công việc. Khi ứng dụng chạy, những thành phần đó cần được tạo ra và giới thiệu cho nhau một cách nào đó.

Ở cốt lõi, Spring cung cấp một container, thường được gọi là Spring application context, tạo và quản lý các thành phần của ứng dụng. Những thành phần này, hay còn gọi là beans, được kết nối với nhau bên trong Spring application context để tạo thành một ứng dụng hoàn chỉnh, giống như cách gạch, vữa, gỗ, đinh, ống nước và dây điện được liên kết với nhau để tạo nên một ngôi nhà.

Việc kết nối các bean lại với nhau dựa trên một mô hình được biết đến là dependency injection (DI). Thay vì để các thành phần tạo và duy trì vòng đời của các bean khác mà chúng phụ thuộc, một ứng dụng được inject dependency dựa trên một đối tượng riêng biệt (container) để tạo và duy trì tất cả các thành phần và inject chúng vào các bean cần chúng. Thông thường, điều này được thực hiện thông qua các đối số của constructor hoặc các phương thức accessor của thuộc tính.

Ví dụ, giả sử trong nhiều thành phần của một ứng dụng, bạn sẽ xử lý hai thành phần: một dịch vụ kho (để lấy thông tin về mức tồn kho) và một dịch vụ sản phẩm (để cung cấp thông tin cơ bản về sản phẩm). Dịch vụ sản phẩm phụ thuộc vào dịch vụ kho để có thể cung cấp một bộ thông tin đầy đủ về sản phẩm. Hình 1.1 mô tả mối quan hệ giữa những bean này và Spring application context.
 

Ngoài container cốt lõi của mình, Spring và một loạt các thư viện liên quan khác cung cấp một framework web, nhiều tùy chọn lưu trữ dữ liệu, một framework bảo mật, tích hợp với các hệ thống khác, giám sát thời gian chạy, hỗ trợ microservice, một mô hình lập trình reactive, và nhiều tính năng khác cần thiết cho phát triển ứng dụng hiện đại. Lịch sử cho thấy cách bạn hướng dẫn Spring application context để kết nối các bean lại với nhau thường là thông qua một hoặc nhiều tệp XML mô tả các thành phần và mối quan hệ của chúng với các thành phần khác.

Ví dụ, đoạn mã XML sau đây khai báo hai "bean", một "InventoryService bean" và một "ProductService bean", và kết nối "InventoryService bean" vào "ProductService" thông qua một đối số của constructor:

```xml
<bean id="inventoryService" class="com.example.InventoryService" />
<bean id="productService" class="com.example.ProductService">
    <constructor-arg ref="inventoryService" />
</bean>
```

Tuy nhiên, trong các phiên bản gần đây của Spring, việc sử dụng cấu hình dựa trên Java là phổ biến hơn. Lớp cấu hình dưới đây được viết bằng Java và tương đương với cấu hình XML trên:



```java
@Configuration
public class ServiceConfiguration {
    @Bean
    public InventoryService inventoryService() {
        return new InventoryService();
    }

    @Bean
    public ProductService productService() {
        return new ProductService(inventoryService());
    }
}
```

Chú thích @Configuration cho biết với Spring rằng đây là một lớp cấu hình sẽ cung cấp các "bean" cho Spring application context. Các phương thức trong cấu hình được chú thích bằng @Bean, cho biết rằng các đối tượng mà chúng trả về sẽ được thêm vào như là "bean" trong application context (mặc định, các ID "bean" tương ứng sẽ giống với tên của các phương thức định nghĩa chúng).

Cấu hình dựa trên Java mang lại nhiều lợi ích hơn so với cấu hình dựa trên XML, bao gồm tính an toàn kiểu (type safety) cao hơn và khả năng refactor tốt hơn. Tuy nhiên, cấu hình rõ ràng bằng cách sử dụng Java hoặc XML chỉ là cần thiết khi Spring không thể tự động cấu hình các thành phần.

Cấu hình tự động có nguồn gốc từ các kỹ thuật trong Spring được biết đến là autowiring và component scanning. Với component scanning, Spring có thể tự động phát hiện các thành phần từ classpath của ứng dụng và tạo chúng như là các "bean" trong Spring application context. Với autowiring, Spring tự động inject các thành phần với các "bean" khác mà chúng phụ thuộc vào.

Gần đây hơn, với sự ra đời của Spring Boot, cấu hình tự động đã đi xa hơn component scanning và autowiring. Spring Boot là một phần mở rộng của Spring Framework cung cấp nhiều cải tiến về năng suất. Cải tiến nổi bật nhất trong số đó là autoconfiguration, nơi Spring Boot có thể đưa ra dự đoán hợp lý về những thành phần cần được cấu hình và kết nối với nhau, dựa trên các mục trong classpath, biến môi trường và các yếu tố khác.

Tôi muốn cho bạn thấy một đoạn mã ví dụ mô tả autoconfiguration, nhưng tôi không thể. Autoconfiguration giống như gió - bạn có thể nhìn thấy các ảnh hưởng của nó, nhưng không có mã nguồn nào tôi có thể cho bạn xem và nói "Nhìn đây! Đây là một ví dụ về autoconfiguration!" Các sự kiện xảy ra, các thành phần được kích hoạt, và chức năng được cung cấp mà không cần viết mã. Điều này làm cho việc thiếu mã nguồn là quan trọng đối với autoconfiguration và làm cho nó trở nên tuyệt vời.

Spring Boot autoconfiguration đã giảm đáng kể lượng cấu hình rõ ràng (bằng cách sử dụng XML hoặc Java) cần thiết để xây dựng một ứng dụng. Thực tế, khi bạn hoàn thành ví dụ trong chương này, bạn sẽ có một ứng dụng Spring hoạt động chỉ với một dòng mã cấu hình Spring!

Spring Boot nâng cao phát triển Spring đến mức độ đáng kể, đến mức khó có thể tưởng tượng phát triển ứng dụng Spring mà không có nó. Vì lí do đó, cuốn sách này xem xét Spring và Spring Boot như là một. Chúng ta sẽ sử dụng Spring Boot nhiều nhất có thể và chỉ sử dụng cấu hình rõ ràng khi cần thiết. Và, vì cấu hình XML của Spring là cách làm "cũ kỹ" khi làm việc với Spring, chúng ta sẽ tập trung chủ yếu vào cấu hình dựa trên Java của Spring.

Nhưng đủ là chuyện nói nhiều rồi, hãy bắt đầu, để bạn có thể bắt đầu viết ứng dụng Spring đầu tiên của mình.


1.2 Initializing a Spring application
Trong suốt quá trình đọc cuốn sách này, bạn sẽ tạo ra Taco Cloud, một ứng dụng trực tuyến để đặt món ăn ngon nhất được tạo ra bởi con người - tacos. Tất nhiên, bạn sẽ sử dụng Spring, Spring Boot và nhiều thư viện và framework liên quan khác để đạt được mục tiêu này.

Bạn sẽ thấy có nhiều lựa chọn để khởi tạo một ứng dụng Spring. Mặc dù tôi có thể hướng dẫn bạn qua các bước để tạo thủ công cấu trúc thư mục dự án và xác định một đặc tả xây dựng, đó là thời gian bị lãng phí - thời gian tốt hơn nên dành để viết mã ứng dụng. Do đó, bạn sẽ sử dụng Spring Initializr để khởi động ứng dụng của mình.

Spring Initializr là cả một ứng dụng web dựa trên trình duyệt và một REST API, có thể tạo ra một cấu trúc dự án Spring mẫu mà bạn có thể mở rộng với bất kỳ chức năng nào bạn muốn. Có nhiều cách để sử dụng Spring Initializr như sau:
- Từ ứng dụng web tại http://start.spring.io
- Từ dòng lệnh bằng cách sử dụng lệnh curl
- Từ dòng lệnh bằng cách sử dụng giao diện dòng lệnh của Spring Boot
- Khi tạo một dự án mới với Spring Tool Suite
- Khi tạo một dự án mới với IntelliJ IDEA
- Khi tạo một dự án mới với Apache NetBeans

Thay vì dành vài trang trong chương này để nói về từng lựa chọn, tôi đã thu thập chi tiết đó trong phần phụ lục. Trong chương này và trong toàn bộ cuốn sách, tôi sẽ chỉ bạn cách tạo một dự án mới bằng cách sử dụng tùy chọn yêu thích của mình: hỗ trợ Spring Initializr trong Spring Tool Suite.

Như tên gọi của nó, Spring Tool Suite là một môi trường phát triển Spring tuyệt vời có sẵn dưới dạng các tiện ích mở rộng cho Eclipse, Visual Studio Code, hoặc IDE Theia. Bạn có thể tải xuống bản nhị phân sẵn sàng chạy của Spring Tool Suite tại https://spring.io/tools. Spring Tool Suite cung cấp một tính năng thuận tiện là Spring Boot Dashboard, giúp bắt đầu, khởi động lại và dừng ứng dụng Spring Boot dễ dàng từ IDE.

Nếu bạn không sử dụng Spring Tool Suite, không vấn đề; chúng ta vẫn có thể là bạn bè. Chuyển đến phần phụ lục và thay thế tùy chọn Initializr phù hợp nhất với bạn cho các hướng dẫn trong các phần sau. Nhưng hãy biết rằng trong toàn bộ cuốn sách này, đôi khi tôi có thể đề cập đến các tính năng cụ thể của Spring Tool Suite, như Spring Boot Dashboard. Nếu bạn không sử dụng Spring Tool Suite, bạn cần điều chỉnh các hướng dẫn đó để phù hợp với IDE của bạn.

1.2.1 Initializing a Spring project with Spring Tool Suite
1.2.2 Examining the Spring project structure
Sau khi dự án được tải trong IDE, mở rộng nó để xem nó chứa những gì. Hình 1.6 hiển thị dự án Taco Cloud được mở rộng trong Spring Tool Suite.

 


Bạn có thể nhận ra đây là một cấu trúc dự án Maven hoặc Gradle điển hình, trong đó mã nguồn ứng dụng được đặt trong src/main/java, mã nguồn kiểm thử được đặt trong src/test/java, và các nguồn không phải Java được đặt trong src/main/resources. Trong cấu trúc dự án đó, bạn sẽ muốn chú ý đến các mục sau:

- `mvnw` và `mvnw.cmd` — Đây là các tập lệnh bọc Maven. Bạn có thể sử dụng những tập lệnh này để xây dựng dự án của bạn, ngay cả khi bạn không có Maven cài đặt trên máy tính của mình.

- `pom.xml` — Đây là đặc tả xây dựng Maven. Chúng ta sẽ xem xét chi tiết hơn về điều này trong một khoảnh khắc.

- `TacoCloudApplication.java` — Đây là lớp chính của Spring Boot, khởi động dự án. Chúng ta sẽ xem xét kỹ hơn về lớp này trong một khoảnh khắc.

- `application.properties` — Tệp này ban đầu là trống, nhưng nó cung cấp một nơi để bạn có thể chỉ định các thuộc tính cấu hình. Chúng ta sẽ làm thử nghiệm với tệp này một chút trong chương này, nhưng tôi sẽ trì hoãn giải thích chi tiết về các thuộc tính cấu hình cho đến chương 6.

- `static` — Thư mục này là nơi bạn có thể đặt bất kỳ nội dung tĩnh nào (hình ảnh, bảng điều khiển, JavaScript, v.v.) mà bạn muốn phục vụ cho trình duyệt. Ban đầu, nó trống rỗng.

- `templates` — Thư mục này là nơi bạn sẽ đặt các tệp mẫu sẽ được sử dụng để hiển thị nội dung cho trình duyệt. Ban đầu, nó trống rỗng, nhưng bạn sẽ thêm một tệp mẫu Thymeleaf sớm.

- `TacoCloudApplicationTests.java` — Đây là một lớp kiểm thử đơn giản đảm bảo rằng ngữ cảnh ứng dụng Spring tải lên thành công. Bạn sẽ thêm nhiều kiểm thử khác vào khi phát triển ứng dụng.

Khi ứng dụng Taco Cloud phát triển, bạn sẽ điền vào cấu trúc dự án gồ ghề này bằng mã Java, hình ảnh, bảng điều khiển, kiểm thử và các tài sản khác sẽ làm cho dự án của bạn trở nên hoàn chỉnh hơn. Nhưng trong lúc chờ đợi đó, hãy đào sâu một chút vào một số mục mà Spring Initializr đã cung cấp.

EXPLORING THE BUILD SPECIFICATION
Khi bạn điền thông tin vào biểu mẫu của Initializr, bạn đã chỉ định rằng dự án của mình sẽ được xây dựng bằng Maven. Do đó, Spring Initializr đã cung cấp cho bạn một tệp pom.xml đã được điền đầy đủ thông tin theo các lựa chọn bạn đã chọn. Dưới đây là toàn bộ nội dung của tệp pom.xml được cung cấp bởi Initializr.

Listing 1.1 The initial Maven build specification
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.7.17</version>     Spring Boot version
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example</groupId>
	<artifactId>taco-cloud</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>taco-cloud</name>
	<description>Taco Cloud Example</description>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>		Starter dependencies
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>		Spring Boot plugin
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>


BOOTSTRAPPING THE APPLICATION

Bởi vì bạn sẽ chạy ứng dụng từ một tệp JAR có thể thực thi, điều quan trọng là có một lớp chính sẽ được thực thi khi tệp JAR đó được chạy. Bạn cũng cần ít nhất một lượng cấu hình Spring tối thiểu để khởi động ứng dụng. Đó là những gì bạn sẽ tìm thấy trong lớp TacoCloudApplication, được hiển thị trong đoạn mã nguồn dưới đây:


Listing 1.2 The Taco Cloud bootstrap class

package tacos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TacoCloudApplication {

	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args);
	}

}




Mặc dù có rất ít mã trong TacoCloudApplication, nhưng những gì có ở đây là khá mạnh mẽ. Một trong những dòng mã mạnh mẽ nhất cũng là một trong những dòng mã ngắn nhất. Chú thích `@SpringBootApplication` rõ ràng cho biết đây là một ứng dụng Spring Boot. Nhưng có nhiều hơn `@SpringBootApplication` mà bạn thấy.

`@SpringBootApplication` là một chú thích hợp nhất (composite annotation) kết hợp ba chú thích sau đây:
- `@SpringBootConfiguration` — Xác định lớp này là một lớp cấu hình. Mặc dù không có nhiều cấu hình trong lớp này, bạn có thể thêm cấu hình Spring Framework dựa trên Java vào lớp này nếu cần thiết. Chú thích này, thực tế, là một biểu diễn chuyên biệt của chú thích `@Configuration`.
- `@EnableAutoConfiguration` — Bật cấu hình tự động của Spring Boot. Chúng ta sẽ nói thêm về tự động cấu hình sau này. Hiện tại, hãy biết rằng chú thích này thông báo cho Spring Boot tự động cấu hình bất kỳ thành phần nào mà nó nghĩ bạn sẽ cần.
- `@ComponentScan` — Bật quét thành phần. Điều này cho phép bạn khai báo các lớp khác với các chú thích như `@Component`, `@Controller`, và `@Service` để Spring tự động phát hiện và đăng ký chúng như các thành phần trong ngữ cảnh ứng dụng Spring.

Phần quan trọng khác của TacoCloudApplication là phương thức `main()`. Đây là phương thức sẽ được chạy khi tệp JAR được thực thi. Đối với phần lớn, phương thức này là mã mẫu; mọi ứng dụng Spring Boot bạn viết sẽ có một phương thức tương tự hoặc giống nhau với phương thức này (ngoại trừ sự khác biệt về tên lớp).

Phương thức `main()` gọi một phương thức `run()` tĩnh trên lớp `SpringApplication`, thực hiện quá trình khởi động thực sự của ứng dụng, tạo ngữ cảnh ứng dụng Spring. Hai tham số được truyền vào phương thức `run()` là một lớp cấu hình và các đối số dòng lệnh. Mặc dù không cần thiết phải là lớp cấu hình được truyền vào `run()` phải giống như lớp khởi động, nhưng đây là sự chọn lựa thuận tiện và điển hình nhất.

Có khả năng bạn sẽ không cần phải thay đổi gì trong lớp khởi động. Đối với các ứng dụng đơn giản, bạn có thể thấy thuận tiện khi cấu hình một hoặc hai thành phần khác trong lớp khởi động, nhưng đối với phần lớn các ứng dụng, bạn nên tạo một lớp cấu hình riêng cho bất kỳ thứ gì không được tự động cấu hình. Bạn sẽ định nghĩa một số lớp cấu hình trong suốt quá trình đọc cuốn sách này, vì vậy hãy theo dõi để biết chi tiết.

TESTING THE APPLICATION

Kiểm thử là một phần quan trọng của phát triển phần mềm. Bạn có thể luôn kiểm thử dự án của mình bằng cách thủ công bằng cách xây dựng nó và sau đó chạy nó từ dòng lệnh như sau:

$ ./mvnw package
...
$ java -jar target/taco-cloud-0.0.1-SNAPSHOT.jar

Hoặc, vì chúng ta đang sử dụng Spring Boot, plugin Spring Boot Maven làm cho nó trở nên dễ dàng hơn, như được thể hiện dưới đây:

$ ./mvnw spring-boot:run

Nhưng kiểm thử thủ công ngụ ý rằng có một con người tham gia và do đó có nguy cơ mắc lỗi và kiểm thử không đồng nhất. Kiểm thử tự động thì đồng nhất và có thể lặp lại.

Nhận ra điều này, Spring Initializr cung cấp cho bạn một lớp kiểm thử để bắt đầu. Đoạn mã dưới đây hiển thị lớp kiểm thử cơ bản:

Listing 1.3 A baseline application test


package tacos;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TacoCloudApplicationTests {

	The test method
	@Test 
	void contextLoads() {
	}

}
Không có nhiều điều để thấy trong TacoCloudApplicationTests: phương thức kiểm thử duy nhất trong lớp là trống rỗng. Tuy nhiên, lớp kiểm thử này thực hiện một kiểm thử quan trọng để đảm bảo rằng application context Spring có thể được tải thành công. Nếu bạn thực hiện bất kỳ thay đổi nào mà làm cho application context Spring không thể được tạo ra, kiểm thử này sẽ thất bại và bạn có thể phản ứng bằng cách sửa lỗi.

Chú thích `@SpringBootTest` cho biết cho JUnit làm thế nào để khởi động kiểm thử với khả năng Spring Boot. Giống như `@SpringBootApplication`, `@SpringBootTest` là một composite annotation, nó cũng được chú thích với `@ExtendWith(SpringExtension.class)`, để thêm khả năng kiểm thử của Spring vào JUnit 5. Tuy nhiên, hiện tại, đủ chỉ nghĩa nó là lớp kiểm thử tương đương với việc gọi `SpringApplication.run()` trong một phương thức `main()`.

Qua suốt cuốn sách này, bạn sẽ thấy `@SpringBootTest` nhiều lần và chúng ta sẽ khám phá một số sức mạnh của nó.

Cuối cùng, có phương thức kiểm thử chính. Mặc dù `@SpringBootTest` có nhiệm vụ tải application context Spring cho kiểm thử, nhưng nó sẽ không có gì để làm nếu không có bất kỳ phương thức kiểm thử nào. Ngay cả khi không có bất kỳ phát biểu hoặc mã nào cả, phương thức kiểm thử trống rỗng này sẽ khuyến khích hai chú thích làm công việc của chúng và tải application context Spring. Nếu có bất kỳ vấn đề gì trong quá trình làm điều này, kiểm thử sẽ thất bại.

Để chạy lớp kiểm thử này và bất kỳ lớp kiểm thử nào khác từ dòng lệnh, bạn có thể sử dụng công thức Maven sau đây:
```
$ ./mvnw test
```
Tính đến thời điểm này, chúng ta đã hoàn tất việc xem xét mã nguồn được cung cấp bởi Spring Initializr. Bạn đã thấy một số nền tảng mã mẫu mà bạn có thể sử dụng để phát triển một ứng dụng Spring, nhưng bạn vẫn chưa viết một dòng mã nào. Bây giờ là lúc khởi động IDE của bạn, lau chùi bàn phím của bạn và thêm một số mã tùy chỉnh vào ứng dụng Taco Cloud.

1.3 Writing a Spring application

Bởi vì bạn chỉ mới bắt đầu, chúng ta sẽ bắt đầu với một thay đổi tương đối nhỏ cho ứng dụng Taco Cloud, nhưng một thay đổi mà sẽ thể hiện nhiều tính năng tốt của Spring. Dường như phù hợp khi bạn chỉ mới bắt đầu, tính năng đầu tiên bạn sẽ thêm vào ứng dụng Taco Cloud là một trang chủ. Khi bạn thêm trang chủ, bạn sẽ tạo ra hai tác phẩm mã nguồn sau đây:
- Một lớp controller xử lý các yêu cầu cho trang chủ.
- Một mẫu xem (view template) xác định cách trang chủ trông như thế nào.

Và vì việc kiểm thử là quan trọng, bạn cũng sẽ viết một lớp kiểm thử đơn giản để kiểm thử trang chủ. Nhưng trước hết... hãy viết controller đó.

1.3.1 Handling web requests

Spring đi kèm với một framework web mạnh mẽ được biết đến với tên gọi là Spring MVC. Ở trung tâm của Spring MVC là khái niệm về controller, một lớp xử lý các yêu cầu và phản hồi với một loại thông tin nào đó. Trong trường hợp của một ứng dụng dành cho trình duyệt, một controller phản hồi bằng cách tùy chọn điền dữ liệu mô hình và chuyển yêu cầu đó đến một view để tạo ra HTML được trả về cho trình duyệt.

Bạn sẽ tìm hiểu nhiều về Spring MVC trong chương 2. Nhưng hiện tại, bạn sẽ viết một lớp controller đơn giản xử lý yêu cầu cho đường dẫn gốc (ví dụ, /) và chuyển tiếp những yêu cầu đó đến view của trang chủ mà không điền bất kỳ dữ liệu mô hình nào. Đoạn mã dưới đây hiển thị lớp controller đơn giản:

Listing 1.4 The home page controller



package tacos;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller	// the controller
public class HomeController {
	
	@GetMapping("/") // Handle requests for root path /
	public String home() {
		return "home"; // Returns the view name
	}
}

Như bạn có thể thấy, lớp này được chú thích bằng `@Controller`. Một mình, `@Controller` không làm nhiều. Mục đích chính của nó là xác định lớp này là một component cho việc component scanning. Bởi vì `HomeController` được chú thích bằng `@Controller`, component auto scanning của Spring phát hiện nó và tạo một instance của `HomeController` như một bean trong Spring application context.

Trong thực tế, một số chú thích khác (bao gồm `@Component`, `@Service`, và `@Repository`) phục vụ mục đích tương tự như `@Controller`. Bạn có thể chú thích `HomeController` với bất kỳ chú thích nào khác đó và nó vẫn sẽ hoạt động giống nhau. Tuy nhiên, sự lựa chọn `@Controller` mô tả mô tả rõ hơn về vai trò của thành phần này trong ứng dụng.

Phương thức `home()` đơn giản như mọi phương thức controller khác. Nó được chú thích bằng `@GetMapping` để chỉ định rằng nếu một HTTP GET request được nhận cho đường dẫn gốc `/`, thì phương thức này sẽ xử lý yêu cầu đó. Nó làm điều đó bằng cách chỉ trả về một giá trị String là "home".


Giá trị này được hiểu là tên logic của một view. Cách triển khai view phụ thuộc vào một số yếu tố, nhưng vì Thymeleaf nằm trong classpath của bạn, bạn có thể định nghĩa template đó bằng Thymeleaf.

Why Thymeleaf? 
Bạn có thể đang tự hỏi tại sao tôi chọn Thymeleaf làm template engine. Tại sao không chọn JSP? Tại sao không chọn FreeMarker? Tại sao không chọn một số lựa chọn khác?
Nói một cách đơn giản, tôi phải chọn một cái gì đó, và tôi thích Thymeleaf và thường ưa thích nó hơn so với những lựa chọn khác. Và mặc dù JSP có vẻ là một lựa chọn rõ ràng, nhưng có một số thách thức cần vượt qua khi sử dụng JSP với Spring Boot. Tôi không muốn đi vào hướng dẫn chi tiết trong chương 1. Hãy kiên nhẫn. Chúng ta sẽ xem xét các lựa chọn template khác, bao gồm cả JSP, trong chương 2.

Tên template được tạo ra từ tên logical của view bằng cách thêm tiền tố là /templates/ và hậu tố là .html. Đường dẫn kết quả cho template là /templates/home.html. Do đó, bạn cần đặt template này trong dự án của bạn tại /src/main/resources/templates/home.html. Hãy tạo template đó ngay bây giờ.

1.3.2 Defining the view

Với mục tiêu giữ cho trang chủ của bạn đơn giản, nó không nên làm gì khác ngoài việc chào đón người dùng đến trang web. Đoạn mã dưới đây hiển thị template Thymeleaf cơ bản mà định nghĩa trang chủ của Taco Cloud.

1.3.3 Testing the controller
Kiểm thử ứng dụng web có thể khó khăn khi thực hiện các kiểm tra đối với nội dung của trang HTML. May mắn thay, Spring đi kèm với một số hỗ trợ kiểm thử mạnh mẽ giúp làm cho việc kiểm thử ứng dụng web trở nên dễ dàng.

Với mục đích của trang chủ, bạn sẽ viết một bài kiểm thử có độ phức tạp tương đương với trang chủ chính nó. Bài kiểm thử của bạn sẽ thực hiện một yêu cầu HTTP GET cho đường dẫn gốc / và mong đợi một kết quả thành công trong đó tên view là home và nội dung kết quả chứa cụm từ "Welcome to…". Đoạn mã dưới đây nên làm nhiệm vụ.

Listing 1.6 A test for the home page 

package tacos;

import static org.hamcrest.CoreMatchers.containsString;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;


@WebMvcTest(controllers = HomeControllerTest.class)  // Web test for HomeController
public class HomeControllerTest {
	
	@Autowired
	private MockMvc mockMvc;	// inject MockMvc
	
	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/"))
			.andExpect(MockMvcResultMatchers.status().isOk())
			.andExpect(MockMvcResultMatchers.view().name("home"))
			.andExpect(MockMvcResultMatchers.content()
					.string(containsString("Welcome to ...")));
	}
}


Điều đầu tiên bạn có thể chú ý về bài kiểm thử này là nó khác một chút so với lớp TacoCloudApplicationTests với mối liên quan đến các chú thích được áp dụng cho nó. Thay vì đánh dấu là @SpringBootTest, HomeControllerTest được chú thích là @WebMvcTest. Đây là một chú thích kiểm thử đặc biệt được cung cấp bởi Spring Boot, sắp xếp cho việc kiểm thử chạy trong ngữ cảnh của một ứng dụng Spring MVC. Cụ thể hơn, trong trường hợp này, nó sắp xếp cho HomeController được đăng ký trong Spring MVC để bạn có thể gửi yêu cầu đến nó. @WebMvcTest cũng thiết lập hỗ trợ Spring để kiểm thử Spring MVC. Mặc dù nó có thể được thiết lập để khởi động một máy chủ, nhưng mô phỏng cơ chế của Spring MVC là đủ cho mục đích của bạn. Lớp kiểm thử được tiêm vào một đối tượng MockMvc để kiểm thử có thể điều khiển mô phỏng.

Phương thức testHomePage() định nghĩa bài kiểm thử bạn muốn thực hiện đối với trang chủ. Nó bắt đầu với đối tượng MockMvc để thực hiện yêu cầu HTTP GET cho / (đường dẫn gốc). Từ yêu cầu đó, nó đặt các kỳ vọng - Expect sau đây:
- Phản hồi nên có trạng thái HTTP 200 (OK).
- View nên có tên logic là home.
- View được hiển thị nên chứa văn bản "Welcome to…."

Bạn có thể chạy bài kiểm thử trong IDE ưa thích của bạn hoặc với Maven như sau:
```
$ mvnw test
```
Nếu, sau khi đối tượng MockMvc thực hiện yêu cầu, bất kỳ kỳ vọng nào không được đáp ứng, thì bài kiểm thử sẽ thất bại. Nhưng controller và template view của bạn được viết để đáp ứng những kỳ vọng đó, vì vậy bài kiểm thử nên đạt điểm hoàn toàn—hoặc ít nhất là có một gam màu xanh cho biểu thị kiểm thử đã thành công.

Controller đã được viết, template view đã được tạo, và bạn đã có một bài kiểm thử thành công. Có vẻ như bạn đã triển khai trang chủ thành công. Nhưng mặc dù bài kiểm thử đạt điểm, có một cái gì đó hơi thỏa mãn hơn khi thấy kết quả trên trình duyệt. Sau cùng, đó là cách mà khách hàng của Taco Cloud sẽ nhìn thấy nó. Hãy xây dựng ứng dụng và chạy nó. 


1.3.4 Building and running the application

Giống như cách chúng ta có nhiều cách để khởi tạo một ứng dụng Spring, chúng ta cũng có nhiều cách để chạy nó. Nếu bạn muốn, bạn có thể chuyển qua phụ lục để đọc về một số cách phổ biến hơn để chạy một ứng dụng Spring Boot.

Bởi vì bạn chọn sử dụng Spring Tool Suite để khởi tạo và làm việc trên dự án, bạn có một tính năng tiện ích gọi là Spring Boot Dashboard để giúp bạn chạy ứng dụng của mình trực tiếp từ IDE. Spring Boot Dashboard xuất hiện dưới dạng một tab, thường ở gần phía dưới bên trái cửa sổ IDE. Hình ảnh 1.7 hiển thị một bức ảnh chụp màn hình được chú thích của Spring Boot Dashboard.

 
Tôi không muốn dành nhiều thời gian để nói về mọi thứ mà Spring Boot Dashboard có thể làm, mặc dù hình ảnh 1.7 bao gồm một số chi tiết hữu ích nhất. Điều quan trọng là lưu ý là Spring Boot Dashboard cung cấp một cách thuận tiện để quản lý và chạy ứng dụng Spring Boot trực tiếp từ IDE.

Để chạy ứng dụng Taco Cloud của bạn bằng Spring Boot Dashboard trong Spring Tool Suite, thực hiện các bước sau:

1. Mở Spring Boot Dashboard trong Spring Tool Suite. Bạn thường có thể tìm thấy nó dưới dạng một tab ở phía dưới bên trái cửa sổ IDE.

2. Định vị dự án Taco Cloud của bạn trong dashboard. Nó nên được liệt kê trong phần "Boot Dash".

3. Nhấp chuột phải vào dự án của bạn trong dashboard.

4. Chọn "Run As"

Chắc chắn là không nhiều để ngắm nhìn. Nhưng cuốn sách này không phải là một cuốn sách thiết kế đồ họa. Bề ngoài khiêm tốn của trang chủ là đủ cho bây giờ. Và nó mang lại cho bạn một bắt đầu vững chắc để hiểu về Spring.

Một điều mà tôi đã lơ là cho đến giờ là DevTools. Bạn đã chọn nó làm phụ thuộc khi khởi tạo dự án của mình. Nó xuất hiện như một phụ thuộc trong tệp pom.xml được tạo ra. Và bảng điều khiển Spring Boot thậm chí còn cho thấy rằng dự án đã kích hoạt DevTools.

Nhưng DevTools là gì, và nó làm gì cho bạn? Hãy xem qua một vài tính năng hữu ích nhất của DevTools.


1.3.5 Getting to know Spring Boot DevTools
Như tên gọi của nó, DevTools cung cấp cho các nhà phát triển Spring một số công cụ hữu ích trong quá trình phát triển. Trong số đó có những tính năng sau:
- Khởi động lại ứng dụng tự động khi mã nguồn thay đổi
- Làm mới trình duyệt tự động khi các nguồn (như mẫu, JavaScript, stylesheet và những thứ khác) được gửi đến trình duyệt thay đổi
- Tự động vô hiệu hóa bộ đệm mẫu
- Bảng điều khiển H2 tích hợp sẵn, nếu sử dụng cơ sở dữ liệu H2

Quan trọng để hiểu rằng DevTools không phải là một plugin của IDE, cũng như không yêu cầu sử dụng một IDE cụ thể nào. Nó hoạt động hiệu quả trên cả Spring Tool Suite, IntelliJ IDEA và NetBeans. Hơn nữa, vì nó chỉ được thiết kế cho mục đích phát triển, nó đủ thông minh để tự vô hiệu hóa khi triển khai trong môi trường sản xuất. Chúng ta sẽ thảo luận về cách nó thực hiện điều này khi bạn bắt đầu triển khai ứng dụng của mình trong chương 18. Bây giờ, hãy tập trung vào những tính năng hữu ích nhất của Spring Boot DevTools, bắt đầu bằng việc tự động khởi động lại ứng dụng.

AUTOMATIC APPLICATION RESTART
Với DevTools là một phần của dự án, bạn sẽ có thể thực hiện các thay đổi trong mã nguồn Java và các tệp thuộc tính trong dự án và thấy những thay đổi đó được áp dụng sau một khoảng thời gian ngắn. DevTools theo dõi sự thay đổi và khi phát hiện thấy điều gì đó đã thay đổi, nó tự động khởi động lại ứng dụng.

Để cụ thể hơn, khi DevTools được kích hoạt, ứng dụng được tải vào hai trình tải lớp riêng biệt trong máy ảo Java (JVM). Một trình tải lớp được tải với mã Java của bạn, các tệp thuộc tính và hầu hết mọi thứ nằm trong đường dẫn src/main/ của dự án. Đây là những mục có khả năng thay đổi thường xuyên. Trình tải lớp khác được tải với các thư viện phụ thuộc, có khả năng thay đổi ít hơn.

Khi phát hiện thấy thay đổi, DevTools chỉ tải lại trình tải lớp chứa mã nguồn dự án của bạn và khởi động lại bối cảnh ứng dụng Spring, nhưng giữ nguyên trình tải lớp và JVM khác. Mặc dù tinh tế, chiến lược này mang lại một giảm nhỏ về thời gian để khởi động ứng dụng.

Nhược điểm của chiến lược này là các thay đổi trong các thư viện phụ thuộc sẽ không có sẵn trong các khởi động lại tự động. Điều này xảy ra vì trình tải lớp chứa thư viện phụ thuộc không được tải lại tự động. Bất kỳ khi nào bạn thêm, thay đổi hoặc loại bỏ một thư viện phụ thuộc trong quy định xây dựng của bạn, bạn sẽ cần thực hiện một khởi động lại đầy đủ của ứng dụng để những thay đổi đó có hiệu lực.

AUTOMATIC BROWSER REFRESH AND TEMPLATE CACHE DISABLE

Mặc định, các tùy chọn mẫu như Thymeleaf và FreeMarker được cấu hình để lưu kết quả của quá trình phân tích mẫu, giúp mẫu không cần phải được phân tích lại mỗi khi có yêu cầu. Điều này rất tốt trong môi trường sản xuất vì mang lại một ít lợi ích về hiệu suất.

Tuy nhiên, mẫu được lưu vào bộ đệm không phải là lựa chọn tốt cho thời gian phát triển. Nó khiến việc thay đổi mẫu trong khi ứng dụng đang chạy và xem kết quả sau khi làm mới trình duyệt trở nên không thể. Ngay cả khi bạn đã thay đổi, mẫu được lưu vào bộ đệm vẫn được sử dụng cho đến khi bạn khởi động lại ứng dụng.

DevTools giải quyết vấn đề này bằng cách tự động vô hiệu hóa tất cả các bộ đệm mẫu. Bạn có thể thực hiện nhiều thay đổi như bạn muốn trong các mẫu của mình và biết rằng bạn chỉ cần làm mới trình duyệt để xem kết quả.

Nhưng nếu bạn giống như tôi, bạn thậm chí không muốn phải nhấp vào nút làm mới của trình duyệt. Sẽ tốt hơn nếu bạn có thể thực hiện các thay đổi và chứng kiến kết quả ngay lập tức trong trình duyệt. May mắn thay, DevTools có một điều đặc biệt cho những người như chúng ta, người không muốn bận tâm đến việc nhấp vào nút làm mới.

DevTools tự động kích hoạt một máy chủ LiveReload (http://livereload.com/) cùng với ứng dụng của bạn. Một mình, máy chủ LiveReload không hữu ích lắm. Nhưng khi kết hợp với một plugin trình duyệt LiveReload tương ứng, nó khiến trình duyệt của bạn tự động làm mới khi có thay đổi trong các mẫu, hình ảnh, stylesheet, JavaScript, và nhiều thứ khác - thực tế, gần như mọi thứ được phục vụ đến trình duyệt của bạn.


BUILT-IN H2 CONSOLE

Mặc dù dự án của bạn hiện chưa sử dụng cơ sở dữ liệu, điều này sẽ thay đổi trong chương 3. Nếu bạn chọn sử dụng cơ sở dữ liệu H2 cho quá trình phát triển, DevTools cũng sẽ tự động kích hoạt một bảng điều khiển H2 mà bạn có thể truy cập từ trình duyệt web của mình. Bạn chỉ cần trỏ trình duyệt web của mình đến http:/ /localhost:8080/h2-console để có cái nhìn chi tiết về dữ liệu mà ứng dụng của bạn đang làm việc.

Ở điểm này, bạn đã viết một ứng dụng Spring hoàn chỉnh, mặc dù đơn giản. Bạn sẽ mở rộng nó trong suốt quá trình của cuốn sách. Nhưng bây giờ là thời điểm tốt để lùi lại và xem xét những gì bạn đã đạt được và cách Spring đã đóng vai trò trong quá trình đó.



1.3.6 Let’s review
Hãy nhớ lại cách bạn đã đạt đến điểm này. Nói một cách ngắn gọn, bạn đã thực hiện các bước sau để xây dựng ứng dụng Taco Cloud Spring của mình:
- Bạn đã tạo cấu trúc dự án ban đầu bằng cách sử dụng Spring Initializr.
- Bạn đã viết một lớp controller để xử lý yêu cầu trang chủ.
- Bạn đã định nghĩa một template view để hiển thị trang chủ.
- Bạn đã viết một lớp kiểm thử đơn giản để chứng minh công việc của bạn.

Có vẻ khá đơn giản, phải không? Ngoại trừ bước đầu tiên để khởi tạo dự án, mỗi hành động bạn đã thực hiện đã được tập trung mạnh mẽ vào mục tiêu tạo ra trang chủ.
Trên thực tế, gần như mỗi dòng mã bạn đã viết đều hướng đến mục tiêu đó. Không tính các câu lệnh nhập Java, tôi chỉ đếm được hai dòng mã trong lớp điều khiển của bạn và không có dòng mã nào trong mẫu xem đó là đặc trưng của Spring. Và mặc dù hầu hết lớp kiểm thử sử dụng hỗ trợ kiểm thử của Spring, nó có vẻ ít xen vào trong bối cảnh của một bài kiểm thử.
Đây là một lợi ích quan trọng khi phát triển với Spring. Bạn có thể tập trung vào mã nguồn đáp ứng yêu cầu của ứng dụng, thay vì phải làm thỏa mãn yêu cầu của một framework. Mặc dù không tránh khỏi việc phải viết một số mã cụ thể của framework đôi khi, nhưng thường chỉ chiếm một phần nhỏ của mã nguồn của bạn. Như tôi đã nói trước đó, Spring (đặc biệt là với Spring Boot) có thể coi là một "framework không framework".
Làm thế nào điều này hoạt động? Spring làm gì ẩn sau các cảnh để đảm bảo các nhu cầu của ứng dụng của bạn được đáp ứng? Để hiểu rõ những gì Spring đang thực hiện, hãy bắt đầu bằng cách xem xét quy định xây dựng.
Trong tệp `pom.xml`, bạn đã khai báo một dependency vào các starter Web và Thymeleaf. Những phụ thuộc này đã đưa vào một số dependency khác, bao gồm:
- Framework MVC của Spring
- Embedded Tomcat
- Thymeleaf và Thymeleaf layout dialect
Nó cũng đưa theo thư viện auto configuration của Spring Boot. Khi ứng dụng bắt đầu, auto configuration của Spring Boot phát hiện những thư viện đó và tự động thực hiện các công việc sau:
- Cấu hình các bean trong Spring application context để kích hoạt Spring MVC.
- Cấu hình máy chủ Tomcat nhúng trong Spring application context.
- Cấu hình trình view resolver Thymeleaf để rendering view Spring MVC với các mẫu Thymeleaf.

Nói một cách ngắn gọn, auto configuration thực hiện toàn bộ công việc nặng nhọc, để bạn có thể tập trung vào việc viết mã nguồn triển khai chức năng của ứng dụng. Đó là một sắp xếp khá ngon lành, theo ý kiến của tôi!

Hành trình với Spring của bạn chỉ mới bắt đầu. Ứng dụng Taco Cloud chỉ chạm vào một phần nhỏ của những gì mà Spring mang lại. Trước khi bạn tiến bước tiếp theo, hãy xem xét cảnh quan Spring và xem những địa danh bạn sẽ gặp trên hành trình của mình.

1.4 Surveying the Spring landscape

Để có cái nhìn về cảnh quan Spring, hãy nhìn vào danh sách lớn vô cùng các ô chọn trên phiên bản đầy đủ của biểu mẫu web Spring Initializr. Nó liệt kê hơn 100 lựa chọn phụ thuộc, nên tôi sẽ không cố gắng liệt kê chúng tất cả ở đây hoặc cung cấp một ảnh chụp màn hình. Nhưng tôi khuyến khích bạn hãy tự xem. Trong khi đó, tôi sẽ đề cập đến một số điểm nổi bật.
1.4.1 The core Spring Framework
Như bạn có thể mong đợi, Spring Framework core là nền tảng của mọi thứ khác trong vũ trụ Spring. Nó cung cấp container core và framework dependency injection. Nhưng nó cũng cung cấp một số tính năng quan trọng khác.

Trong số đó là Spring MVC, framework web của Spring. Bạn đã thấy cách sử dụng Spring MVC để viết một lớp controller để xử lý các yêu cầu web. Tuy nhiên, điều bạn chưa thấy là Spring MVC cũng có thể được sử dụng để tạo các REST API tạo ra đầu ra không phải là HTML. Chúng tôi sẽ đàm phán thêm về Spring MVC trong chương 2 và sau đó xem xét cách sử dụng nó để tạo các REST API trong chương 7.

Spring Framework core cũng cung cấp một số hỗ trợ cơ bản cho lưu trữ dữ liệu, cụ thể là hỗ trợ JDBC dựa trên template. Bạn sẽ biết cách sử dụng JdbcTemplate trong chương 3.

Spring bao gồm hỗ trợ cho lập trình theo kiểu reactive, bao gồm một framework web reactive mới được gọi là Spring WebFlux, được mượn nhiều từ Spring MVC. Bạn sẽ xem xét mô hình lập trình reactive của Spring trong phần 3 và cụ thể về Spring WebFlux trong chương 12.

1.4.2 Spring Boot

Chúng ta đã thấy nhiều lợi ích của Spring Boot, bao gồm các dependencies starter và auto configuration. Hãy chắc chắn rằng chúng ta sẽ sử dụng càng nhiều Spring Boot càng tốt trong toàn bộ cuốn sách này và tránh mọi hình thức cấu hình rõ ràng, trừ khi đó là hoàn toàn cần thiết. Nhưng ngoài các dependencies starter và auto configuration, Spring Boot cũng cung cấp những tính năng hữu ích khác sau đây:

- Actuator cung cấp cái nhìn runtime vào bản chất hoạt động của một ứng dụng, bao gồm các thông số, thông tin dump thread, sức khỏe ứng dụng và các thuộc tính môi trường có sẵn cho ứng dụng.
- Quy định linh hoạt các thuộc tính môi trường.
- Hỗ trợ kiểm thử bổ sung trên nền tảng sự hỗ trợ kiểm thử có sẵn trong framework cốt lõi.

Hơn nữa, Spring Boot cung cấp một mô hình lập trình thay thế dựa trên các tập lệnh Groovy được gọi là Spring Boot CLI (giao diện dòng lệnh). Với Spring Boot CLI, bạn có thể viết toàn bộ ứng dụng dưới dạng một bộ script Groovy và chạy chúng từ dòng lệnh. Chúng ta sẽ không dành nhiều thời gian cho Spring Boot CLI, nhưng sẽ đề cập đến nó đôi khi khi nó phù hợp với nhu cầu của chúng ta.

Spring Boot đã trở thành một phần không thể thiếu của phát triển Spring mà tôi không thể tưởng tượng việc phát triển một ứng dụng Spring mà không có nó. Do đó, cuốn sách này nhìn nhận từ quan điểm tập trung vào Spring Boot, và bạn có thể thấy tôi sử dụng từ "Spring" khi đề cập đến điều gì đó mà Spring Boot đang thực hiện.

1.4.3 Spring Data
Mặc dù Spring Framework cốt lõi đi kèm với sự hỗ trợ cơ bản cho lưu trữ dữ liệu, nhưng Spring Data mang đến một điều khá tuyệt vời: khả năng định nghĩa các repository của ứng dụng của bạn dưới dạng các interface Java đơn giản, sử dụng quy ước đặt tên khi định nghĩa các phương thức để điều khiển cách dữ liệu được lưu trữ và truy xuất.

Hơn nữa, Spring Data có khả năng làm việc với nhiều loại cơ sở dữ liệu khác nhau, bao gồm relational (thông qua JDBC hoặc JPA), document (Mongo), graph (Neo4j), và nhiều loại khác. Bạn sẽ sử dụng Spring Data để giúp tạo ra các repository cho ứng dụng Taco Cloud trong chương 3.

1.4.4 Spring Security
Bảo mật ứng dụng luôn là một chủ đề quan trọng và có vẻ trở nên quan trọng hơn mỗi ngày. May mắn thay, Spring có một framework bảo mật mạnh mẽ trong Spring Security.
Spring Security giải quyết một loạt các nhu cầu về bảo mật ứng dụng, bao gồm xác thực-authentication, ủy quyền-authorization và API Security. Mặc dù phạm vi của Spring Security quá lớn để được đề cập đầy đủ trong cuốn sách này, chúng ta sẽ đề cập đến một số trường hợp sử dụng phổ biến nhất trong các chương 5 và 12.

1.4.5 Spring Integration and Spring Batch

Ở một số điểm nào đó, hầu hết các ứng dụng sẽ cần tích hợp với các ứng dụng khác hoặc thậm chí là với các thành phần khác của cùng một ứng dụng. Nhiều mô hình tích hợp ứng dụng đã xuất hiện để đáp ứng những nhu cầu này. Spring Integration và Spring Batch cung cấp các triển khai của những mô hình này cho các ứng dụng Spring. Spring Integration giải quyết tích hợp thời gian thực trong đó dữ liệu được xử lý ngay khi nó sẵn có. Ngược lại, Spring Batch giải quyết tích hợp theo lô trong đó dữ liệu được phép tích lũy trong một khoảng thời gian cho đến khi một tín hiệu kích hoạt (có thể là một tín hiệu thời gian) cho biết đã đến lúc xử lý lô dữ liệu. Bạn sẽ khám phá Spring Integration trong chương 10.

1.4.6 Spring Cloud
Thế giới phát triển ứng dụng đang bước vào một thời đại mới, nơi chúng ta sẽ không phát triển ứng dụng của mình như là các single-deployment, unit monolith và thay vào đó sẽ xây dựng ứng dụng từ một số đơn vị triển khai cá nhân được gọi là microservices.

Microservices là một chủ đề nóng, giải quyết một số vấn đề thực tế liên quan đến quá trình phát triển và thực thi. Tuy nhiên, trong quá trình làm như vậy, chúng đặt ra những thách thức riêng của mình. Những thách thức này được Spring Cloud đối mặt trực tiếp, đó là một bộ dự án để phát triển ứng dụng cloud-native với Spring.

Spring Cloud bao phủ nhiều lĩnh vực, và không thể bao phủ hết trong cuốn sách này. Để thảo luận đầy đủ về Spring Cloud, tôi đề xuất xem qua cuốn sách "Cloud Native Spring in Action" của Thomas Vitale (Manning, 2020, www.manning.com/books/cloud-native-spring-in-action).

1.4.7 Spring Native

Một phát triển khá mới trong Spring là dự án Spring Native. Dự án thử nghiệm này cho phép biên dịch các dự án Spring Boot thành các tập tin thực thi native bằng cách sử dụng trình biên dịch native-image của GraalVM, dẫn đến việc khởi động ảnh nhanh hơn đáng kể và có trọng lượng nhẹ hơn.

Để biết thêm thông tin về Spring Native, bạn có thể xem tại https://github.com/spring-projects-experimental/spring-native.

Summary
- Spring nhằm đơn giản hóa những thách thức phức tạp của nhà phát triển, như tạo ứng dụng web, làm việc với cơ sở dữ liệu, bảo mật ứng dụng và microservices.
- Spring Boot xây dựng trên nền tảng của Spring để làm cho việc sử dụng Spring trở nên dễ dàng hơn với quản lý dependency đơn giản, auto configuration và cái nhìn runtime.
- Ứng dụng Spring có thể được khởi tạo bằng cách sử dụng Spring Initializr, một ứng dụng web được hỗ trợ mặc định trong hầu hết các môi trường phát triển Java.
- Các thành phần, thường được gọi là beans, trong Spring application context có thể được khai báo một cách rõ ràng bằng Java hoặc XML, được phát hiện thông qua component scan hoặc được tự động cấu hình với các cấu hình tự động của Spring Boot.


Chapter 02 - Developing web
Applications

This chapter covers
 Presenting model data in the browser
 Processing and validating form input
 Choosing a view template library

Ấn tượng ban đầu rất quan trọng. Sự hấp dẫn của bề ngoài có thể bán được một căn nhà ngay trước khi người mua bước vào cửa. Màu sơn đỏ cherry của một chiếc xe có thể thu hút sự chú ý nhiều hơn so với những gì ẩn sau cỗ máy. Văn học tràn ngập những câu chuyện về tình yêu từ cái nhìn đầu tiên.

Nội dung bên trong quan trọng, nhưng cái nằm ở bề ngoài cái được nhìn thấy trước tiên cũng quan trọng. Các ứng dụng mà bạn sẽ xây dựng với Spring sẽ thực hiện mọi loại công việc, bao gồm xử lý dữ liệu, đọc thông tin từ cơ sở dữ liệu và tương tác với các ứng dụng khác. Nhưng ấn tượng đầu tiên mà người dùng ứng dụng của bạn sẽ nhận được đến từ giao diện người dùng. Và trong nhiều ứng dụng, giao diện người dùng đó là một ứng dụng web được trình bày trong trình duyệt.

Trong chương 1, bạn đã tạo ra controller Spring MVC đầu tiên để hiển thị trang chủ của ứng dụng. Nhưng Spring MVC có thể làm nhiều hơn chỉ hiển thị nội dung tĩnh. Trong chương này, bạn sẽ phát triển chức năng quan trọng đầu tiên trong ứng dụng Taco Cloud của mình khả năng thiết kế các loại taco tùy chỉnh. Trong quá trình làm điều này, bạn sẽ khám phá sâu hơn vào Spring MVC, và bạn sẽ thấy cách hiển thị model data và xử lý đầu vào biểu mẫu.

2.1 Displaying information

Về cơ bản, Taco Cloud là nơi bạn có thể đặt hàng taco trực tuyến. Nhưng hơn thế nữa, Taco Cloud muốn cho phép khách hàng của mình thể hiện sự sáng tạo và thiết kế các loại taco tùy chỉnh từ một bảng màu phong phú của các thành phần.

Do đó, ứng dụng web Taco Cloud cần một trang để hiển thị các lựa chọn thành phần để những người nghệ sĩ taco có thể chọn. Các lựa chọn thành phần có thể thay đổi bất kỳ lúc nào, nên chúng không nên được mã cứng vào một trang HTML. Thay vào đó, danh sách các thành phần có sẵn nên được lấy từ cơ sở dữ liệu và được chuyển đến trang để hiển thị cho khách hàng.

Trong một ứng dụng web Spring, công việc của một controller là lấy và xử lý dữ liệu. Và công việc của một chế độ view là biểu diễn dữ liệu đó thành HTML sẽ được hiển thị trong trình duyệt.

Bạn sẽ tạo ra các thành phần sau để hỗ trợ trang tạo taco:
- Một lớp domain xác định các thuộc tính của một thành phần taco.
- Một lớp controller Spring MVC lấy thông tin thành phần và chuyển nó đến chế độ xem.
- Một mẫu xem biểu diễn một danh sách các thành phần trong trình duyệt của người dùng.

Mối quan hệ giữa các thành phần này được minh họa trong hình 2.1.

 

Vì chương này tập trung vào framework web của Spring, chúng ta sẽ hoãn lại mọi vấn đề liên quan đến cơ sở dữ liệu cho đến chương 3. Hiện tại, controller chỉ đơn thuần chịu trách nhiệm cung cấp các thành phần cho chế độ view. Trong chương 3, bạn sẽ chỉnh sửa lại controller để cộng tác với một repository lấy dữ liệu thành phần từ cơ sở dữ liệu.
Trước khi bạn viết controller và chế độ view, hãy xác định loại domain biểu diễn một thành phần. Điều này sẽ thiết lập một nền tảng để phát triển các thành phần web của bạn.

2.1.1 Establishing the domain
Domain ứng dụng là lĩnh vực chủ đề, các ý tưởng và khái niệm ảnh hưởng đến sự hiểu biết về ứng dụng. Trong ứng dụng Taco Cloud, domain bao gồm các đối tượng như thiết kế taco, các thành phần tạo nên thiết kế đó, customers, và taco orders được đặt bởi customers. Hình 2.2 thể hiện những thực thể này và cách chúng liên quan.

 

Để bắt đầu, chúng ta sẽ tập trung vào các taco ingredients. Trong miền của bạn, các taco ingredients là những đối tượng khá đơn giản. Mỗi thành phần có một tên cũng như một loại để có thể được phân loại một cách trực quan (proteins, cheeses, sauces, v.v.). Mỗi Ingredient cũng có một ID để nó có thể được tham chiếu một cách dễ dàng và không thể hiểu nhầm. Lớp Ingredient sau đây định nghĩa domain object mà bạn cần.

Listing 2.1 Defining taco ingredients

package tacos;

import lombok.Data;

@Data
public class Ingredient {
	private final String id;
	private final String name;
	private final String type;
	
	public enum Type {
		WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
	}
}

Như bạn có thể thấy, đây là một lớp domain Java phổ biến, định nghĩa ba thuộc tính cần thiết để mô tả một thành phần. Có thể điều không bình thường nhất về lớp Ingredient như đã định nghĩa trong danh sách 2.1 là nó có vẻ thiếu bộ phương thức getter và setter thông thường, chưa kể đến các phương thức hữu ích như equals(), hashCode(), toString(), và các phương thức khác.

Bạn không thấy chúng trong danh sách một phần là để tiết kiệm không gian, nhưng cũng vì bạn đang sử dụng một thư viện tuyệt vời gọi là Lombok để tự động tạo ra những phương thức đó vào thời điểm biên dịch để chúng sẽ sẵn có khi chạy. Trong thực tế, chú thích @Data ở cấp độ lớp được cung cấp bởi Lombok và báo cho Lombok biết để tạo ra tất cả những phương thức bị thiếu đó cũng như một hàm tạo chấp nhận tất cả các thuộc tính cuối cùng làm đối số. Bằng cách sử dụng Lombok, bạn có thể giữ mã nguồn cho Ingredient gọn gàng và tinh tế.

Lombok không phải là một thư viện của Spring, nhưng nó lại rất hữu ích đến mức tôi thấy khó khăn khi phát triển mà không có nó. Ngoài ra, nó là một "người cứu thế" khi tôi cần giữ ví dụ mã nguồn trong sách ngắn gọn và ngọt ngào.

Để sử dụng Lombok, bạn cần thêm nó vào dự án của mình như một phụ thuộc. Nếu bạn đang sử dụng Spring Tool Suite, chỉ cần nhấp phải chuột vào tệp pom.xml chọn “Spring” và chọn "Add Starters" từ menu ngữ cảnh Spring. Cùng một lựa chọn các phụ thuộc mà bạn được cung cấp trong chương 1 (trong hình 1.4) sẽ xuất hiện, cho bạn cơ hội để thêm hoặc thay đổi các phụ thuộc đã chọn của mình. Tìm Lombok trong Developer Tools, đảm bảo nó được chọn, và nhấp vào OK; Spring Tool Suite sẽ tự động thêm nó vào cấu hình xây dựng của bạn.
Nếu bạn quyết định thêm Lombok vào dự án của mình bằng cách thủ công, bạn cũng muốn loại bỏ nó khỏi plugin Maven của Spring Boot trong phần `<build>` của tệp pom.xml như sau:

<build>
<plugins>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
<configuration>
<excludes>
<exclude>
<groupId>org.projectlombok</groupId>
<artifactId>lombok</artifactId>
</exclude>
</excludes>
</configuration>
</plugin>
</plugins>
</build>

Phép màu của Lombok được áp dụng vào thời điểm biên dịch, vì vậy không cần phải có nó khi chạy ứng dụng. Việc loại bỏ nó như vậy giữ cho nó không xuất hiện trong tệp JAR hoặc WAR kết quả.

Phụ thuộc Lombok cung cấp các chú thích Lombok (như @Data) trong quá trình phát triển và tạo ra các phương thức tự động trong quá trình biên dịch. Nhưng bạn cũng cần thêm Lombok như một tiện ích mở rộng trong IDE của bạn, hoặc IDE của bạn sẽ phàn nàn, với lỗi về các phương thức bị thiếu và các thuộc tính cuối cùng không được thiết lập. Truy cập https://projectlombok.org/ để biết cách cài đặt Lombok trong IDE mà bạn chọn.

Tôi nghĩ bạn sẽ thấy Lombok rất hữu ích, nhưng hãy biết rằng nó là tùy chọn. Bạn không cần nó để phát triển ứng dụng Spring, nên nếu bạn muốn không sử dụng nó, hãy thoải mái viết những phương thức còn thiếu bằng tay. Tiến lên đi ... tôi sẽ đợi.
Nguyên liệu là những khối xây dựng cơ bản của một chiếc taco. Để mô tả cách những nguyên liệu đó được kết hợp, chúng ta sẽ định nghĩa lớp domain Taco, như được hiển thị dưới đây.




Listing 2.2 A domain object defining a taco design

package tacos;

import java.util.List;

public class Taco {
	private String name;
	
	private List<Ingredient> ingredients;

	public Taco(String name, List<Ingredient> ingredients) {
		super();
		this.name = name;
		this.ingredients = ingredients;
	}

	public Taco() {
		
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public List<Ingredient> getIngredients() {
		return ingredients;
	}

	public void setIngredients(List<Ingredient> ingredients) {
		this.ingredients = ingredients;
	}
	
}

Bây giờ chúng ta đã định nghĩa Ingredient và Taco, chúng ta cần thêm một lớp domain nữa để xác định cách khách hàng chỉ định các chiếc taco mà họ muốn đặt hàng, cùng với thông tin thanh toán và giao hàng. Đó chính là công việc của lớp TacoOrder, được hiển thị ở đây.
Listing 2.3 A domain object for taco orders

public class TacoOrder {
	private String deliveryName;
	private String deliveryStreet;
	private String deliveryCity;
	private String deliveryState;
	private String deliveryZip;
	private String ccNumber;
	private String ccExpiration;
	private String ccCVV;
	
	private List<Taco> tacos = new ArrayList<>();
	
	public void addTaco(Taco taco) {
		this.tacos.add(taco);
	}

	


Hãy thêm một số controllers để xử lý các yêu cầu web trong ứng dụng.

2.1.2 Creating a controller class

Các controllers là những thành phần quan trọng trong framework MVC của Spring. Nhiệm vụ chính của chúng là xử lý các yêu cầu HTTP và entiher chuyển yêu cầu đó đến một view để render HTML (hiển thị trên trình duyệt) hoặc ghi dữ liệu trực tiếp vào phần thân của một phản hồi (RESTful). Trong chương này, chúng ta đang tập trung vào các loại controllers sử dụng views để tạo nội dung cho trình duyệt web. Khi chúng ta đến chương 7, chúng ta sẽ xem xét cách viết controllers để xử lý các yêu cầu trong một REST API.

Đối với ứng dụng Taco Cloud, bạn cần một controller đơn giản sẽ thực hiện các công việc sau:
- Xử lý các yêu cầu HTTP GET với đường dẫn yêu cầu là /design
- Xây dựng một list Ingredients
- Đưa ra yêu cầu và dữ liệu nguyên liệu đó đến một view template để render như HTML và gửi đến trình duyệt web đang yêu cầu.

Lớp DesignTacoController trong đoạn mã tiếp theo đáp ứng các yêu cầu đó:
Listing 2.4 The beginnings of a Spring controller class

package tacos.web;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.SessionAttributes;

import lombok.extern.slf4j.Slf4j;
import tacos.Ingredient;
import tacos.Ingredient.Type;
import tacos.Taco;
import tacos.TacoOrder;

@Slf4j
@Controller
@RequestMapping(path = "/design")
@SessionAttributes("tacoOrder")
public class DesignTacoController {

	@ModelAttribute
	public void addIngredientsToModel(Model model) {
		List<Ingredient> ingredients = Arrays.asList(
				new Ingredient("FLTO", "Flour Tortilla", Type.WRAP),
				new Ingredient("COTO", "Corn Tortilla", Type.WRAP),
				new Ingredient("GRBF", "Ground Beef", Type.PROTEIN),
				new Ingredient("CARN", "Carnitas", Type.PROTEIN),
				new Ingredient("TMTO", "Diced Tomatoes", Type.VEGGIES),
				new Ingredient("LETC", "Lettuce", Type.VEGGIES),
				new Ingredient("CHED", "Cheddar", Type.CHEESE),
				new Ingredient("JACK", "Monterrey Jack", Type.CHEESE),
				new Ingredient("SLSA", "Salsa", Type.SAUCE),
				new Ingredient("SRCR", "Sour Cream", Type.SAUCE)
		);
		
		Type[] types = Ingredient.Type.values();
		for (Type type : types) {
			model.addAttribute(type.toString().toLowerCase());
			filterByType(ingredients, type);
		}
	}
	
	@ModelAttribute(name = "tacoOrder")
	public TacoOrder order() {
		return new TacoOrder();
	}
	
	@ModelAttribute(name = "taco")
	public Taco taco() {
		return new Taco();
	}
	
	@GetMapping
	public String showDesignForm() {
		return "design";
	}
	
	private Iterable<Ingredient> filterByType (
			List<Ingredient> ingredients, 
			Type type) {
		return ingredients.stream()
				.filter(x -> x.getType().equals(type))
				.collect(Collectors.toList());
	}
}


Điều đầu tiên cần lưu ý về DesignTacoController là tập hợp các chú thích được áp dụng ở mức lớp. Chú thích đầu tiên, @Slf4j, là một chú thích được cung cấp bởi Lombok, và vào thời điểm biên dịch, nó sẽ tự động tạo ra một thuộc tính tĩnh Logger SLF4J (Simple Logging Facade for Java, https://www.slf4j.org/) trong lớp. Chú thích nhỏ này có cùng hiệu quả như bạn thêm dòng mã sau vào trong lớp một cách rõ ràng:

private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(DesignTacoController.class);

Bạn sẽ sử dụng Logger này một chút sau.

Chú thích tiếp theo được áp dụng cho DesignTacoController là @Controller. Chú thích này định danh lớp này là một controller và đánh dấu nó là ứng viên cho việc component scan, để Spring có thể phát hiện nó và tự động tạo một instance của DesignTacoController như một bean Spring application context.

DesignTacoController cũng được đánh dấu với @RequestMapping. Chú thích @RequestMapping, khi được áp dụng ở mức lớp, chỉ định loại yêu cầu mà controller này xử lý. Trong trường hợp này, nó chỉ định rằng DesignTacoController sẽ xử lý các yêu cầu có đường dẫn bắt đầu bằng /design.

Cuối cùng, bạn thấy rằng DesignTacoController được đánh dấu với @SessionAttributes ("tacoOrder"). Điều này chỉ ra rằng đối tượng TacoOrder được đưa vào model một chút sau trong lớp này nên được duy trì trong phiên làm việc. Điều này quan trọng vì việc tạo một chiếc taco cũng là bước đầu tiên trong việc tạo một đơn hàng, và đơn hàng chúng ta tạo ra sẽ cần được giữ trong phiên làm việc để có thể bao gồm nhiều yêu cầu.

@SessionAttributes("tacoOrder"): Đây là một chú thích đặc biệt của Spring. Nói cho Spring biết rằng tacoOrder là một thuộc tính (attribute) trong mô hình (model) của controller này và nó nên được duy trì trong phiên làm việc (session).

Duy trì trong phiên làm việc: Bởi vì @SessionAttributes("tacoOrder") được sử dụng, đối tượng TacoOrder này sẽ được giữ lại trong phiên làm việc của người dùng. Điều này có ý nghĩa khi người dùng thực hiện nhiều yêu cầu (ví dụ: thêm nhiều tacos vào đơn hàng) và chúng cần được liên kết với cùng một phiên làm việc.

HANDLING A GET REQUEST

Đặc tả `@RequestMapping` ở cấp độ lớp được làm rõ thông qua chú thích `@GetMapping` được áp dụng cho phương thức `showDesignForm()`. `@GetMapping`, kết hợp với `@RequestMapping` ở cấp độ lớp, xác định rằng khi một yêu cầu HTTP GET được nhận cho /design, Spring MVC sẽ gọi `showDesignForm()` để xử lý yêu cầu.

`@GetMapping` chỉ là một thành viên của họ chú thích đánh dấu yêu cầu trong Spring MVC. Bảng 2.1 liệt kê tất cả các chú thích đánh dấu yêu cầu có sẵn trong Spring MVC.

Table 2.1 Spring MVC request-mapping annotations

Annotation	Description
@RequestMapping	General-purpose request handling
@GetMapping	Handles HTTP GET requests
@PostMapping	Handles HTTP POST requests
@PutMapping	Handles HTTP PUT requests
@DeleteMapping	Handles HTTP DELETE requests
@PatchMapping	Handles HTTP PATCH requests

Khi `showDesignForm()` xử lý một yêu cầu GET cho /design, nó thực sự không làm nhiều. Điều chính mà nó thực hiện chính là trả về một giá trị String là "design", đây là tên logic của view sẽ được sử dụng để hiển thị model lên trình duyệt. Nhưng trước khi thực hiện điều đó, nó cũng điền dữ liệu cho đối tượng Model được cung cấp bằng một đối tượng Taco trống dưới một khóa có tên là "design". Điều này sẽ cho phép biểu mẫu có một bảng trắng để tạo ra một tác phẩm nghệ thuật taco.

Có vẻ như một request GET đến /design không làm nhiều. Nhưng ngược lại, có một chút nhiều hơn trong phương thức `showDesignForm()`. Bạn cũng sẽ thấy một phương thức có tên là `addIngredientsToModel()` được chú thích bằng `@ModelAttribute`. Phương thức này cũng sẽ được gọi khi một request được xử lý và sẽ xây dựng một danh sách các đối tượng Ingredient để đưa vào model. Danh sách được cứng cố định tạm thời. Khi chúng ta đến chương 3, bạn sẽ rút danh sách các thành phần taco có sẵn từ cơ sở dữ liệu.

Khi List Ingredient đã sẵn sàng, các dòng mã tiếp theo của `addIngredientsToModel()` lọc danh sách theo loại thành phần bằng cách sử dụng một phương thức trợ giúp có tên là `filterByType()`. Sau đó, một danh sách các loại thành phần được thêm làm attribute vào đối tượng Model sẽ được chuyển vào `showDesignForm()`. Model là một đối tượng chuyển dữ liệu giữa một controller và bất kỳ view nào được giao với việc hiển thị dữ liệu đó. Cuối cùng, dữ liệu được đặt trong các thuộc tính của đối tượng Model được sao chép vào các request attribute servlet, nơi view có thể tìm thấy chúng và sử dụng chúng để hiển thị một trang trên trình duyệt của người dùng.

2.1.3 Designing the view
Sau khi bộ điều khiển hoàn thành công việc của mình, đến lúc view bắt đầu hoạt động. Spring cung cấp một số lựa chọn tuyệt vời để định nghĩa views, bao gồm JavaServer Pages (JSP), Thymeleaf, FreeMarker, Mustache, và các mẫu dựa trên Groovy. Hiện tại, chúng ta sẽ sử dụng Thymeleaf, sự lựa chọn đã được thực hiện trong chương 1 khi bắt đầu dự án. Chúng ta sẽ xem xét một số lựa chọn khác trong phần 2.5.
Chúng ta đã thêm Thymeleaf làm phụ thuộc trong chương 1. Tại thời điểm chạy, Spring Boot tự động cấu hình nhìn thấy rằng Thymeleaf có sẵn trong classpath và tự động tạo các bean hỗ trợ views Thymeleaf cho Spring MVC.
Thư viện view như Thymeleaf được thiết kế để tách rời khỏi bất kỳ framework web cụ thể nào. Do đó, chúng không biết về trừu tượng hóa model của Spring và không thể làm việc với dữ liệu mà controller đặt vào Model. Nhưng chúng có thể làm việc với các thuộc tính của servlet request. Do đó, trước khi Spring chuyển giao yêu cầu cho một view, nó sao chép dữ liệu model vào các request attribute mà Thymeleaf và các lựa chọn view-templating khác có sẵn để truy cập.

Các template Thymeleaf chỉ là HTML với một số thuộc tính phần tử bổ sung để hướng dẫn một mẫu trong quá trình hiển thị dữ liệu yêu cầu. Ví dụ, nếu có một request attribute có khóa là "message" và bạn muốn nó được hiển thị vào một thẻ HTML <p> bởi Thymeleaf, bạn sẽ viết như sau trong mẫu Thymeleaf của mình:
<p th:text="${message}">placeholder message</p>
Khi mẫu được hiển thị thành HTML, nội dung của phần tử <p> sẽ được thay thế bằng giá trị của request attribute servlet có khóa là "message". Thuộc tính th:text là một thuộc tính không gian tên của Thymeleaf thực hiện quá trình thay thế. Toán tử ${} cho biết nó sẽ sử dụng giá trị của một request attribute ("message", trong trường hợp này).

Thymeleaf cũng cung cấp một thuộc tính khác, th:each, lặp qua một bộ sưu tập các phần tử, hiển thị HTML một lần cho mỗi mục trong bộ sưu tập. Thuộc tính này sẽ hữu ích khi bạn thiết kế giao diện để liệt kê các nguyên liệu taco từ Model. Ví dụ, để hiển thị danh sách các nguyên liệu "wrap", bạn có thể sử dụng đoạn mã HTML sau:

```html
<h3>Designate your wrap:</h3>
<div th:each="ingredient : ${wrap}">
    <input th:field="*{ingredients}" type="checkbox" th:value="${ingredient.id}"/>
    <span th:text="${ingredient.name}">INGREDIENT</span><br/>
</div>
```

Ở đây, bạn sử dụng thuộc tính th:each trên thẻ <div> để lặp lại quá trình hiển thị của thẻ <div> một lần cho mỗi phần tử trong bộ sưu tập được tìm thấy trong request attribute wrap. Trong mỗi lần lặp, phần tử ingredient được gán cho một biến Thymeleaf có tên là ingredient.

Bên trong thẻ <div> là một phần tử hộp kiểm <input> và một phần tử <span> để cung cấp một nhãn cho hộp kiểm. Hộp kiểm sử dụng th:value của Thymeleaf để đặt giá trị thuộc tính value của phần tử <input> được hiển thị thành giá trị được tìm thấy trong thuộc tính id của ingredient. Thuộc tính th:field cuối cùng đặt giá trị thuộc tính name của phần tử <input> và được sử dụng để nhớ xem hộp kiểm có được chọn hay không. Khi chúng ta thêm xác thực sau này, điều này sẽ đảm bảo rằng hộp kiểm giữ trạng thái của mình nếu biểu mẫu cần được hiển thị lại sau một lỗi xác thực. Phần tử <span> sử dụng th:text để thay thế văn bản "INGREDIENT" bằng giá trị thuộc tính name của ingredient.

Khi được hiển thị với dữ liệu mô hình thực tế, một lần lặp của vòng lặp <div> có thể trông như sau:

```html
<div>
    <input name="ingredients" type="checkbox" value="FLTO" />
    <span>Flour Tortilla</span><br/>
</div>
```

Cuối cùng, đoạn mã Thymeleaf trước đó chỉ là một phần của một biểu mẫu HTML lớn hơn thông qua đó người dùng nghệ sĩ taco của bạn sẽ gửi các tác phẩm ngon miệng của họ. Mẫu Thymeleaf đầy đủ, bao gồm tất cả các loại nguyên liệu và biểu mẫu, được hiển thị trong đoạn mã tiếp theo.

Listing 2.5 The complete design-a-taco page
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Taco Cloud</title>
	<link rel="stylesheet" th:href="@{/styles.css}" />
</head>

<body>
	<h1>Design your taco!</h1>	
	<img th:src="@{/images/TacoCloud.png}" alt="" />
	
	<form method="post" th:object="${taco}">
	<div class="grid">
		
		<div class="ingredient-group" id="wraps">
		<h3>Designate your wrap:</h3>
		<div th:each="ingredient : ${wrap}">
			<input th:field="*{ingredients}" type="checkbox" 
					th:value="ingredient.id">
			<span th:text="${ingredient.name}">INGREDIENT</span> <br />
		</div>
		</div>
		
		<div class="ingredient-group" id="proteins">
		<h3>Pick your protein:</h3>
		<div th:each="ingredient : ${protein}">
			<input th:field="*{ingredients}" type="checkbox"
					th:value="${ingredient.id}"/>
			<span th:text="${ingredient.name}">INGREDIENT</span><br/>
		</div>
		</div>
		
		<div class="ingredient-group" id="proteins">
		<h3>Choose your cheese:</h3>
		<div th:each="ingredient : ${cheese}">
			<input th:field="*{ingredients}" type="checkbox"
					th:value="${ingredient.id}"/>
			<span th:text="${ingredient.name}">INGREDIENT</span><br/>
		</div>
		</div>
		
		<div class="ingredient-group" id="proteins">
		<h3>Determine your veggies:</h3>
		<div th:each="ingredient : ${veggies}">
			<input th:field="*{ingredients}" type="checkbox"
					th:value="${ingredient.id}"/>
			<span th:text="${ingredient.name}">INGREDIENT</span><br/>
		</div>
		</div>
		
		<div class="ingredient-group" id="proteins">
		<h3>Select your sauce:</h3>
		<div th:each="ingredient : ${sauce}">
			<input th:field="*{ingredients}" type="checkbox"
					th:value="${ingredient.id}"/>
			<span th:text="${ingredient.name}">INGREDIENT</span><br/>
		</div>
		</div>
		
	</div>
	
	<div>
		<h3>Name your taco creation:</h3>
		<input type="text" th:fieldd="*{name}" />
		<br />
		
		<button>Submit Your Taco</button>
	</div>
	</form>
</body>

</html>

Như bạn có thể thấy, bạn lặp lại đoạn mã <div> cho mỗi loại nguyên liệu và bạn bao gồm một nút Gửi và trường nơi người dùng có thể đặt tên cho sáng tạo của họ.
Nó cũng đáng lưu ý rằng mẫu đầy đủ bao gồm hình ảnh biểu tượng Taco Cloud và một tham chiếu <link> đến một bảng kiểu. Trong cả hai trường hợp, toán tử @{} của Thymeleaf được sử dụng để tạo ra một đường dẫn liên quan đến ngữ cảnh đến các tác phẩm nghệ thuật tĩnh mà các thẻ này đang tham chiếu. Như bạn đã học trong chương 1, nội dung tĩnh trong ứng dụng Spring Boot được phục vụ từ thư mục /static ở gốc của classpath.
Bây giờ khi controller và view của bạn đã hoàn chỉnh, bạn có thể khởi chạy ứng dụng để xem thành quả của công việc của mình. Chúng ta có nhiều cách để chạy một ứng dụng Spring Boot. Trong chương 1, tôi đã chỉ cho bạn cách chạy ứng dụng bằng cách nhấp vào nút Start trên Spring Boot Dashboard. Bất kỳ cách nào bạn khởi chạy ứng dụng Taco Cloud, sau khi nó bắt đầu, hãy mở trình duyệt của bạn và truy cập địa chỉ 
http:/ /localhost:8080/design. Bạn nên thấy một trang web giống như hình 2.3.
Nó trông rất tốt! Một nghệ sĩ taco khi đến thăm trang web của bạn sẽ được hiển thị một biểu mẫu chứa một bảng nguyên liệu taco mà họ có thể sử dụng để tạo ra tác phẩm của mình. Nhưng điều gì sẽ xảy ra khi họ nhấp vào nút Gửi Taco của bạn?
DesignTacoController của bạn vẫn chưa sẵn sàng chấp nhận sự sáng tạo của taco. Nếu biểu mẫu thiết kế được gửi, người dùng sẽ được hiển thị một lỗi. (Cụ thể, đó sẽ là một lỗi HTTP 405: Phương thức Yêu cầu "POST" không được hỗ trợ.) Hãy sửa lại điều đó bằng cách viết thêm mã điều khiển để xử lý việc gửi biểu mẫu.

Giải ngố: Annotation như @GetMapping sẽ chỉ định phương thức nào được sử dụng để xử lý yêu cầu GET đến một đường dẫn cụ thể.
Ví dụ:
@GetMapping
public String showDesignForm() {return "design";}

Phương thức được sử dụng để xử lý cho Method GET là phương thức showDesignForm()

2.2 Processing form submission

Nếu bạn nhìn lại vào thẻ `<form>` trong view của mình, bạn có thể thấy rằng thuộc tính `method` của nó được đặt là POST. Hơn nữa, thẻ `<form>` không khai báo thuộc tính `action`. Điều này có nghĩa là khi form được gửi đi, trình duyệt sẽ thu thập tất cả dữ liệu trong form và gửi nó đến máy chủ trong một yêu cầu HTTP POST đến cùng một đường dẫn mà một yêu cầu GET đã hiển thị form - đó là đường dẫn /design.

Do đó, bạn cần một phương thức xử lý của controller để xử lý yêu cầu POST đó. Bạn cần viết một phương thức xử lý yêu cầu mới trong `DesignTacoController` để xử lý một yêu cầu POST đến /design.
Trong đoạn mã 2.4, bạn đã sử dụng chú thích @GetMapping để chỉ định rằng phương thức showDesignForm() sẽ xử lý các yêu cầu HTTP GET đối với /design. Tương tự như @GetMapping xử lý các yêu cầu GET, bạn có thể sử dụng @PostMapping để xử lý các yêu cầu POST. Để xử lý việc gửi thiết kế taco, thêm phương thức processTaco() trong đoạn mã sau vào DesignTacoController.





Listing 2.6 Handling POST requests with @PostMapping
@PostMapping
public String processTaco(Taco taco, 
		@ModelAttribute TacoOrder tacoOrder) {
	tacoOrder.addTaco(taco);
	log.info("Processing taco: {}", taco);
		
	return "redirect:/orders/current";
}

Khi áp dụng cho phương thức processTaco(), @PostMapping phối hợp với @RequestMapping ở cấp độ lớp để chỉ định rằng processTaco() sẽ xử lý các yêu cầu POST đối với /design. Điều này chính xác là những gì bạn cần để xử lý các tác phẩm nghệ sĩ taco được nộp.

Khi form được gửi, các trường th:field trong biểu mẫu được liên kết với các thuộc tính của một đối tượng Taco (lớp của nó được hiển thị trong đoạn mã kế tiếp) được chuyển làm tham số vào processTaco(). Từ đó, phương thức processTaco() có thể thực hiện bất kỳ điều gì với đối tượng Taco. Trong trường hợp này, nó thêm Taco vào đối tượng TacoOrder được chuyển làm tham số vào phương thức và sau đó ghi log. @ModelAttribute được áp dụng cho tham số TacoOrder chỉ ra rằng nó nên sử dụng đối tượng TacoOrder đã được đặt vào model thông qua phương thức order() được đánh dấu bằng @ModelAttribute được hiển thị trước đó trong đoạn mã 2.4.
@ModelAttribute(name = "tacoOrder")
public TacoOrder order() {
	return new TacoOrder();
}

Nếu bạn nhìn lại vào biểu mẫu trong đoạn mã 2.5, bạn sẽ thấy một số yếu tố checkbox, tất cả đều có tên là ingredients, và một yếu tố nhập văn bản có tên là name. Những trường trong biểu mẫu tương ứng trực tiếp với các thuộc tính ingredients và name của lớp Taco. Trường name trên biểu mẫu chỉ cần chứa một giá trị văn bản đơn giản. Do đó, thuộc tính name của Taco có kiểu String. Các hộp kiểm ingredients cũng có giá trị văn bản, nhưng vì có thể chọn không hoặc nhiều, thuộc tính ingredients mà chúng được liên kết với là một List<Ingredient> sẽ chứa từng thành phần được chọn.

Nhưng đợi đã. Nếu các hộp kiểm thành phần có giá trị văn bản (ví dụ, String), nhưng đối tượng Taco biểu thị một danh sách các thành phần dưới dạng List<Ingredient>, thì có sự không phù hợp đúng không? Làm thế nào một danh sách văn bản như ["FLTO", "GRBF", "LETC"] có thể được gắn kết với một danh sách các đối tượng Ingredient là các đối tượng phong phú không chỉ chứa một ID mà còn chứa một tên mô tả và loại nguyên liệu?
Đó là lúc một converter trở nên hữu ích. Một converter là bất kỳ lớp nào thực hiện giao diện Converter của Spring và thực hiện phương thức convert() để chuyển đổi một giá trị từ một giá trị khác. Để chuyển đổi một chuỗi thành Ingredient, chúng ta sẽ sử dụng IngredientByIdConverter như sau.

Listing 2.7 Converting strings to ingredients

@Component
public class IngredientByIdConverter 
	implements Converter<String, Ingredient>{

	private Map<String, Ingredient> ingredientMap = new HashMap<>();
	
	
	
	public IngredientByIdConverter() {
		ingredientMap.put("FLTO",
				new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
				ingredientMap.put("COTO",
				new Ingredient("COTO", "Corn Tortilla", Type.WRAP));
				ingredientMap.put("GRBF",
				new Ingredient("GRBF", "Ground Beef", Type.PROTEIN));
				ingredientMap.put("CARN",
				new Ingredient("CARN", "Carnitas", Type.PROTEIN));
				ingredientMap.put("TMTO",
				new Ingredient("TMTO", "Diced Tomatoes", Type.VEGGIES));
				ingredientMap.put("LETC",
				new Ingredient("LETC", "Lettuce", Type.VEGGIES));
				ingredientMap.put("CHED",
				new Ingredient("CHED", "Cheddar", Type.CHEESE));
				ingredientMap.put("JACK",
				new Ingredient("JACK", "Monterrey Jack", Type.CHEESE));
				ingredientMap.put("SLSA",
				new Ingredient("SLSA", "Salsa", Type.SAUCE));
				ingredientMap.put("SRCR",
				new Ingredient("SRCR", "Sour Cream", Type.SAUCE));
	}

	@Override
	public Ingredient convert(String id) {
		return ingredientMap.get(id);
	}

Vì chúng ta chưa có một cơ sở dữ liệu để lấy đối tượng Ingredient, constructor của IngredientByIdConverter tạo một Map có key là một chuỗi là ID của nguyên liệu và giá trị là các đối tượng Ingredient. Trong chương 3, chúng ta sẽ điều chỉnh converter này để lấy dữ liệu nguyên liệu từ cơ sở dữ liệu thay vì được đặt cứng như thế này. Phương thức convert() sau đó chỉ đơn giản nhận một chuỗi là ID của nguyên liệu và sử dụng nó để tìm kiếm Ingredient từ trong map.

Lưu ý rằng IngredientByIdConverter được đánh dấu bằng @Component để làm cho nó có thể được phát hiện như một bean trong ngữ cảnh ứng dụng Spring. Spring Boot tự động cấu hình sẽ phát hiện điều này và bất kỳ bean Converter nào khác, và sẽ tự động đăng ký chúng với Spring MVC để sử dụng khi chuyển đổi các tham số yêu cầu thành các thuộc tính được ràng buộc là cần thiết.

Hiện tại, phương thức processTaco() không thực hiện bất kỳ công việc nào với đối tượng Taco. Trên thực tế, nó không thực hiện nhiều công việc lắm. Điều này hoàn toàn chấp nhận được. Trong chương 3, bạn sẽ thêm một số logic liên quan đến cơ sở dữ liệu để lưu Taco đã được gửi.

Tương tự như phương thức showDesignForm(), processTaco() kết thúc bằng việc trả về một giá trị là chuỗi. Giống như showDesignForm(), giá trị trả về chỉ định một view sẽ được hiển thị cho người dùng. Nhưng điều khác biệt là giá trị trả về từ processTaco() có tiền tố là "redirect:", chỉ định rằng đây là một redirect view. Cụ thể hơn, nó cho biết sau khi processTaco() hoàn thành, trình duyệt của người dùng sẽ được chuyển hướng đến đường dẫn tương đối /orders/current.
Ý tưởng là sau khi tạo một taco, người dùng sẽ được chuyển hướng đến một biểu mẫu đặt hàng, từ đó họ có thể đặt hàng để giao tận nơi. Nhưng hiện tại, bạn chưa có một controller để xử lý yêu cầu cho /orders/current.
Dựa trên những gì bạn biết về @Controller, @RequestMapping và @GetMapping, bạn có thể dễ dàng tạo một controller như sau:

Listing 2.8 A controller to present a taco order form 
@Slf4j
@Controller
@RequestMapping("/orders")
@SessionAttributes("tacoOrder")
public class OrderController {

	@GetMapping("/current")
	public String orderForm() {
		return "orderForm";
	}
}
Một lần nữa, bạn sử dụng chú thích @Slf4j của Lombok để tạo một đối tượng Logger của SLF4J tự do tại thời điểm biên dịch. Bạn sẽ sử dụng Logger này trong một khoảnh khắc để ghi chi tiết về đơn hàng được gửi.

Chú thích @RequestMapping ở cấp độ lớp chỉ định rằng bất kỳ phương thức xử lý yêu cầu nào trong controller này sẽ đều xử lý yêu cầu có đường dẫn bắt đầu bằng /orders. Khi kết hợp với chú thích @GetMapping ở cấp độ phương thức, nó chỉ định rằng phương thức orderForm() sẽ xử lý các yêu cầu HTTP GET cho /orders/current.

Còn đối với phương thức orderForm() chính nó, nó cực kỳ cơ bản, chỉ trả về một tên view logic là orderForm. Khi bạn có một cách để lưu trữ tạo ra các taco vào cơ sở dữ liệu trong chương 3, bạn sẽ quay lại phương thức này và sửa đổi nó để điền model với một list các đối tượng Taco để đặt vào đơn hàng.

View orderForm được cung cấp bởi một template Thymeleaf có tên là orderForm.html, được hiển thị dưới đây.

Listing 2.9 A taco order form view 
<head>
	<meta charset="UTF-8" />
	<title>Taco Cloud</title>
	<link rel="stylesheet" th:href="@{/styles.css}" />
</head>
<body>
	
	<form method="post" th:action="@{/orders}" th:object="${tacoOrder}">
		<h1>Order your taco creations!</h1>
		
		<img th:src="@{/images/TacoCloud.png}" alt="" />
		
		<h3>Your tacos in this order:</h3>
		<a th:href="@{/design}" id="another">Design another taco</a> <br />
		
		<ul>
			<li th:each="taco : ${tacoOrder.tacos}">
				<span th:text="${taco.name}">taco name</span>	
			</li>
		</ul>
		
		<h3>Deliver my taco masterpieces to...</h3>
		<label for="deliveryName">Name: </label>
		<input type="text" th:field="*{deliveryName}" />
		<br />
		
		<label for="deliveryStreet">Street address: </label>
		<input type="text" th:field="*{deliveryStreet}" />
		<br />
		
		<label for="deliveryCity">City: </label>
		<input type="text" th:field="*{deliveryCity}" />
		<br />
		
		<label for="deliveryState">State: </label>
		<input type="text" th:field="*{deliveryState}" />
		<br />
		
		<label for="deliveryZip">Zip code: </label>
		<input type="text" th:field="*{deliveryZip}" />
		<br />
		
		<h3>Here's how I'll pay...</h3>
		<label for="ccNumber">Credit Card #: </label>
		<input type="text" th:field="*{ccNumber}" />
		<br />
		
		<label for="ccExpiration">Expiration: </label>
		<input type="text" th:field="*{ccExpiration}" />
		<br />
		
		<label for="ccCVV">CVV: </label>
		<input type="text" th:field="*{ccCVV}" />
		<br />
		
		<input type="submit" value="Submit Order" />
	</form>
	
</body>
</html>

Đa phần, view orderForm.html là nội dung HTML/Thymeleaf điển hình, với rất ít điều đáng chú ý. Nó bắt đầu bằng việc liệt kê các taco đã được thêm vào đơn hàng. Nó sử dụng th:each của Thymeleaf để lặp qua thuộc tính tacos của đơn hàng khi tạo danh sách.

Sau đó, nó hiển thị biểu mẫu đặt hàng. Tuy nhiên, lưu ý rằng thẻ `<form>` ở đây khác với thẻ `<form>` được sử dụng trong ví dụ 2.5 vì nó cũng chỉ định một hành động của biểu mẫu. Nếu không có hành động được chỉ định, biểu mẫu sẽ gửi một yêu cầu HTTP POST trở lại cùng URL mà biểu mẫu được hiển thị.

Nhưng ở đây, bạn chỉ định rằng biểu mẫu nên được gửi đi với phương thức POST đến /orders (sử dụng toán tử @{...} của Thymeleaf để tạo đường dẫn liên quan đến ngữ cảnh).

Do đó, bạn sẽ cần thêm một phương thức khác vào lớp OrderController của mình để xử lý các yêu cầu POST cho /orders. Bạn sẽ không có cách nào để lưu trữ các đơn đặt hàng cho đến chương tiếp theo, vì vậy ở đây bạn sẽ giữ nó đơn giản—giống như bạn thấy trong đoạn mã tiếp theo.

Listing 2.10 Handling a taco order submission 
@PostMapping
public String processOrder(TacoOrder order, SessionStatus sessionStatus) {
	log.info("Order submitted: {}", order);
	sessionStatus.setComplete();
	
	return "redirect:/";
}

Khi phương thức processOrder() được gọi để xử lý một đơn đặt hàng đã được gửi, nó nhận một đối tượng TacoOrder có các thuộc tính được liên kết với các field của form đã được gửi. TacoOrder, giống như Taco, là một lớp khá đơn giản mang thông tin về đơn đặt hàng.
Trong trường hợp của phương thức processOrder(), đối tượng TacoOrder chỉ được ghi log. Chúng ta sẽ tìm hiểu cách lưu trữ nó vào cơ sở dữ liệu trong chương tiếp theo. Tuy nhiên, trước khi processOrder() kết thúc, nó cũng gọi setComplete() trên đối tượng SessionStatus được truyền vào như một tham số. Đối tượng TacoOrder được tạo ban đầu và đặt vào session khi người dùng tạo ra taco đầu tiên của họ. Bằng cách gọi setComplete(), chúng ta đảm bảo rằng session sẽ được dọn dẹp và sẵn sàng cho một đơn đặt hàng mới vào lần tiếp theo người dùng tạo ra một taco..
Bây giờ, sau khi bạn đã phát triển một OrderController và view biểu mẫu đặt hàng, bạn có thể thử nghiệm nó. Mở trình duyệt của bạn tới http://localhost:8080/design, chọn một số thành phần cho taco của bạn và nhấp vào nút Submit Your Taco. Bạn nên thấy một biểu mẫu tương tự như được hiển thị trong hình 2.4.
Điền vào một số trường trong biểu mẫu và nhấn nút Submit Order. Trong quá trình làm, hãy theo dõi nhật ký ứng dụng để xem thông tin đơn đặt hàng của bạn. Khi tôi thử nghiệm, mục nhật ký trông giống như sau (đã định dạng lại để vừa với chiều rộng của trang này):

Order submitted: TacoOrder(deliveryName=Craig Walls, deliveryStreet=1234 7th
Street, deliveryCity=Somewhere, deliveryState=Who knows?,
deliveryZip=zipzap, ccNumber=Who can guess?, ccExpiration=Some day,
ccCVV=See-vee-vee, tacos=[Taco(name=Awesome Sauce, ingredients=[
Ingredient(id=FLTO, name=Flour Tortilla, type=WRAP), Ingredient(id=GRBF,
name=Ground Beef, type=PROTEIN), Ingredient(id=CHED, name=Cheddar,
type=CHEESE), Ingredient(id=TMTO, name=Diced Tomatoes, type=VEGGIES),
Ingredient(id=SLSA, name=Salsa, type=SAUCE), Ingredient(id=SRCR,
name=Sour Cream, type=SAUCE)]), Taco(name=Quesoriffic, ingredients=
[Ingredient(id=FLTO, name=Flour Tortilla, type=WRAP), Ingredient(id=CHED,
name=Cheddar, type=CHEESE), Ingredient(id=JACK, name=Monterrey Jack,
type=CHEESE), Ingredient(id=TMTO, name=Diced Tomatoes, type=VEGGIES),
Ingredient(id=SRCR,name=Sour Cream, type=SAUCE)])])

Dường như phương thức processOrder() đã thực hiện công việc của nó, xử lý việc gửi biểu mẫu bằng cách đăng nhập chi tiết về đơn đặt hàng. Nhưng nếu bạn nhìn kỹ vào mục nhật ký từ đơn đặt hàng kiểm thử của tôi, bạn có thể thấy rằng nó đã cho phép một số thông tin không chính xác trôi vào. Hầu hết các trường trong biểu mẫu chứa dữ liệu không thể là đúng. Hãy thêm một số kiểm tra hợp lệ để đảm bảo rằng dữ liệu được cung cấp ít nhất là giống với loại thông tin yêu cầu.

2.3 Validating form input

Khi thiết kế một chiếc taco mới, liệu người dùng có chọn bất kỳ thành phần nào hay quên chỉ định tên cho sáng tạo của họ không? Khi gửi đơn đặt hàng, người dùng có thể quên điền vào các trường địa chỉ bắt buộc không? Hoặc họ có thể nhập một giá trị vào trường thẻ tín dụng mà thậm chí không phải là một số thẻ tín dụng hợp lệ không?
Hiện tại, không có điều gì ngăn chặn người dùng từ việc tạo ra một chiếc taco mà không có bất kỳ thành phần nào hoặc với một địa chỉ giao hàng trống, hoặc thậm chí gửi lời bài hát yêu thích của họ làm số thẻ tín dụng. Điều này xảy ra vì bạn chưa chỉ định cách những trường đó nên được xác thực.
Một cách để thực hiện kiểm tra hợp lệ của biểu mẫu là làm cho processTaco() và processOrder() đầy ứng với nhiều đoạn mã if/then, kiểm tra từng trường để đảm bảo nó đáp ứng các quy tắc xác thực thích hợp. Nhưng điều này sẽ làm cho mã nguồn trở nên phiền toái và khó đọc và gỡ lỗi.
May mắn là, Spring hỗ trợ JavaBean Validation API (còn được biết đến là JSR 303; https://jcp.org/en/jsr/detail?id=303). Điều này làm cho việc khai báo các quy tắc xác thực trở nên dễ dàng thay vì việc viết rõ logic khai báo trong mã nguồn ứng dụng của bạn.
Để áp dụng xác thực trong Spring MVC, bạn cần:
- Thêm Spring Validation starter vào dự án.
- Khai báo các quy tắc xác thực trên lớp cần xác thực, cụ thể là lớp Taco.
- Chỉ định rằng xác thực sẽ được thực hiện trong các phương thức của controller cần xác thực, cụ thể là phương thức processTaco() của DesignTacoController và phương thức processOrder() của OrderController.
- Sửa đổi giao diện biểu mẫu để hiển thị lỗi xác thực.
API Xác thực cung cấp một số chú thích có thể đặt trên các thuộc tính của các đối tượng miền để khai báo các quy tắc xác thực. Bản triển khai của Hibernate cho Validation API thêm nhiều chú thích xác thực hơn nữa. Cả hai đều có thể được thêm vào một dự án bằng cách thêm Spring Validation starter vào dự án. Ô kiểm Validation dưới I/O trong Spring Boot Starter wizard sẽ hoàn tất công việc, nhưng nếu bạn thích chỉnh sửa build của mình, mục nhập sau trong tệp pom.xml của Maven sẽ giải quyết vấn đề:
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>

Hoặc nếu bạn đang sử dụng Gradle, đây là dependency bạn cần:
implementation 'org.springframework.boot:spring-boot-starter-validation'

2.3.1 Declaring validation rules

Đối với lớp Taco, bạn muốn đảm bảo rằng thuộc tính name không rỗng hoặc null và rằng danh sách các thành phần được chọn có ít nhất một mục. Đoạn mã sau đây hiển thị một lớp Taco đã được cập nhật sử dụng @NotNull và @Size để khai báo những quy tắc xác thực đó.

Listing 2.11 Adding validation to the Taco domain class 

public class Taco {
	
	@NotNull
	@Size(min = 5, message = "Name must be at least 5 characters long")
	private String name;
	
	@NotNull
	@Size(min = 1, message = "You must choose at least 1 ingredient")
	private List<Ingredient> ingredients;

Bạn sẽ nhận thấy rằng ngoài việc yêu cầu thuộc tính name không được null, bạn khai báo rằng nó nên có một giá trị ít nhất là năm ký tự.

Khi đến việc khai báo xác thực trên các đơn đặt hàng taco đã gửi, bạn phải áp dụng các chú thích cho lớp TacoOrder. Đối với các thuộc tính địa chỉ, bạn muốn đảm bảo rằng người dùng không để trống bất kỳ trường nào. Đối với điều đó, bạn sẽ sử dụng chú thích @NotBlank.

Tuy nhiên, xác thực các trường thanh toán có vẻ phức tạp hơn một chút. Bạn cần đảm bảo không chỉ thuộc tính ccNumber không được trống mà còn chứa một giá trị có thể là một số thẻ tín dụng hợp lệ. Thuộc tính ccExpiration phải tuân theo định dạng MM/YY (tháng và năm hai chữ số), và thuộc tính ccCVV cần phải là một số ba chữ số. Để đạt được kiểu xác thực này, bạn cần sử dụng một số chú thích khác của Java-Bean Validation API và mượn một chú thích xác thực từ bộ sưu tập chú thích Hibernate Validator. Đoạn mã sau đây hiển thị các thay đổi cần thiết để xác thực lớp TacoOrder.
Listing 2.12 Validating order fields 
public class TacoOrder {
	@NotBlank(message = "Delivery name is required")
	private String deliveryName;
	
	@NotBlank(message = "Delivery street is required")
	private String deliveryStreet;
	
	@NotBlank(message = "Delivery city is required")
	private String deliveryCity;
	
	@NotBlank(message = "Delivery state is required")
	private String deliveryState;
	
	@NotBlank(message = "Delivery zip is required")
	private String deliveryZip;
	
	@CreditCardNumber(message = "Not a valid credit card number")
	private String ccNumber;
	
	@Pattern(regexp = "^(0[1-9]|1[0-2])([\\/])([2-9][0-9])$", 
			message = "Must be formatted MM/YY")
	private String ccExpiration;
	
	@Digits(integer = 3, fraction = 0, message = "Invalid CVV")
	private String ccCVV;
	
	private List<Taco> tacos = new ArrayList<>();
	
	public void addTaco(Taco taco) {
		this.tacos.add(taco);
	}


2.3.2 Performing validation at form binding

Bây giờ khi bạn đã khai báo cách một Taco và TacoOrder nên được xác thực, chúng ta cần xem xét lại từng controller, chỉ định rằng validation sẽ được thực hiện khi biểu mẫu được gửi (POST) đến các phương thức xử lý tương ứng của chúng.
Để xác thực một Taco đã được gửi, bạn cần thêm chú thích `@Valid` của JavaBean Validation API vào đối số Taco của phương thức `processTaco()` của DesignTacoController, như được hiển thị dưới đây.

Listing 2.13 Validating a POSTed Taco 

import javax.validation.Valid;
import org.springframework.validation.Errors;

@PostMapping
public String processTaco(
		@Valid Taco taco, Errors errors,
		@ModelAttribute TacoOrder tacoOrder) {
	if(errors.hasErrors()) {
		return "design";
	}
	
	tacoOrder.addTaco(taco);
	log.info("Processing taco: {}", taco.getIngredients().size());
	
	return "redirect:/orders/current";
}

Chú thích `@Valid` báo cho Spring MVC thực hiện xác thực trên đối tượng Taco đã được gửi sau khi nó được liên kết với dữ liệu biểu mẫu đã được gửi và trước khi phương thức `processTaco()` được gọi. Nếu có bất kỳ lỗi xác thực nào, chi tiết của những lỗi đó sẽ được lưu trong một đối tượng Errors được chuyển vào `processTaco()`. Một số dòng đầu tiên của `processTaco()` kiểm tra đối tượng Errors, hỏi phương thức hasErrors() của nó xem có bất kỳ lỗi xác thực nào hay không. Nếu có, phương thức kết thúc mà không xử lý Taco và trả về tên view "design" để biểu mẫu được hiển thị lại.

Để thực hiện xác thực trên các đối tượng TacoOrder đã được gửi, cũng cần thực hiện những thay đổi tương tự trong phương thức `processOrder()` của OrderController, như được hiển thị trong đoạn mã tiếp theo.
Listing 2.14 Validating a POSTed TacoOrder 
@PostMapping
	public String processOrder(
			@Valid TacoOrder order, Errors errors, 
			SessionStatus sessionStatus) {
		if(errors.hasErrors()) {
			return "orderForm";
		}
		
		log.info("Order submitted: {}", order);
		sessionStatus.setComplete();
		
		return "redirect:/";
	}

Trong cả hai trường hợp, phương thức sẽ được phép xử lý dữ liệu đã được gửi nếu không có lỗi xác thực. Nếu có lỗi xác thực, yêu cầu sẽ được chuyển tiếp đến giao diện biểu mẫu để cung cấp cho người dùng cơ hội để sửa lỗi của họ.
Nhưng làm thế nào người dùng sẽ biết những lỗi nào cần được sửa chữa? Nếu bạn không thông báo lỗi trên biểu mẫu, người dùng sẽ phải đoán về cách gửi biểu mẫu một cách thành công.

2.3.3 Displaying validation errors
Thymeleaf cung cấp quyền truy cập thuận tiện vào đối tượng Errors thông qua thuộc tính fields và với thuộc tính th:errors. Ví dụ, để hiển thị lỗi xác thực trên trường credit card number, bạn có thể thêm một phần tử <span> sử dụng các tham chiếu lỗi này vào mẫu biểu mẫu đơn hàng, như sau.

Listing 2.15 Displaying validation errors 
<label for="ccNumber">Credit Card #: </label>
		<input type="text" th:field="*{ccNumber}" />
		<span class="validationError" 
				th:if="${#fields.hasErrors('ccNumber')}"
				th:errors="*{ccErrors}">CC Num Error</span>

Ngoài thuộc tính class có thể được sử dụng để tạo style cho lỗi để thu hút sự chú ý của người dùng, phần tử <span> sử dụng thuộc tính th:if để quyết định liệu có hiển thị <span> hay không. Phương thức hasErrors() của thuộc tính fields kiểm tra xem có bất kỳ lỗi nào trong trường ccNumber hay không. Nếu có, <span> sẽ được hiển thị.

Thuộc tính th:errors tham chiếu đến trường ccNumber và, giả sử có lỗi cho trường đó, nó sẽ thay thế nội dung giữ chỗ của phần tử <span> bằng thông báo xác thực.

Nếu bạn thêm các thẻ <span> tương tự xung quanh biểu mẫu đơn hàng cho các trường khác, bạn có thể thấy một biểu mẫu giống như hình 2.5 khi bạn gửi thông tin không hợp lệ. Các lỗi chỉ ra rằng các trường name, city và ZIP code đã bị bỏ trống và tất cả các trường thanh toán không đáp ứng các tiêu chí xác thực.

Bây giờ, các controllers của Taco Cloud không chỉ hiển thị và lưu thông tin đầu vào, mà còn xác thực rằng thông tin đó đáp ứng một số quy tắc xác thực cơ bản. Hãy bước lại và xem xét HomeController từ chương 1, nhìn vào một cách triển khai thay thế.

#fields là một đối tượng đặc biệt được cung cấp bởi Spring để hỗ trợ xác thực trên biểu mẫu. Đối tượng này cung cấp các phương thức để kiểm tra xem có lỗi xác thực nào đó cho một trường cụ thể hay không.
th:if="${#fields.hasErrors('ccNumber')}"

2.4 Working with view controllers
Cho đến nay, bạn đã viết ba controller cho ứng dụng Taco Cloud. Mặc dù mỗi controller phục vụ một mục đích cụ thể trong chức năng của ứng dụng, chúng đều tuân thủ khá chặt chẽ mô hình lập trình sau đây:






- Tất cả đều được chú thích bằng `@Controller` để chỉ định rằng chúng là các lớp điều khiển sẽ được tự động phát hiện bởi component scan của Spring và được khởi tạo như các bean trong Spring application context.
- Tất cả, trừ `HomeController`, đều được chú thích bằng `@RequestMapping` ở cấp lớp để xác định một mẫu yêu cầu cơ sở mà controller sẽ xử lý.
- Tất cả đều có một hoặc nhiều phương thức được chú thích bằng `@GetMapping` hoặc `@PostMapping` để cung cấp thông tin chi tiết về việc phương thức nào sẽ xử lý loại yêu cầu nào.

Hầu hết các controller bạn sẽ viết sẽ tuân thủ mô hình đó. Nhưng khi một controller đơn giản đến mức nó không điền vào một mô hình hoặc xử lý đầu vào như là trường hợp của `HomeController` có một cách khác mà bạn có thể định nghĩa controller. Hãy xem đoạn mã tiếp theo để biết làm thế nào bạn có thể khai báo một view controller một controller chỉ là chuyển tiếp yêu cầu đến một view.

Listing 2.16 Declaring a view controller

@Configuration
public class WebConfig implements WebMvcConfigurer {

	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController("/").setViewName("home");
	}
	
}

setViewName("home"); Mày muốn chuyển tiếp tới đâu?
Điều quan trọng nhất để lưu ý về `WebConfig` là nó implements giao diện `WebMvcConfigurer`. `WebMvcConfigurer` định nghĩa một số phương thức để cấu hình Spring MVC. Mặc dù nó là một giao diện, nhưng nó cung cấp các triển khai default của tất cả các phương thức, vì vậy bạn chỉ cần ghi đè các phương thức bạn cần. Trong trường hợp này, bạn ghi đè phương thức `addViewControllers()`.

Phương thức `addViewControllers()` được truyền một đối tượng `ViewControllerRegistry` mà bạn có thể sử dụng để đăng ký một hoặc nhiều view controller. Ở đây, bạn gọi `addViewController()` trên registry, truyền vào "/" là đường dẫn mà view controller của bạn sẽ xử lý các yêu cầu GET. Phương thức đó trả về một đối tượng `ViewControllerRegistration`, trên đó bạn ngay lập tức gọi `setViewName()` để chỉ định "home" là view mà một yêu cầu cho "/" sẽ được chuyển tiếp đến.

Và chỉ như vậy, bạn đã có thể thay thế `HomeController` bằng vài dòng mã trong một lớp cấu hình. Bạn có thể xóa `HomeController` ngay bây giờ và ứng dụng vẫn nên hoạt động như trước. Thay đổi duy nhất khác cần thiết là quay lại `HomeControllerTest` từ chương 1, xóa tham chiếu đến `HomeController` khỏi chú thích `@WebMvcTest`, để lớp kiểm thử sẽ biên dịch mà không có lỗi.

Ở đây, bạn đã tạo một lớp cấu hình mới `WebConfig` để chứa khai báo view controller. Nhưng bất kỳ lớp cấu hình nào cũng có thể thực hiện `WebMvcConfigurer` và ghi đè phương thức `addViewController`. Ví dụ, bạn có thể đã thêm cùng khai báo view controller vào lớp `TacoCloudApplication` như sau:



@SpringBootApplication
public class TacoCloudApplication implements WebMvcConfigurer {

	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args);
	}

	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController("/").setViewName("home");
	}
	
}

Bằng cách mở rộng một lớp cấu hình hiện tại, bạn có thể tránh tạo ra một lớp cấu hình mới, giữ cho số lượng thành phần trong dự án của bạn giảm xuống. Nhưng tôi thích tạo ra một lớp cấu hình mới cho mỗi loại cấu hình (web, data, security, và những thứ khác), giữ cho cấu hình khởi động ứng dụng trở nên sạch sẽ và đơn giản.

Nói về view controllers và một cách tổng quát hơn, các view mà controllers chuyển tiếp yêu cầu đến cho đến nay, bạn đã sử dụng Thymeleaf cho tất cả các view của mình. Tôi thích Thymeleaf rất nhiều, nhưng có thể bạn muốn sử dụng một mô hình template khác cho các view của ứng dụng của bạn. Hãy xem xét các lựa chọn view được hỗ trợ bởi Spring.

2.5 Choosing a view template library

Ở phần lớn, việc lựa chọn một thư viện template view là một vấn đề cá nhân. Spring là linh hoạt và hỗ trợ nhiều tùy chọn template phổ biến. Với một số ngoại lệ nhỏ, thư viện template bạn chọn sẽ không biết rằng nó đang làm việc với Spring.
Bảng 2.2 liệt kê các lựa chọn template được hỗ trợ bởi cấu hình tự động của Spring Boot.

 

Nói chung, bạn chọn thư viện template view bạn muốn, thêm nó như là một dependency vào dự án của bạn, và bắt đầu viết các template trong thư mục /templates (nằm trong thư mục src/main/resources trong dự án Maven hoặc Gradle). Spring Boot phát hiện thư viện template bạn đã chọn và tự động cấu hình các thành phần cần thiết để phục vụ các view cho các controller Spring MVC của bạn.

Bạn đã thực hiện điều này với Thymeleaf cho ứng dụng Taco Cloud. Ở chương 1, bạn chọn hộp kiểm Thymeleaf khi khởi tạo dự án. Điều này dẫn đến việc bao gồm Thymeleaf starter của Spring Boot trong tệp pom.xml. Khi ứng dụng khởi động, cấu hình tự động của Spring Boot phát hiện sự hiện diện của Thymeleaf và tự động cấu hình các bean Thymeleaf cho bạn. Bạn chỉ cần bắt đầu viết các template trong /templates.
Nếu bạn muốn sử dụng một thư viện template khác, bạn chỉ cần chọn nó khi khởi tạo dự án hoặc chỉnh sửa cấu trúc dự án hiện tại để bao gồm thư viện template mới được chọn.
Ví dụ, giả sử bạn muốn sử dụng Mustache thay vì Thymeleaf. Không vấn đề. Chỉ cần truy cập tệp pom.xml của dự án và thay thế mã sau:

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

với : 

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-mustache</artifactId>
</dependency>

Tất nhiên, bạn cần đảm bảo rằng bạn viết tất cả các template với cú pháp Mustache thay vì các thẻ Thymeleaf. Các chi tiết về làm việc với Mustache (hoặc bất kỳ lựa chọn ngôn ngữ template nào khác) nằm ngoài phạm vi của cuốn sách này. Tuy nhiên, để bạn có cái nhìn tổng quan về những gì bạn có thể mong đợi, dưới đây là một đoạn mã mẫu từ một template Mustache sẽ hiển thị một trong nhóm nguyên liệu trong biểu mẫu thiết kế taco:

<h3>Designate your wrap:</h3>
{{#wrap}}
<div>
   <input name="ingredients" type="checkbox" value="{{id}}" />
   <span>{{name}}</span><br/>
</div>
{{/wrap}}

…

2.5.1 Caching templates

Mặc định, các template chỉ được phân tích một lần khi chúng được sử dụng lần đầu tiên và kết quả của phân tích đó được lưu vào cache để sử dụng trong các lần sau. Điều này là một tính năng tuyệt vời cho môi trường sản xuất, vì nó ngăn chặn việc phân tích template không cần thiết trên mỗi yêu cầu và từ đó cải thiện hiệu suất.
Tính năng đó không quá tuyệt vời khi bạn đang phát triển ứng dụng. Hãy giả sử bạn khởi động ứng dụng, truy cập trang thiết kế taco và quyết định thực hiện một số thay đổi. Khi bạn làm mới trình duyệt web của mình, bạn vẫn thấy phiên bản ban đầu. Cách duy nhất để xem các thay đổi của bạn là khởi động lại ứng dụng, điều này khá không thuận tiện.
May mắn thay, chúng ta có cách để tắt chức năng caching. Chúng ta chỉ cần đặt một thuộc tính caching phù hợp cho template thành false. Bảng 2.3 liệt kê các thuộc tính caching cho mỗi thư viện template được hỗ trợ.

 

Mặc định, tất cả các thuộc tính này được đặt thành true để bật chế độ caching. Bạn có thể tắt chế độ caching cho engine template bạn đã chọn bằng cách đặt thuộc tính cache của nó thành false. Ví dụ, để tắt caching cho Thymeleaf, thêm dòng sau trong application.properties:
spring.thymeleaf.cache=false
Tuy nhiên, bạn cần chắc chắn xóa dòng này (hoặc đặt nó thành true) trước khi triển khai ứng dụng của bạn lên production. Một lựa chọn là đặt thuộc tính trong một profile. (Chúng ta sẽ thảo luận về profiles trong chương 6.)
Một lựa chọn đơn giản hơn là sử dụng Spring Boot's DevTools, như chúng ta đã lựa chọn trong chương 1. Trong số nhiều tính năng hữu ích của DevTools khi đang phát triển, nó sẽ tắt chế độ caching cho tất cả các thư viện template nhưng sẽ tắt chính nó (và do đó kích hoạt lại caching template) khi ứng dụng của bạn được deploy.

Summary
- Spring cung cấp một framework web mạnh mẽ gọi là Spring MVC, có thể được sử dụng để phát triển phần giao diện web cho ứng dụng Spring.
- Spring MVC sử dụng các annotation, cho phép khai báo các phương thức xử lý yêu cầu với các annotation như @RequestMapping, @GetMapping và @PostMapping.
- Hầu hết các phương thức xử lý yêu cầu kết thúc bằng việc trả về tên logic của một view, chẳng hạn như một template Thymeleaf, mà yêu cầu (cùng với bất kỳ dữ liệu mô hình nào) được chuyển tiếp đến.
- Spring MVC hỗ trợ validation thông qua JavaBean Validation API và các triển khai của Validation API như Hibernate Validator.
- View controllers có thể được đăng ký với `addViewController` trong một lớp `WebMvcConfigurer` để xử lý các yêu cầu HTTP GET mà không cần dữ liệu mô hình hoặc xử lý.
- Ngoài Thymeleaf, Spring hỗ trợ nhiều tùy chọn view khác nhau, bao gồm FreeMarker, Groovy templates, và Mustache.


Chapter 03 -Working with data
This chapter covers
 Using Spring’s JdbcTemplate
 Creating Spring Data JDBC repositories
 Declaring JPA repositories with Spring Data


3.3 Persisting data with Spring Data JPA

Trong khi Spring Data JDBC giúp việc lưu trữ dữ liệu trở nên dễ dàng, Java Persistence API (JPA) là một lựa chọn phổ biến khác để làm việc với dữ liệu trong cơ sở dữ liệu quan hệ. Spring Data JPA cung cấp một cách tiếp cận cho việc lưu trữ với JPA tương tự như Spring Data JDBC đã làm cho chúng ta với JDBC.
Để xem cách Spring Data hoạt động, bạn sẽ bắt đầu lại từ đầu, thay thế các repository dựa trên JDBC từ trước trong chương này bằng các repository được tạo bởi Spring Data JPA. Nhưng trước hết, bạn cần thêm Spring Data JPA vào dự án.

3.3.1 Adding Spring Data JPA to the project

Spring Data JPA có sẵn cho các ứng dụng Spring Boot thông qua JPA starter. Dependency này không chỉ mang đến Spring Data JPA mà còn bao gồm Hibernate như một triển khai JPA theo chiều chuyển giao, như thể hiện dưới đây:
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

3.3.2 Annotating the domain as entities

Như bạn đã thấy với Spring Data JDBC, Spring Data làm một số điều tuyệt vời khi tạo các kho dữ liệu. Nhưng không may thay, nó không hỗ trợ nhiều khi bạn cần đánh dấu các đối tượng miền của mình với các chú thích ánh xạ JPA. Bạn sẽ cần mở rộng các lớp Ingredient, Taco và TacoOrder và thêm vào một số chú thích. Đầu tiên là lớp Ingredient, được hiển thị dưới đây.

Listing 3.18 Annotating Ingredient for JPA persistence 
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)
public class Ingredient {
	@Id
	private String id;
	private String name;
	private Type type;

public enum Type {
		WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
	}


Để khai báo Ingredient như một thực thể JPA, nó phải được chú thích bằng @Entity. Và thuộc tính id của nó phải được chú thích bằng @Id để đặt nó làm thuộc tính sẽ xác định một cách duy nhất thực thể trong cơ sở dữ liệu. Lưu ý rằng chú thích @Id này là loại JPA từ gói javax.persistence, khác với @Id được cung cấp bởi Spring Data trong gói org.springframework.data.annotation.
Cũng lưu ý rằng chúng ta không còn cần chú thích @Table hoặc cần phải triển khai Persistable. Mặc dù chúng ta vẫn có thể sử dụng @Table ở đây, nhưng nó không cần thiết khi làm việc với JPA và mặc định là tên của lớp ("Ingredient", trong trường hợp này). Về Persistable, nó chỉ là cần thiết với Spring Data JDBC để xác định liệu một thực thể có nên được tạo mới hay cập nhật một thực thể hiện có; JPA tự động giải quyết điều đó.
Ngoài các chú thích cụ thể của JPA, bạn cũng sẽ thấy bạn đã thêm một chú thích @NoArgsConstructor ở cấp độ lớp. JPA yêu cầu thực thể có một constructor không có tham số, nên @NoArgsConstructor của Lombok làm điều đó cho bạn. Tuy nhiên, bạn không muốn có thể sử dụng nó, vì vậy bạn làm cho nó là private bằng cách đặt thuộc tính truy cập là AccessLevel.PRIVATE. Và vì bạn phải đặt thuộc tính là final, bạn cũng đặt thuộc tính force là true, điều này dẫn đến việc constructor được tạo ra bởi Lombok sẽ đặt chúng thành giá trị mặc định là null, 0, hoặc false, phụ thuộc vào loại thuộc tính.
Bạn cũng sẽ thêm một chú thích @AllArgsConstructor để dễ dàng tạo ra một đối tượng Ingredient với tất cả các thuộc tính được khởi tạo.
Bạn cũng cần một @RequiredArgsConstructor. Chú thích @Data tự động thêm một constructor yêu cầu tham số, nhưng khi sử dụng @NoArgsConstructor, constructor đó sẽ bị loại bỏ. Một @RequiredArgsConstructor rõ ràng đảm bảo rằng bạn vẫn có một constructor yêu cầu tham số, bên cạnh constructor không có tham số private.
Bây giờ hãy tiếp tục với lớp Taco và xem cách chú thích nó như một thực thể JPA.

Listing 3.19 Annotating Taco as an entity 
@Entity
public class Taco {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	@NotNull
	@Size(min = 5, message = "Name must be at least 5 characters long")
	private String name;
	
	private Date createdAt = new Date();
	
	@Size(min = 1, message = "You must choose at least 1 ingredient")
	@ManyToMany
	private List<Ingredient> ingredients = new ArrayList<>();
	
	public void addIngredient(Ingredient ingredient) {
		this.ingredients.add(ingredient);
	}

	public Taco(String name, Date createdAt, List<Ingredient> ingredients) {
		this.name = name;
		this.createdAt = createdAt;
		this.ingredients = ingredients;
	}

	private Taco() {
		
	}

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(Date createdAt) {
		this.createdAt = createdAt;
	}

	public List<Ingredient> getIngredients() {
		return ingredients;
	}

	public void setIngredients(List<Ingredient> ingredients) {
		this.ingredients = ingredients;
	}
 
	@Override
	public String toString() {
return "Taco [id=" + id + ", name=" + name + ", createdAt=" + createdAt + ", ingredients=" + ingredients + "]";
	}
	
}

Listing 3.20 Annotating TacoOrder as a JPA entity 

@Entity
public class TacoOrder implements Serializable{
	
	private static final long serialVersionUID = 1L;
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	private Date placeAt = new Date();
	
	@OneToMany(cascade = CascadeType.ALL)
	private List<Taco> tacos = new ArrayList<>();
	
	public void addTaco(Taco taco) {
		this.tacos.add(taco);
	}

	public TacoOrder(Date placeAt, List<Taco> tacos) {
		super();
		this.placeAt = placeAt;
		this.tacos = tacos;
	}

	private TacoOrder() {
	}

	public Long getId() {
		return id;
	}

	public Date getPlaceAt() {
		return placeAt;
	}

	public void setPlaceAt(Date placeAt) {
		this.placeAt = placeAt;
	}

	public List<Taco> getTacos() {
		return tacos;
	}

	public void setTacos(List<Taco> tacos) {
		this.tacos = tacos;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}

	@Override
	public String toString() {
		return "TacoOrder [id=" + id + ", placeAt=" + placeAt + ", tacos=" + tacos + "]";
	}	
3.3.3 Declaring JPA repositories
Khi bạn tạo các phiên bản của repositories sử dụng JdbcTemplate, bạn đã tường minh khai báo các phương thức mà bạn muốn repository cung cấp. Nhưng với Spring Data JDBC, bạn có thể bỏ qua việc tạo tường minh các lớp triển khai và thay vào đó mở rộng từ giao diện CrudRepository. Như có vẻ, CrudRepository hoạt động một cách hiệu quả tương tự cho Spring Data JPA. Ví dụ, dưới đây là giao diện IngredientRepository mới:

import org.springframework.data.repository.CrudRepository;

import tacos.Ingredient;

public interface IngredientRepository extends CrudRepository<Ingredient, String> {
	
}

Thực tế, giao diện IngredientRepository mà chúng ta sẽ sử dụng với Spring Data JPA là hoàn toàn giống với giao diện mà chúng ta đã định nghĩa để sử dụng với Spring Data JDBC. Giao diện CrudRepository thường được sử dụng rộng rãi trong nhiều dự án của Spring Data, không phụ thuộc vào cơ chế lưu trữ cơ bản. Tương tự, bạn có thể định nghĩa OrderRepository cho Spring Data JPA giống như nó đã được định nghĩa cho Spring Data JDBC, như sau:

import org.springframework.data.repository.CrudRepository;

import tacos.TacoOrder;

public interface OrderRepository extends CrudRepository<TacoOrder, Long> {
	
}

Các phương thức được cung cấp bởi `CrudRepository` là tuyệt vời cho việc lưu trữ tổng quát của các thực thể. Nhưng nếu bạn có những yêu cầu vượt ra khỏi việc lưu trữ cơ bản, hãy xem cách tùy chỉnh các repository để thực hiện các truy vấn độc đáo cho domain của bạn. Mục 3.3.4 giải thích về quá trình tùy chỉnh.

3.3.4 Customizing repositories

Hãy tưởng tượng rằng ngoài các thao tác CRUD cơ bản được cung cấp bởi `CrudRepository`, bạn cũng cần truy xuất tất cả các đơn hàng được giao đến một mã ZIP cụ thể. Như đã thấy, điều này có thể dễ dàng được giải quyết bằng cách thêm khai báo phương thức sau vào OrderRepository:
List<TacoOrder> findByDeliveryZip(String deliveryZip);
Khi tạo ra triển khai của repository, Spring Data kiểm tra từng phương thức trong giao diện repository, phân tích tên phương thức và cố gắng hiểu rõ mục đích của phương thức trong ngữ cảnh của đối tượng được lưu trữ (trong trường hợp này là TacoOrder). Theo cách tiếp cận này, Spring Data định nghĩa một loại ngôn ngữ đặc biệt cho miền (DSL), trong đó chi tiết về lưu trữ được thể hiện trong các chữ ký của phương thức repository.

Spring Data biết rằng phương thức này được dùng để tìm kiếm các đơn hàng, vì bạn đã sử dụng TacoOrder làm tham số hóa cho CrudRepository. Tên phương thức, `findByDeliveryZip()`, làm rõ rằng phương thức này sẽ tìm tất cả các đối tượng TacoOrder bằng cách so khớp thuộc tính deliveryZip của chúng với giá trị được truyền vào như là một tham số cho phương thức.

Phương thức `findByDeliveryZip()` đơn giản đủ, nhưng Spring Data cũng có thể xử lý các tên phương thức có ý nghĩa phức tạp hơn. Các phương thức repository được tạo thành từ một động từ, một chủ đề tùy chọn, từ "By", và một tiền đề. Trong trường hợp của `findByDeliveryZip()`, động từ là "find" và tiền đề là "DeliveryZip"; chủ đề không được chỉ định và được ngụ ý là một TacoOrder.

Hãy xem xét một ví dụ khác, phức tạp hơn. Giả sử bạn cần truy vấn tất cả các đơn hàng được giao đến một mã ZIP cụ thể trong khoảng thời gian từ ngày này đến ngày khác. Trong trường hợp đó, phương thức sau, khi được thêm vào OrderRepository, có thể hữu ích:
List<TacoOrder> readOrdersByDeliveryZipAndPlaceAtBetween
			(String deliveryZip, Date startDate, Date endDate);


Hình 3.2 mô tả cách Spring Data phân tích và hiểu phương thức ` readOrdersByDeliveryZipAndPlaceAtBetween ()` khi tạo ra triển khai của repository.

 

Như bạn có thể thấy, động từ trong ` readOrdersByDeliveryZipAndPlaceAtBetween ()` là "read". Spring Data cũng hiểu "find", "read", và "get" là đồng nghĩa khi truy xuất một hoặc nhiều thực thể. Hoặc nếu bạn muốn phương thức trả về chỉ một int đại diện cho số lượng thực thể khớp, bạn cũng có thể sử dụng "count" làm động từ.

Mặc dù chủ đề của phương thức là tùy chọn, ở đây nó nói về Orders. Spring Data bỏ qua hầu hết các từ trong chủ đề, vì vậy bạn có thể đặt tên phương thức là readPuppiesBy... và nó vẫn sẽ tìm thấy các thực thể TacoOrder, vì đó là loại mà CrudRepository được tham số hóa.

Predicate theo sau từ "By" trong tên phương thức và là phần đáng chú ý nhất của chữ ký phương thức. Trong trường hợp này, predicate đề cập đến hai thuộc tính của TacoOrder: deliveryZip và placedAt. Thuộc tính deliveryZip phải bằng giá trị được truyền vào tham số đầu tiên của phương thức. Từ khóa Between cho biết rằng giá trị của deliveryZip phải nằm giữa các giá trị được truyền vào hai tham số cuối cùng của phương thức.

Ngoài hoạt động Equals và hoạt động Between được ngụ ý, chữ ký phương thức Spring Data cũng có thể bao gồm bất kỳ toán tử sau đây:

 IsAfter, After, IsGreaterThan, GreaterThan
 IsGreaterThanEqual, GreaterThanEqual
 IsBefore, Before, IsLessThan, LessThan
 IsLessThanEqual, LessThanEqual
 IsBetween, Between
 IsNull, Null
 IsNotNull, NotNull
 IsIn, In
 IsNotIn, NotIn
 IsStartingWith, StartingWith, StartsWith
 IsEndingWith, EndingWith, EndsWith
 IsContaining, Containing, Contains
 IsLike, Like
 IsNotLike, NotLike
 IsTrue, True
 IsFalse, False
 Is, Equals
 IsNot, Not
 IgnoringCase, IgnoresCase


Như là phương thức thay thế cho IgnoringCase và IgnoresCase, bạn có thể sử dụng AllIgnoringCase hoặc AllIgnoresCase để bỏ qua sự phân biệt chữ hoa chữ thường cho tất cả các so sánh chuỗi. Ví dụ, xem xét phương thức sau:
List<TacoOrder> findByDeliveryCityAndDeliveryStateAllIgnoreCase(
			String deliveryCity, String deliveryState);

Cuối cùng, bạn cũng có thể đặt OrderBy ở cuối tên phương thức để sắp xếp kết quả theo một cột cụ thể. Ví dụ, để sắp xếp theo thuộc tính deliveryTo, bạn có thể sử dụng mã sau:

List<TacoOrder> findByDeliveryCityOrderByDeliveryState(String city);

Mặc dù quy ước đặt tên có thể hữu ích cho các truy vấn tương đối đơn giản, nhưng không khó để thấy rằng tên phương thức có thể trở nên phức tạp đối với các truy vấn phức tạp hơn. Trong trường hợp đó, bạn có thể tự do đặt tên phương thức là bất cứ điều gì bạn muốn và chú thích nó với @Query để chỉ định một cách rõ ràng truy vấn sẽ được thực hiện khi phương thức được gọi, như ví dụ dưới đây:

@Query("Order o where o.deliveryCity='Seattle'")
	List<TacoOrder> readOrdersDeliveredInSeattle();

Trong việc sử dụng đơn giản này của @Query, bạn yêu cầu tất cả các đơn hàng được giao tới Seattle. Tuy nhiên, bạn có thể sử dụng @Query để thực hiện bất kỳ truy vấn JPA nào bạn có thể nghĩ ra, ngay cả khi việc thực hiện truy vấn bằng cách tuân theo quy ước đặt tên trở nên khó khăn hoặc không thể thực hiện được.

Chapter 04 - Working with
nonrelational data

This chapter covers
 Persisting data to Cassandra
 Data modeling in Cassandra
 Working with document data in MongoDB

Họ nói rằng sự đa dạng là gia vị của cuộc sống.
Bạn có lẽ có một loại kem yêu thích. Đó là loại kem mà bạn chọn thường xuyên nhất vì nó làm hài lòng sự ham muốn kem mịn hơn bất kỳ loại kem nào khác.
Nhưng hầu hết mọi người, mặc dù có một loại kem yêu thích, cũng thường xuyên thử nhiều loại khác nhau để làm mới khẩu vị.
Cơ sở dữ liệu cũng giống như kem. Trong nhiều thập kỷ, cơ sở dữ liệu quan hệ đã là loại ưa thích để lưu trữ dữ liệu. Nhưng ngày nay, chúng ta có nhiều lựa chọn hơn bao giờ hết. Các cơ sở dữ liệu "NoSQL" (https://aws.amazon.com/nosql/) cung cấp các khái niệm và cấu trúc khác nhau để lưu trữ dữ liệu. Và mặc dù sự chọn lựa có thể vẫn dựa trên khẩu vị một chút, một số cơ sở dữ liệu phù hợp hơn cho việc lưu trữ các loại dữ liệu khác nhau.
May mắn thay, Spring Data đã hỗ trợ bạn cho nhiều cơ sở dữ liệu NoSQL, bao gồm MongoDB, Cassandra, Couchbase, Neo4j, Redis và nhiều loại khác. Và may mắn thay, mô hình lập trình gần như giống nhau, không phụ thuộc vào cơ sở dữ liệu bạn chọn.
Trong chương này không đủ không gian để nói về tất cả cơ sở dữ liệu mà Spring Data hỗ trợ. Nhưng để đưa ra một mẫu về "hương vị" khác của Spring Data, chúng ta sẽ xem xét hai cơ sở dữ liệu NoSQL phổ biến, Cassandra và MongoDB, và xem cách tạo repository để lưu trữ dữ liệu cho chúng. Hãy bắt đầu bằng cách xem cách tạo repository Cassandra với Spring Data.

4.1 Working with Cassandra repositories

Cassandra là một cơ sở dữ liệu (phân tán – distributed), (hiệu suất cao – high performance), luôn sẵn có, nhất quán cuối cùng, (phân vùng cột lưu trữ - partitioned-column-store), cơ sở dữ liệu NoSQL.
Đó là một chuỗi các tính từ để mô tả một cơ sở dữ liệu, nhưng mỗi từ nói lên sức mạnh của việc làm việc với Cassandra. Để diễn đạt một cách đơn giản hơn, Cassandra xử lý các hàng dữ liệu được viết vào các bảng, được phân vùng trên một hoặc nhiều nút phân tán. Không có một nút duy nhất nào chứa toàn bộ dữ liệu, nhưng bất kỳ hàng dữ liệu cụ thể nào có thể được sao chép trên nhiều nút, loại bỏ bất kỳ điểm thất bại duy nhất nào.

Spring Data Cassandra cung cấp hỗ trợ tự động cho việc lưu trữ Cassandra rất giống với—nhưng khá khác biệt so với—những gì được cung cấp bởi Spring Data JPA cho cơ sở dữ liệu quan hệ. Ngoài ra, Spring Data Cassandra cung cấp các chú thích để ánh xạ các loại domain ứng dụng vào các cấu trúc cơ sở dữ liệu hậu cần.

Trước khi chúng ta tiếp tục khám phá thêm về Cassandra, quan trọng là hiểu rằng mặc dù Cassandra chia sẻ nhiều khái niệm tương tự như cơ sở dữ liệu quan hệ như Oracle và SQL Server, Cassandra không phải là một cơ sở dữ liệu quan hệ và ở nhiều cách là một "quái vật" khác biệt. Tôi sẽ giải thích những đặc điểm riêng của Cassandra liên quan đến việc làm việc với Spring Data. Tuy nhiên, tôi khuyến khích bạn đọc tài liệu chính thức của Cassandra (http://cassandra.apache.org/doc/latest/) để hiểu rõ về những điều làm cho nó hoạt động.

Hãy bắt đầu bằng cách kích hoạt Spring Data Cassandra trong dự án Taco Cloud.

4.1.1 Enabling Spring Data Cassandra

Để bắt đầu sử dụng Spring Data Cassandra, bạn cần thêm dependency của Spring Boot starter cho Spring Data Cassandra không sử dụng reactive. Thực tế, có hai dependency khởi đầu riêng biệt cho Spring Data Cassandra để lựa chọn: một cho việc lưu trữ dữ liệu reactive và một cho việc lưu trữ dữ liệu thông thường, không sử dụng reactive.

Chúng ta sẽ thảo luận thêm về việc viết reactive repositories sau trong chương 15. Tuy nhiên, trong lúc này, chúng ta sẽ sử dụng starter không sử dụng reactive trong build như dưới đây:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-cassandra</artifactId>
</dependency>

Dependency này cũng có sẵn từ Initializr bằng cách chọn hộp kiểm Cassandra.

Quan trọng là hiểu rằng dependency này thay thế cho dependency của Spring Data JPA hoặc Spring Data JDBC mà chúng ta đã sử dụng trong chương trước. Thay vì lưu trữ dữ liệu Taco Cloud vào cơ sở dữ liệu quan hệ với JPA hoặc JDBC, bạn sẽ sử dụng Spring Data để lưu trữ dữ liệu vào cơ sở dữ liệu Cassandra. Do đó, bạn sẽ muốn loại bỏ các dependency của Spring Data JPA hoặc Spring Data JDBC và bất kỳ dependency của cơ sở dữ liệu quan hệ nào (như JDBC drivers hoặc dependency H2) khỏi build.

Dependency của Spring Data Cassandra starter đưa vào dự án một số dependency, cụ thể là thư viện Spring Data Cassandra. Do sự có mặt của Spring Data Cassandra trong classpath khi chạy, autoconfiguration để tạo các repository Cassandra được kích hoạt. Điều này có nghĩa là bạn có thể bắt đầu viết các repository Cassandra với một cấu hình tối thiểu. 

Cassandra hoạt động như một cụm nút cluster of nodes hoạt động cùng nhau như một hệ thống cơ sở dữ liệu hoàn chỉnh. Nếu bạn chưa có một Cassandra cluster để làm việc, bạn có thể khởi chạy một singlenode cluster để phục vụ mục đích phát triển sử dụng Docker như sau:

$ docker network create cassandra-net
$ docker run --name my-cassandra \
--network cassandra-net \
-p 9042:9042 \
-d cassandra:latest

Dòng này bắt đầu một single-node cluster và tiếp cận cổng của nút (9042) trên máy chủ để ứng dụng của bạn có thể truy cập vào nó. 
Tuy nhiên, bạn sẽ cần cung cấp một lượng cấu hình nhỏ. Ít nhất, bạn sẽ cần cấu hình tên của một keyspace mà các repository của bạn sẽ hoạt động trong keyspace đó. Để làm điều đó, bạn sẽ cần tạo một keyspace như vậy.

LƯU Ý: Trong Cassandra, một keyspace là một nhóm các bảng trong một node Cassandra. Điều này tương tự như cách các bảng, chế độ xem và ràng buộc được nhóm lại trong một cơ sở dữ liệu quan hệ.
Mặc dù có thể cấu hình Spring Data Cassandra để tự động tạo keyspace, nhưng thường dễ dàng hơn để tạo nó thủ công (hoặc sử dụng một keyspace đã tồn tại). Sử dụng shell CQL (cqlsh) (Cassandra Query Language) của Cassandra, bạn có thể tạo một keyspace cho ứng dụng Taco Cloud. Bạn có thể bắt đầu shell CQL bằng Docker như sau:
$ docker run -it --network cassandra-net --rm cassandra cqlsh my-cassandra

LƯU Ý: Nếu lệnh này không khởi động shell CQL và hiển thị lỗi " Unable to connect to any servers,," hãy đợi một hoặc hai phút và thử lại. Bạn cần chắc chắn rằng Cassandra cluster đã hoàn toàn khởi động trước khi shell CQL có thể kết nối đến nó.
 

Khi shell đã sẵn sàng, sử dụng lệnh tạo keyspace như sau:
cqlsh> create keyspace tacocloud
... with replication={'class':'SimpleStrategy', 'replication_factor':1}
... and durable_writes=true;
Đơn giản nói, điều này sẽ tạo ra một keyspace có tên là "tacocloud" với simple replication và durable write. Bằng cách đặt replication_factor là 1, bạn yêu cầu Cassandra giữ một bản sao của mỗi hàng. Replication strategy xác định cách replication handle. Replication strategy SimpleStrategy thích hợp cho việc sử dụng trong một trung tâm dữ liệu (data center) (và cho mã demo), nhưng bạn có thể xem xét chiến lược NetworkTopologyStrategy nếu Cassandra cluster của bạn được phân tán trên nhiều trung tâm dữ liệu. Tôi giới thiệu bạn đến tài liệu Cassandra để biết thêm chi tiết về cách replication strategies hoạt động và cách tạo keyspaces theo cách khác.
Bây giờ bạn đã tạo một keyspace, bạn cần cấu hình thuộc tính `spring.data.cassandra.keyspace-name` để thông báo cho Spring Data Cassandra sử dụng keyspace đó, như được thể hiện dưới đây:

spring:
  data:
    cassandra:
      keyspace-name: taco_cloud
      schema-action: recreate
      local-datacenter: datacenter1

Ở đây, bạn cũng đặt `spring.data.cassandra.schema-action` thành giá trị "recreate". Thiết lập này rất hữu ích cho mục đích phát triển vì nó đảm bảo rằng bất kỳ tables và user-defined types nào đó sẽ bị xóa và tạo lại mỗi khi ứng dụng khởi động. Giá trị mặc định là "none", không thực hiện hành động nào đối với schema và hữu ích trong cài đặt sản xuất, nơi bạn không muốn xóa tất cả các bảng mỗi khi ứng dụng khởi động.

Cuối cùng, thuộc tính `spring.data.cassandra.local-datacenter` xác định tên của local data center để thiết lập chính sách cân bằng tải load-balancing của Cassandra. Trong cài đặt với một node, "datacenter1" là giá trị sử dụng. Để biết thêm thông tin về các chính sách cân bằng tải của Cassandra và cách thiết lập local data center, bạn có thể xem tài liệu tham khảo của trình điều khiển Cassandra của DataStax (http://mng.bz/XrQM).

Đây là những thuộc tính duy nhất mà bạn cần để làm việc với một cơ sở dữ liệu Cassandra đang chạy cục bộ. Ngoài hai thuộc tính này, tuy nhiên, bạn có thể muốn đặt các thuộc tính khác tùy thuộc vào cách bạn đã cấu hình Cassandra cluster của mình.

Mặc định, Spring Data Cassandra giả định rằng Cassandra đang chạy cục bộ và lắng nghe trên cổng 9042. Nếu không phải là trường hợp đó, như trong cài đặt sản xuất, bạn có thể muốn đặt các thuộc tính `spring.data.cassandra.contact-points` và `spring.data.cassandra.port` như sau:
spring:
  data:
    cassandra:
      keyspace-name: tacocloud
      local-datacenter: datacenter1
      contact-points:
      - casshost-1.tacocloud.com
      - casshost-2.tacocloud.com
      - casshost-3.tacocloud.com
      port: 9043
Lưu ý rằng thuộc tính `spring.data.cassandra.contact-points` là nơi bạn xác định tên máy chủ của Cassandra. Một điểm liên hệ là máy chủ nơi một node Cassandra đang chạy. Theo mặc định, nó được đặt là localhost, nhưng bạn có thể đặt nó thành một danh sách các tên máy chủ. Hệ thống sẽ thử mỗi contact point cho đến khi kết nối được tạo ra. Điều này nhằm đảm bảo không có một point duy nhất gây sự cố trong Cassandra cluster và ứng dụng có thể kết nối với cụm thông qua một trong những contact point được cung cấp.

Bạn cũng có thể cần chỉ định username và password cho Cassandra cluster của bạn. Điều này có thể được thực hiện bằng cách đặt các thuộc tính `spring.data.cassandra.username` và `spring.data.cassandra.password`, như thể hiện dưới đây:
spring:
  data:
    cassandra:
    ...
      username: tacocloud
      password: s3cr3tP455w0rd

Đây là những thuộc tính duy nhất mà bạn cần để làm việc với cơ sở dữ liệu Cassandra đang chạy cục bộ. Tuy nhiên, ngoài hai thuộc tính này, bạn có thể muốn đặt các thuộc tính khác tùy thuộc vào cách bạn đã cấu hình cụm máy Cassandra của mình.

Bây giờ mà Spring Data Cassandra đã được bật và cấu hình trong dự án của bạn, bạn gần như đã sẵn sàng để ánh xạ các loại miền của mình thành các bảng Cassandra và viết repositories. Nhưng trước tiên, hãy rời xa một chút và xem xét một số điểm cơ bản về mô hình dữ liệu Cassandra.

4.1.2 Understanding Cassandra data modeling

Như đã đề cập, Cassandra khá khác biệt so với cơ sở dữ liệu quan hệ. Trước khi bạn có thể bắt đầu ánh xạ các loại domain của mình thành các bảng Cassandra, quan trọng là hiểu rõ một số cách mà mô hình dữ liệu Cassandra khác biệt so với cách bạn có thể mô hình dữ liệu của mình để lưu trữ trong một cơ sở dữ liệu quan hệ.

Dưới đây là một số điều quan trọng cần hiểu về mô hình dữ liệu Cassandra:
- Bảng Cassandra có thể có bất kỳ số cột nào, nhưng không phải tất cả các hàng đều cần sử dụng tất cả các cột đó.
- Cassandra databases được chia thành nhiều phân vùng partitions. Bất kỳ hàng nào trong một bảng cụ thể có thể được quản lý bởi một hoặc nhiều phân vùng, nhưng khó có thể tất cả các phân vùng đều chứa tất cả các hàng.
- Một bảng Cassandra có hai loại khóa: khóa phân vùng partition keys và khóa phân cụm clustering keys. Các phép băm được thực hiện trên khóa phân vùng của mỗi hàng để xác định phân vùng (hoặc các phân vùng) mà hàng đó sẽ được quản lý bởi. Khóa clustering xác định thứ tự mà các hàng được duy trì trong một phân vùng (không nhất thiết là thứ tự mà chúng xuất hiện trong kết quả của một truy vấn). Hãy tham khảo tài liệu Cassandra (http://mng.bz/yJ6E) để biết giải thích chi tiết hơn về mô hình dữ liệu trong Cassandra, bao gồm các partition, cluster, và khóa tương ứng của chúng.
- Cassandra được tối ưu hóa mạnh mẽ cho các thao tác đọc. Do đó, việc bảng được giảm chuẩn và dữ liệu được sao chép/lặp lại trên nhiều bảng là phổ biến và mong muốn. (Ví dụ, thông tin về khách hàng có thể được lưu trữ trong bảng khách hàng và được sao chép trong bảng chứa các đơn hàng được đặt bởi khách hàng.)
Đủ nói rằng, việc điều chỉnh các loại domain của Taco Cloud để hoạt động với Cassandra không đơn giản là việc thay thế một số chú thích JPA bằng chú thích Cassandra. Bạn sẽ phải suy nghĩ lại cách bạn mô hình dữ liệu.

4.1.3 Mapping domain types for Cassandra persistence
Trong chương 3, bạn đã đánh dấu các loại miền của mình (Taco, Ingredient, TacoOrder, v.v.) với các chú thích được cung cấp bởi quy định JPA. Những chú thích này đã ánh xạ các loại miền của bạn thành các đối tượng được lưu trữ trong cơ sở dữ liệu quan hệ. Mặc dù những chú thích đó sẽ không hoạt động cho việc lưu trữ Cassandra, nhưng Spring Data Cassandra cung cấp bộ chú thích ánh xạ riêng cho một mục đích tương tự.

Hãy bắt đầu với lớp Ingredient, vì nó là lớp đơn giản nhất để ánh xạ cho Cassandra. Lớp Ingredient mới, sẵn sàng cho Cassandra, sẽ trông như sau:

package tacos;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Table("ingredients")
public class Ingredient {

    @PrimaryKey
    private String id;
    private String name;
    private Type type;

    public enum Type {
        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
    }
}

Lớp Ingredient dường như mâu thuẫn với những gì tôi đã nói về việc chỉ cần thay đổi một số chú thích. Thay vì chú thích lớp với @Entity như bạn đã làm cho JPA persistence, nó được chú thích với @Table để chỉ định rằng các thành phần nên được lưu trữ vào một bảng có tên là ingredients. Và thay vì chú thích thuộc tính id với @Id, lần này nó được chú thích với @PrimaryKey. Cho đến nay, dường như bạn chỉ cần thay đổi một số chú thích.

Nhưng đừng để ánh xạ Ingredient đánh lừa bạn. Lớp Ingredient là một trong những loại domain đơn giản nhất của bạn. Mọi thứ trở nên thú vị hơn khi bạn ánh xạ lớp Taco cho sự tồn tại của Cassandra, như thể hiện trong đoạn mã tiếp theo.

@Data
@Table("tacos")
public class Taco {

    @PrimaryKeyColumn(type = PrimaryKeyType.PARTITIONED)
    private UUID id = Uuids.timeBased();    // partition key

    @NotNull
    @Size(min = 5, message = "Name must be at least 5 characters long")
    private String name;

    @PrimaryKeyColumn(type = PrimaryKeyType.CLUSTERED
            , ordering = Ordering.DESCENDING)
    private Date createdAt = new Date();

    @Size(min = 1, message = "You must choose at least 1 ingredient")
    @Column("ingredients")
    private List<IngredientUDT> ingredients = new ArrayList<>();

    public void addIngredient(Ingredient ingredient) {
        this.ingredients.add(TacoUDRUtils.toIngredientUDT(ingredient));
    }
}


Như bạn có thể thấy, ánh xạ lớp Taco là một chút phức tạp hơn. Như với Ingredient,, chú thích @Table được sử dụng để xác định tacos là tên của bảng mà tacos nên được ghi vào. Nhưng đó là thứ duy nhất tương tự với Ingredient..

Thuộc tính id vẫn là khóa chính của bạn, nhưng chỉ là một trong hai cột khóa chính. Cụ thể hơn, thuộc tính id được chú thích bằng @PrimaryKeyColumn với loại là PrimaryKeyType.PARTITIONED. Điều này chỉ định rằng thuộc tính id làm vai trò của partition key, được sử dụng để xác định vào phân vùng Cassandra(s) mỗi hàng dữ liệu của taco sẽ được ghi.
Bạn cũng sẽ chú ý rằng thuộc tính id bây giờ là một UUID thay vì một Long. Mặc dù không bắt buộc, những thuộc tính giữ giá trị ID được tạo tự động thường có kiểu UUID. Hơn nữa, UUID được khởi tạo với một giá trị UUID dựa trên thời gian cho các đối tượng Taco mới (nhưng có thể bị ghi đè khi đọc một Taco hiện có từ cơ sở dữ liệu).
Một chút phía dưới, bạn thấy thuộc tính createdAt được ánh xạ như một cột primary key. Nhưng trong trường hợp này, thuộc tính loại @PrimaryKeyColumn được đặt thành PrimaryKeyType.CLUSTERED, chỉ định thuộc tính createdAt là một clustering key. Như đã đề cập trước đó, khóa clustering được sử dụng để xác định thứ tự của các hàng trong một phân vùng. Cụ thể hơn, thứ tự được đặt thành thứ tự giảm dần do đó, trong một phân vùng cụ thể, các hàng mới xuất hiện đầu tiên trong bảng tacos.

Cuối cùng, thuộc tính ingredients bây giờ là một List của các đối tượng IngredientUDT thay vì một List của các đối tượng Ingredient. Như bạn nhớ, bảng Cassandra được giảm chuẩn và có thể chứa dữ liệu được duplicated từ các bảng khác. Mặc dù ingredient table sẽ là bảng ghi cho tất cả các ingredient có sẵn, nhưng các ingredient được chọn cho một taco sẽ được sao chép trong cột ingredients. Thay vì đơn giản là tham chiếu một hoặc nhiều hàng trong bảng ingredients, thuộc tính ingredients sẽ chứa đầy đủ dữ liệu cho mỗi nguyên liệu được chọn.

Nhưng tại sao bạn cần giới thiệu một lớp mới IngredientUDT? Tại sao bạn không thể đơn giản là tái sử dụng lớp Ingredient? Đơn giản là, các cột mà chứa collections of data, như cột ingredients, phải là bộ sưu tập của các loại native (số nguyên, chuỗi, v.v.) hoặc user-defined types.

Trong Cassandra, user-defined types cho phép bạn khai báo các cột bảng có tính năng phong phú hơn so với các kiểu native. Thường xuyên chúng được sử dụng như một phương tiện giảm chuẩn tương tự cho relational foreign keys.. Ngược lại với các khóa ngoại, chỉ giữ tham chiếu đến một hàng trong bảng khác, columns with user-defined types thực sự mang theo dữ liệu có thể được duplicate từ một hàng trong bảng khác. Trong trường hợp của cột ingredients trong bảng tacos, nó sẽ chứa một bộ sưu tập các cấu trúc dữ liệu định nghĩa chính ingredient chính nó. 
Bạn không thể sử dụng Ingredient class làm user-defined type, vì chú thích @Table đã ánh xạ nó như một đối tượng để lưu trữ trong Cassandra. Do đó, bạn phải tạo một lớp mới để định nghĩa cách ingredient sẽ được lưu trữ trong cột ingredients của bảng taco. IngredientUDT (nơi UDT có nghĩa là user-defined type) là lớp phù hợp cho công việc, như được hiển thị dưới đây:

@Data
@RequiredArgsConstructor
@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)
@UserDefinedType("ingredient")
public class IngredientUDT {
    private final String name;
    private final Ingredient.Type type;
}

Mặc dù IngredientUDT trông khá giống với Ingredient,, nhưng yêu cầu ánh xạ của nó đơn giản hơn nhiều. Nó được chú thích với @UserDefinedType để xác định nó là một user-defined
type trong Cassandra. Nhưng ngoài ra, nó chỉ là một lớp đơn giản với một số thuộc tính.

Bạn cũng sẽ chú ý rằng lớp IngredientUDT không bao gồm thuộc tính id. Mặc dù nó có thể bao gồm một bản sao của thuộc tính id từ nguồn Ingredient, nhưng điều đó không cần thiết. Trên thực tế, user-defined
type có thể bao gồm bất kỳ thuộc tính nào bạn mong muốn  nó không cần phải là một ánh xạ one-to-one với bất kỳ định nghĩa bảng nào.

Tôi nhận ra rằng có thể khó tưởng tượng được cách dữ liệu trong một user defined type liên quan đến dữ liệu được lưu trữ trong một bảng. Hình ảnh 4.1 hiển thị mô hình dữ liệu cho toàn bộ cơ sở dữ liệu Taco Cloud, bao gồm các user defined type.
 

Đối với user-defined type mà bạn vừa tạo, hãy chú ý cách Taco có một danh sách các đối tượng IngredientUDT, chứa dữ liệu được sao chép từ các đối tượng Ingredient. Khi một Taco được lưu trữ, đó là đối tượng Taco và danh sách các đối tượng IngredientUDT được lưu trữ vào bảng tacos. Danh sách các đối tượng IngredientUDT được lưu trữ hoàn toàn trong cột ingredients.

Một cách khác để nhìn vào điều này, có thể giúp bạn hiểu cách các user-defined type được sử dụng, là truy vấn cơ sở dữ liệu để lấy các hàng từ bảng tacos. Sử dụng CQL và công cụ cqlsh đi kèm với Cassandra, bạn sẽ thấy các kết quả sau:

 


Như bạn có thể thấy, các cột id, name và createdat chứa các giá trị đơn giản. Liên quan đến điều này, chúng không khác biệt nhiều so với những gì bạn mong đợi từ một truy vấn tương tự đối với cơ sở dữ liệu quan hệ. Nhưng cột ingredients có một chút khác biệt. Bởi vì nó được định nghĩa chứa một bộ sưu tập user-defined type (được định nghĩa bởi IngredientUDT), giá trị của nó xuất hiện dưới dạng một mảng JSON được điền với các đối tượng JSON.

Có thể bạn đã chú ý các user-defined type khác trong hình 4.1. Bạn nhất định sẽ tạo thêm một số loại khi bạn tiếp tục ánh xạ domain của mình thành các bảng Cassandra, bao gồm một số loại sẽ được sử dụng bởi lớp TacoOrder. Đoạn mã tiếp theo hiển thị lớp TacoOrder, được sửa đổi để lưu trữ Cassandra.
package tacos;

import com.datastax.oss.driver.api.core.uuid.Uuids;
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

@Data
@Table("orders")
public class TacoOrder implements Serializable {

    private static final long serialVersionUID = 1l;

    @PrimaryKey
    private UUID id = Uuids.timeBased();

    private Date placedAt = new Date();

    @Column("tacos")
    private List<TacoUDT> tacos = new ArrayList<>();

    public void addTaco(TacoUDT taco) {
        this.tacos.add(taco);
    }
}


Đoạn mã 4.2 cố ý bỏ qua nhiều thuộc tính của TacoOrder mà không phù hợp với việc thảo luận về mô hình dữ liệu Cassandra. Những gì còn lại là một số thuộc tính và ánh xạ, tương tự như cách Taco được định nghĩa. @Table được sử dụng để ánh xạ TacoOrder vào bảng orders, giống như cách đã được sử dụng trước đó với @Table. Trong trường hợp này, bạn không quan tâm đến việc sắp xếp, vì vậy thuộc tính id chỉ đơn giản được chú thích bằng @PrimaryKey, xác định nó là cả partition key và clustering key với sắp xếp mặc định.
Thuộc tính tacos có một số điều thú vị vì nó là một List<TacoUDT> thay vì một danh sách các đối tượng Taco. Mối quan hệ giữa TacoOrder và Taco/TacoUDT ở đây tương tự như mối quan hệ giữa Taco và Ingredient/IngredientUDT. Nghĩa là, thay vì kết hợp dữ liệu từ nhiều hàng trong một bảng riêng biệt thông qua khóa ngoại, bảng orders sẽ chứa tất cả dữ liệu taco liên quan, tối ưu hóa bảng để đọc nhanh.
Lớp TacoUDT khá giống với lớp IngredientUDT, tuy nhiên nó bao gồm một collection tham chiếu đến một user defined type khác, như sau:



package tacos;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.UserDefinedType;

import java.util.List;

@Data
@UserDefinedType("taco")
public class TacoUDT {
    private final String name;
    private List<IngredientUDT> ingredients;
}


4.1.4 Writing Cassandra repositories

Như bạn đã thấy trong chương 3, việc viết một repository với Spring Data đơn giản chỉ là khai báo một giao diện mà mở rộng một trong các giao diện repository cơ bản của Spring Data và tùy chọn khai báo thêm các phương thức truy vấn cho các truy vấn tùy chỉnh. Như có thể thấy, viết các repository Cassandra không khác nhiều.

Trên thực tế, có rất ít thứ mà bạn sẽ cần thay đổi trong các repository mà chúng ta đã viết để chúng hoạt động với sự tồn tại của Cassandra. Ví dụ, hãy xem xét IngredientRepository sau đây mà chúng ta đã tạo trong chương 3:
package tacos.data;

import org.springframework.data.repository.CrudRepository;
import tacos.Ingredient;

public interface IngredientRepository 
        extends CrudRepository<Ingredient, String> {
}

Bằng cách mở rộng CrudRepository như được hiển thị ở đây, IngredientRepository đã sẵn sàng lưu trữ các đối tượng Ingredient có thuộc tính ID (hoặc, trong trường hợp của Cassandra, thuộc tính khóa chính) là một chuỗi. Điều đó hoàn hảo! Không cần thay đổi nào cả cho IngredientRepository.

Các thay đổi yêu cầu cho OrderRepository chỉ phức tạp một chút. Thay vì một tham số kiểu Long, kiểu tham số ID được chỉ định khi mở rộng CrudRepository sẽ được thay đổi thành UUID như sau:

package tacos.data;

import org.springframework.data.repository.CrudRepository;
import tacos.TacoOrder;

import java.util.UUID;

public interface OrderRepository 
        extends CrudRepository<TacoOrder, UUID> {
}





Chapter05 - Securing Spring

This chapter covers
 Autoconfiguring Spring Security
 Defining custom user storage
 Customizing the login page
 Securing against CSRF attacks
 Knowing your user

Bạn đã bao giờ để ý rằng hầu hết mọi người trong các chương trình hài trên truyền hình đều không khoá cửa nhà mình chưa? Trong thời kỳ của bộ phim "Leave It to Beaver", việc để cửa mở không phải là điều quá bất thường. Nhưng có vẻ điên rồ khi ở thời điểm mà chúng ta quan tâm đến quyền riêng tư và an ninh, chúng ta thấy các nhân vật truyền hình đang tạo điều kiện cho việc truy cập không gian đến căn hộ và nhà của họ mà không bị cản trở.

Thông tin có lẽ là món đồ có giá trị nhất mà chúng ta có hiện nay; tội phạm đang tìm kiếm cách đánh cắp dữ liệu và danh tính của chúng ta bằng cách xâm nhập vào các ứng dụng không an toàn. Như là nhà phát triển phần mềm, chúng ta phải thực hiện các biện pháp để bảo vệ thông tin trong ứng dụng của chúng ta. Cho dù đó là một tài khoản email được bảo vệ bằng cặp tên người dùng và mật khẩu, hay một tài khoản môi giới được bảo vệ bằng một mã PIN giao dịch, an ninh là một khía cạnh quan trọng của hầu hết các ứng dụng.

5.1 Enabling Spring Security
Bước đầu tiên quan trọng nhất để bảo mật ứng dụng Spring của bạn là thêm dependency Spring Boot Security vào bản dựng của bạn. Trong tệp pom.xml của dự án, thêm đoạn mã sau:

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>

Tin hay không, dependency đó là thứ duy nhất cần thiết để bảo mật một ứng dụng. Khi ứng dụng khởi động, tự động cấu hình sẽ phát hiện rằng Spring Security có trong classpath và sẽ thiết lập một số cấu hình bảo mật cơ bản.

Nếu bạn muốn thử nghiệm, khởi động ứng dụng và thử truy cập trang chủ (hoặc bất kỳ trang nào). Bạn sẽ được yêu cầu xác thực bằng một trang đăng nhập khá đơn giản giống như trong hình 5.2.
 


Mẹo: Bạn có thể thấy hữu ích khi đặt trình duyệt của mình vào chế độ riêng tư hoặc ẩn danh khi kiểm thử bảo mật. Điều này sẽ đảm bảo rằng bạn có một phiên mới mỗi khi bạn mở một cửa sổ riêng tư/ẩn danh. Bạn sẽ phải đăng nhập vào ứng dụng mỗi lần, nhưng bạn có thể chắc chắn rằng mọi thay đổi bạn đã thực hiện trong bảo mật đều được áp dụng và không có dư vết của phiên cũ ngăn bạn thấy những thay đổi của mình.

Để vượt qua trang đăng nhập, bạn sẽ cần cung cấp tên người dùng và mật khẩu. Tên người dùng là "user". Còn về mật khẩu, nó được tạo ngẫu nhiên và được ghi vào tệp log ứng dụng. Mục log sẽ trông giống như sau:
Using generated security password: 087cfc6a-027d-44bc-95d7-cbb3a798a1ea
Giả sử bạn nhập tên người dùng và mật khẩu đúng, bạn sẽ được cấp quyền truy cập vào ứng dụng.

Dường như việc bảo mật ứng dụng Spring khá dễ dàng. Với ứng dụng Taco Cloud đã được bảo mật, tôi có thể kết thúc chương này ngay bây giờ và chuyển sang chủ đề tiếp theo. Nhưng trước khi tiến xa quá, hãy xem xét xem tự động cấu hình bảo mật đã cung cấp loại bảo mật nào. Bằng cách chỉ thêm dependency security vào bản dựng dự án, bạn sẽ có các tính năng bảo mật sau đây:

- Tất cả đường dẫn yêu cầu xác thực HTTP.
- Không yêu cầu bất kỳ vai trò hoặc quyền cụ thể nào.
- Yêu cầu xác thực bằng trang đăng nhập đơn giản.
- Chỉ có một người dùng; tên người dùng là "user".

Đây là một bắt đầu tốt, nhưng tôi nghĩ rằng nhu cầu về bảo mật của hầu hết các ứng dụng (bao gồm Taco Cloud) sẽ khá khác biệt so với những tính năng bảo mật cơ bản này.
Bạn cần phải làm thêm nhiều công việc nếu muốn bảo mật đúng cách ứng dụng Taco Cloud.
Ít nhất, bạn sẽ cần cấu hình Spring Security để thực hiện các bước sau:
- Cung cấp một trang đăng nhập được thiết kế để phù hợp với trang web.
- Hỗ trợ nhiều người dùng và kích hoạt một trang đăng ký để khách hàng mới của Taco Cloud có thể đăng ký.
- Áp dụng các quy tắc bảo mật khác nhau cho các đường dẫn yêu cầu khác nhau. Ví dụ, trang chủ và trang đăng ký không nên yêu cầu xác thực.
Để đáp ứng nhu cầu bảo mật của Taco Cloud, bạn sẽ phải viết một số cấu hình cụ thể, ghi đè lên những gì tự động cấu hình đã cung cấp cho bạn. Bạn sẽ bắt đầu bằng cách cấu hình một repository user đúng cách để có thể có nhiều hơn một người dùng.

5.2 Configuring authentication

Trong suốt những năm qua, đã tồn tại nhiều cách để cấu hình Spring Security, bao gồm cả cấu hình XML dài dòng. May mắn thay, một số phiên bản gần đây của Spring Security đã hỗ trợ cấu hình bằng Java, điều này giúp đơn giản hóa quá trình đọc và viết rất nhiều.
Trước khi chương này kết thúc, bạn sẽ đã cấu hình tất cả các yêu cầu bảo mật của Taco Cloud trong một cấu hình Java cho Spring Security. Nhưng để bắt đầu, bạn sẽ làm quen với nó bằng cách viết lớp cấu hình được hiển thị trong đoạn mã nguồn sau.






Listing 5.1 A barebones configuration class for Spring Security 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {
	
	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}

Cấu hình bảo mật cơ bản này thực sự không làm nhiều việc. Điều chính quan trọng nhất của nó là khai báo một bean PasswordEncoder, mà chúng ta sẽ sử dụng khi tạo người dùng mới và khi xác thực người dùng trong quá trình đăng nhập. Trong trường hợp này, chúng ta sử dụng BCryptPasswordEncoder, một trong số ít các bộ mã hóa mật khẩu được cung cấp bởi Spring Security, bao gồm:

- BCryptPasswordEncoder: Áp dụng mã hóa bảo mật bcrypt mạnh mẽ.
- NoOpPasswordEncoder: Không áp dụng mã hóa.
- Pbkdf2PasswordEncoder: Áp dụng mã hóa PBKDF2.
- SCryptPasswordEncoder: Áp dụng mã hóa bảo mật Scrypt.
- StandardPasswordEncoder: Áp dụng mã hóa bảo mật SHA-256.

Bất kỳ bộ mã hóa mật khẩu nào bạn chọn, điều quan trọng là phải hiểu rằng mật khẩu trong cơ sở dữ liệu không bao giờ được giải mã. Thay vào đó, mật khẩu mà người dùng nhập vào khi đăng nhập được mã hóa bằng cùng một thuật toán, và sau đó so sánh với mật khẩu đã được mã hóa trong cơ sở dữ liệu. So sánh này được thực hiện trong phương thức matches() của PasswordEncoder.

Bạn nên sử dụng bộ mã hóa mật khẩu nào?
Không phải tất cả các bộ mã hóa mật khẩu đều được tạo ra bằng nhau. Cuối cùng, bạn sẽ cần cân nhắc về thuật toán của mỗi bộ mã hóa mật khẩu dựa trên mục tiêu bảo mật của bạn và tự quyết định. Tuy nhiên, có một vài bộ mã hóa mật khẩu bạn nên tránh sử dụng trong ứng dụng sản xuất.
- NoOpPasswordEncoder: Bộ mã hóa này không áp dụng bất kỳ mã hóa nào cả. Do đó, mặc dù có thể hữu ích để kiểm thử, nhưng nó không thích hợp cho việc sử dụng trong sản xuất vì nó không mang lại bảo mật thực sự.

- StandardPasswordEncoder: Bộ mã hóa này không được xem xét là đủ an toàn để mã hóa mật khẩu và thực sự đã bị loại bỏ. Khuyến cáo tránh sử dụng nó trong môi trường sản xuất.

Thay vào đó, bạn nên xem xét việc sử dụng một trong những bộ mã hóa mật khẩu khác, tất cả đều cung cấp các lựa chọn an toàn hơn. Chúng tôi sẽ sử dụng BCryptPasswordEncoder cho các ví dụ trong cuốn sách này, đây là một lựa chọn mạnh mẽ và được khuyến nghị rộng rãi để bảo vệ mật khẩu.

Ngoài bộ mã hóa mật khẩu, chúng ta sẽ điền thêm các bean trong lớp cấu hình này để xác định chi tiết về bảo mật cho ứng dụng của chúng ta. Chúng ta sẽ bắt đầu bằng cách cấu hình một user store có thể xử lý nhiều người dùng.

Để cấu hình một user store cho mục đích xác thực, bạn sẽ cần khai báo một bean UserDetailsService. Giao diện UserDetailsService khá đơn giản, chỉ bao gồm một phương thức cần được triển khai. Dưới đây là giao diện UserDetailsService:
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

public interface UserDetailsService {
	UserDetails loadUserByUsername(String username) 
		throws UsernameNotFoundException;
}

Phương thức `loadUserByUsername()` chấp nhận một username và sử dụng nó để tìm một đối tượng UserDetails. Nếu không tìm thấy user cho username cung cấp, nó sẽ ném một UsernameNotFoundException.

Như đã thấy, Spring Security cung cấp một số triển khai sẵn có của UserDetailsService, bao gồm:

- User store trong bộ nhớ (in-memory user store).
- User store JDBC (JDBC user store).
- User store LDAP (LDAP user store).

Hoặc, bạn cũng có thể tạo triển khai của riêng mình để phù hợp với nhu cầu bảo mật cụ thể của ứng dụng của bạn.

Để bắt đầu, hãy thử nghiệm triển khai trong bộ nhớ (in-memory implementation) của UserDetailsService.

5.2.1 In-memory user details service

Một nơi mà thông tin người dùng có thể được giữ lại là trong bộ nhớ. Giả sử bạn chỉ có một số ít người dùng, và không có dấu hiệu nào cho thấy rằng chúng sẽ thay đổi. Trong trường hợp đó, có thể đơn giản đủ để định nghĩa những người dùng đó như là một phần của cấu hình bảo mật.
Phương thức bean sau đây mô tả cách tạo một InMemoryUserDetailsManager với hai người dùng, "buzz" và "woody," cho mục đích đó.
@Bean
public UserDetailsService userDetailsService(PasswordEncoder encoder) {
	List<UserDetails> usersList = new ArrayList<>();
	usersList.add(new User(
			"buzz", encoder.encode("password"), 
			Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"))));
	usersList.add(new User(
			"woody", encoder.encode("password"), 
			Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"))));
	return new InMemoryUserDetailsManager(usersList);
}

Ở đây, một danh sách các đối tượng User của Spring Security được tạo ra, mỗi đối tượng có một tên người dùng, mật khẩu và một danh sách chứa một hoặc nhiều quyền. Sau đó, một InMemoryUserDetailsManager được tạo ra bằng cách sử dụng danh sách đó.

Nếu bạn thử nghiệm ứng dụng ngay bây giờ, bạn nên có thể đăng nhập với tên người dùng "woody" hoặc "buzz," sử dụng "password" làm mật khẩu.

Dịch vụ chi tiết người dùng trong bộ nhớ rất thuận tiện cho mục đích kiểm thử hoặc cho các ứng dụng rất đơn giản, nhưng nó không cho phép dễ dàng chỉnh sửa thông tin người dùng. Nếu bạn cần thêm, xoá hoặc thay đổi một người dùng, bạn sẽ phải thực hiện các thay đổi cần thiết và sau đó xây dựng lại và triển khai lại ứng dụng.

Đối với ứng dụng Taco Cloud, bạn muốn khách hàng có thể đăng ký với ứng dụng và quản lý tài khoản người dùng của họ. Điều này không phù hợp với các hạn chế của dịch vụ chi tiết người dùng trong bộ nhớ. Vì vậy, hãy xem cách tạo ra triển khai của riêng chúng ta cho UserDetailsService mà cho phép sử dụng một cơ sở dữ liệu lưu trữ người dùng.

Hướng dẫn sử dụng H2 DB
Mặc định, tên database được tạo ngẫu nhiên. Tuy nhiên, điều này làm cho việc xác định URL cơ sở dữ liệu trở nên khó khăn nếu, vì một lý do nào đó, bạn cần kết nối vào cơ sở dữ liệu bằng cách sử dụng H2 console (mà Spring Boot DevTools kích hoạt tại http:/ /localhost:8080/h2-console). Do đó, nên tốt nhất là xác định rõ tên cơ sở dữ liệu bằng cách đặt một vài thông số trong application.properties.
spring.datasource.generate-unique-name=false
spring.datasource.name=tacocloud
Hoặc, nếu bạn muốn, đổi tên file `application.properties` thành `application.yml` và thêm các thuộc tính theo định dạng YAML như sau:

spring:
datasource:
generate-unique-name: false
name: tacocloud

Sự lựa chọn giữa định dạng file properties và định dạng YAML là tùy thuộc vào bạn. Spring Boot có thể làm việc với cả hai định dạng. Với cấu trúc và tính đọc được tăng cao của YAML, chúng tôi sẽ sử dụng YAML cho các thuộc tính cấu hình trong phần còn lại của cuốn sách.

Bằng cách đặt thuộc tính `spring.datasource.generate-unique-name` thành `false`, chúng tôi thông báo cho Spring rằng không cần phải tạo ra một giá trị ngẫu nhiên độc đáo cho tên cơ sở dữ liệu. Thay vào đó, nó sẽ sử dụng giá trị được đặt cho thuộc tính `spring.datasource.name`. Trong trường hợp này, tên cơ sở dữ liệu sẽ là "tacocloud". Do đó, URL cơ sở dữ liệu sẽ là "jdbc:h2:mem:tacocloud", mà bạn có thể chỉ định trong JDBC URL cho kết nối H2 console.

5.2.2 Customizing user authentication

Trong chương trước, bạn đã quyết định sử dụng Spring Data JPA làm lựa chọn lưu trữ cho tất cả dữ liệu về taco, nguyên liệu và đơn hàng. Do đó, có lý khi lưu trữ dữ liệu user theo cùng cách. Nếu bạn làm như vậy, dữ liệu sẽ cuối cùng tồn tại trong một cơ sở dữ liệu quan hệ, vì vậy bạn có thể sử dụng xác thực JDBC. Tuy nhiên, sẽ tốt hơn nếu tận dụng Spring Data JPA repository được sử dụng để lưu trữ user.

Điều quan trọng nhất là hãy tạo ra đối tượng domain và giao diện repository đại diện và lưu trữ thông tin người dùng.

DEFINING THE USER DOMAIN AND PERSISTENCE

Khi khách hàng của Taco Cloud đăng ký với ứng dụng, họ sẽ cần cung cấp nhiều hơn chỉ là một tên người dùng và mật khẩu. Họ cũng sẽ cung cấp tên đầy đủ, địa chỉ và số điện thoại. Thông tin này có thể được sử dụng cho nhiều mục đích, bao gồm việc điền trước mẫu đơn đặt hàng (chưa kể đến cơ hội tiếp thị tiềm năng).
Để thu thập tất cả thông tin đó, bạn sẽ tạo một lớp User, như sau:
Listing 5.3 Defining a user entity 

@Data
@Entity
@Table(name = "USERS")
@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)
@AllArgsConstructor
public class User implements UserDetails, Serializable{

	private static final long serialVersionUID = 1L;
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Long id;
	
	private final String username;
	private final String password;
	private final String fullname;
	private final String street;
	private final String city;
	private final String state;
	private final String zip;
	private final String phoneNumber;
	
	
	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}

}

Điều đầu tiên cần lưu ý về loại User này là nó không giống như lớp User mà chúng ta đã sử dụng khi tạo UserDetailsService trong memory. Lớp này chứa thêm chi tiết về người dùng mà chúng ta sẽ cần để xử lý các đơn đặt taco, bao gồm địa chỉ và thông tin liên hệ của người dùng.

Bạn cũng có thể đã chú ý rằng lớp User phức tạp hơn một chút so với bất kỳ đối tượng nào khác được định nghĩa trong chương 3. Ngoài việc định nghĩa một số thuộc tính, User còn triển khai giao diện UserDetails từ Spring Security.

Các triển khai của UserDetails sẽ cung cấp một số thông tin người dùng quan trọng cho framework, như những quyền được cấp cho người dùng và liệu tài khoản của người dùng có được kích hoạt hay không.
Phương thức getAuthorities() nên trả về một collection các quyền được cấp cho người dùng đó. Các phương thức is* khác trả về một giá trị boolean để chỉ định liệu tài khoản của người dùng có được kích hoạt, bị khóa hay hết hạn hay không.
Đối với đối tượng User của bạn, phương thức getAuthorities() đơn giản trả về một bộ sưu tập chỉ định rằng tất cả người dùng sẽ được cấp quyền ROLE_USER. Và, ít nhất là trong thời điểm hiện tại, Taco Cloud không cần vô hiệu hóa người dùng, nên tất cả các phương thức is* đều trả về true để chỉ định rằng người dùng đang hoạt động.
Với đối tượng User đã được định nghĩa, bạn có thể định nghĩa giao diện repository như sau:

import tacos.User;

public interface UserRepository extends CrudRepository<User, Long> {

	User findByUsername(String username);
}

Ngoài các hoạt động CRUD được cung cấp bằng cách mở rộng CrudRepository, UserRepository định nghĩa một phương thức findByUsername() mà bạn sẽ sử dụng trong UserDetailsService để tìm kiếm một User theo tên người dùng của họ.

Như bạn đã học trong chương 3, Spring Data JPA tự động tạo ra cài đặt của giao diện này vào thời gian chạy. Do đó, bạn đã sẵn sàng để viết một UserDetailsService tùy chỉnh sử dụng repository này.
CREATING A USER DETAILS SERVICE

Như bạn sẽ nhớ, giao diện UserDetailsService chỉ định một phương thức loadUserByUsername() duy nhất. Điều này có nghĩa là nó là một functional interface và có thể được triển khai dưới dạng một lambda thay vì là một lớp triển khai đầy đủ. Vì chúng ta thực sự chỉ cần cho UserDetailsService tùy chỉnh của mình để gửi yêu cầu đến UserRepository, nó có thể được đơn giản chỉ định như một bean bằng cách sử dụng phương thức cấu hình sau:

Listing 5.4 Defining a custom user details service bean 
@Configuration
public class SecurityConfig {
	
	@Bean
	PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	@Bean
	UserDetailsService userDetailsService (UserRepository userRepo) {
		return username -> {
			User user = userRepo.findByUsername(username);
			if(user != null) return user;
			
			throw new UsernameNotFoundException("User '" + username + "' not found");
		};
	}
}

Phương thức `userDetailsService()` được truyền một `UserRepository` như là tham số. Để tạo bean, nó trả về một lambda nhận một tham số là `username` và sử dụng nó để gọi `findByUsername()` trên `UserRepository` đã cho.

Phương thức `loadByUsername()` có một quy tắc đơn giản: nó không bao giờ được trả về giá trị null. Do đó, nếu cuộc gọi đến `findByUsername()` trả về null, lambda sẽ ném một `UsernameNotFoundException` (được định nghĩa bởi Spring Security). Ngược lại, đối tượng `User` được tìm thấy sẽ được trả về.

Bây giờ bạn đã có một UserDetailsService tùy chỉnh đọc thông tin người dùng thông qua một Repo JPA, bạn chỉ cần một cách để đưa người dùng vào cơ sở dữ liệu từ đầu. Bạn cần tạo một trang đăng ký để khách hàng Taco Cloud có thể đăng ký với ứng dụng.

REGISTERING USERS

Mặc dù Spring Security xử lý nhiều khía cạnh của bảo mật, nhưng nó thực sự không trực tiếp tham gia vào quá trình đăng ký người dùng. Do đó, bạn sẽ phải dựa vào một chút Spring MVC để xử lý công việc này. Lớp RegistrationController trong đoạn mã sau đây hiển thị và xử lý các form đăng ký:

Listing 5.5 A user registration controller 








Như bất kỳ controller Spring MVC điển hình nào, RegistrationController được chú thích bằng @Controller để đánh dấu nó là một controller và để đánh dấu nó để quét thành phần. Nó cũng được chú thích bằng @RequestMapping để xác định rằng nó sẽ xử lý các yêu cầu có đường dẫn là /register.

Cụ thể hơn, một yêu cầu GET cho /register sẽ được xử lý bởi phương thức registerForm(), mà đơn giản chỉ trả về một tên view logic là "registration". Đoạn mã sau đây hiển thị một mẫu Thymeleaf định nghĩa chế độ xem đăng ký.
Listing 5.6 A Thymeleaf registration form view 
<body>
	<h1>Register</h1>
	
	<form method="POST" th:action="@{/register}" id="registerForm">
		
		<label for="username">Username: </label>
		<input type="text" name="username" /> <br />
		
		<label for="password">Password: </label>
		<input type="password" name="password" /> <br />
		
		<label for="confirm">Confirm password: </label>
		<input type="password" name="confirm" /> <br />
		
		<label for="fullname">Fullname: </label>
		<input type="text" name="fullname" /> <br />
		
		<label for="street">Street: </label>
		<input type="text" name="street" /> <br />
		
		<label for="city">City: </label>
		<input type="text" name="city" /> <br />
		
		<label for="state">State: </label>
		<input type="text" name="state" /> <br />
		
		<label for="zip">Zip: </label>
		<input type="text" name="zip" /> <br />
		
		<label for="phone">Phone: </label>
		<input type="text" name="phone" /> <br />
		
		<input type="submit" value="Register" />
	</form>
</body>
</html>

Khi biểu mẫu được gửi, phương thức processRegistration() xử lý yêu cầu POST HTTPS. Các trường của biểu mẫu sẽ được liên kết với một đối tượng RegistrationForm bởi Spring MVC và được chuyển vào phương thức processRegistration() để xử lý. RegistrationForm được định nghĩa trong lớp sau:

@Data
public class RegistrationForm {
	private String username;
	private String password;
	private String fullname;
	private String street;
	private String city;
	private String state;
	private String zip;
	private String phone;
	
	public User toUser(PasswordEncoder passwordEncoder) {
		return new User(
				username, passwordEncoder.encode(password), 
				fullname, street, city, state, zip, phone);
	}
	
}

Đối với phần lớn, `RegistrationForm` chỉ là một lớp cơ bản sử dụng Lombok với một số thuộc tính. Nhưng phương thức `toUser()` sử dụng các thuộc tính đó để tạo một đối tượng `User` mới, đối tượng này sẽ được `processRegistration()` lưu trữ, sử dụng `UserRepository` đã được inject.

Bạn đã nhận thức rằng `RegistrationController` được inject với một `PasswordEncoder`. Đây chính là `PasswordEncoder` bean bạn đã khai báo trước đó. Khi xử lý một form đăng ký, `RegistrationController` truyền nó vào phương thức `toUser()`, phương thức này sử dụng nó để mã hóa mật khẩu trước khi lưu trữ vào cơ sở dữ liệu. Như vậy, mật khẩu được submit sẽ được lưu trữ dưới dạng đã được mã hóa, và dịch vụ chi tiết người dùng sẽ có thể xác thực đối với mật khẩu đã được mã hóa đó.

@PostMapping
public String processRegistration(RegistrationForm form) {
	userRepo.save(form.toUser(passwordEncoder));
	return "redirect:/login";
}


Bây giờ ứng dụng Taco Cloud đã có đầy đủ chức năng đăng ký và xác thực người dùng. Tuy nhiên, nếu bạn khởi chạy ứng dụng ở điểm này, bạn sẽ nhận thấy rằng bạn thậm chí còn không thể truy cập trang đăng ký mà không bị yêu cầu đăng nhập. Điều này xảy ra vì theo mặc định, tất cả các request đều yêu cầu xác thực. Hãy xem cách các web requests được intercept và secured để bạn có thể khắc phục tình trạng lạ này.

5.3 Securing web requests

Các yêu cầu bảo mật cho Taco Cloud nên yêu cầu người dùng xác thực trước khi thiết kế taco hoặc đặt đơn hàng. Tuy nhiên, trang chủ, trang đăng nhập và trang đăng ký nên sẵn có cho người dùng chưa xác thực.

Để cấu hình các quy tắc bảo mật này, chúng ta sẽ cần khai báo một bean `SecurityFilterChain`. 
Phương thức sau đây sẽ hiển thị Bean SecurityFilterChain.
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http.build();
}
Phương thức `filterChain()` chấp nhận một đối tượng `HttpSecurity`, đóng vai trò như một builder có thể được sử dụng để cấu hình cách bảo mật được xử lý ở cấp độ web. Khi cấu hình bảo mật được thiết lập thông qua đối tượng `HttpSecurity`, một cuộc gọi đến `build()` sẽ tạo ra một `SecurityFilterChain` được trả về từ phương thức bean.

Dưới đây là một số điều bạn có thể cấu hình với `HttpSecurity`:
- Yêu cầu rằng một số điều kiện bảo mật cụ thể phải được đáp ứng trước khi cho phép một yêu cầu được phục vụ.
- Cấu hình một trang đăng nhập tùy chỉnh.
- Cho phép người dùng đăng xuất khỏi ứng dụng.
- Cấu hình bảo vệ chống tấn công giả mạo yêu cầu qua các trang web khác nhau.
Việc chặn yêu cầu để đảm bảo người dùng có đủ quyền là một trong những điều phổ biến nhất bạn sẽ cấu hình `HttpSecurity` để thực hiện. Hãy đảm bảo rằng khách hàng Taco Cloud của bạn đáp ứng những yêu cầu này.

5.3.1 Securing requests
Bạn cần đảm bảo rằng các yêu cầu cho /design và /orders chỉ có sẵn cho người dùng đã xác thực; tất cả các yêu cầu khác nên được phép cho tất cả người dùng. Cấu hình sau đây thực hiện đúng điều đó:
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http.authorizeHttpRequests((authz) -> authz
			.requestMatchers("/design/**", "/orders/**").hasRole("USER")
			.anyRequest().permitAll());
	return http.build();
}

Cuộc gọi đến ` authorizeHttpRequests ()` trả về một đối tượng ExpressionInterceptUrlRegistry trên đó bạn có thể chỉ định các đường dẫn và mẫu URL và yêu cầu bảo mật cho những đường dẫn đó. Trong trường hợp này, bạn chỉ định hai quy tắc bảo mật sau đây:
- Yêu cầu cho /design/** và /orders/** phải là cho người dùng có quyền được cấp quyền là ROLE_USER. Đừng bao gồm tiền tố ROLE_ cho các vai trò được chuyển vào hasRole(); nó sẽ được giả định bởi hasRole().
- Tất cả các yêu cầu nên được phép cho tất cả người dùng.  permitAll()

Thứ tự của những quy tắc này quan trọng. Những quy tắc bảo mật được khai báo trước có ưu tiên hơn so với những quy tắc được khai báo phía dưới. Nếu bạn hoán đổi thứ tự của hai quy tắc bảo mật này, tất cả các yêu cầu sẽ có permitAll() được áp dụng cho chúng; quy tắc cho các yêu cầu /design và /orders sẽ không có tác dụng.

Các phương thức hasRole() và permitAll() chỉ là một số trong số các phương thức để khai báo yêu cầu bảo mật cho các đường dẫn yêu cầu. Bảng 5.1 mô tả tất cả các phương thức có sẵn.

Dưới đây là giải thích các phương thức được sử dụng trong cấu hình bảo mật của Spring Security:
1. access(String): Cho phép truy cập nếu biểu thức Spring Expression Language (SpEL) được đánh giá là true.
2. anonymous(): Cho phép truy cập cho người dùng ẩn danh (anonymous users).
3. authenticated(): Cho phép truy cập cho người dùng đã được xác thực.
4. denyAll(): Từ chối truy cập mà không xem xét điều kiện.
5. fullyAuthenticated(): Cho phép truy cập nếu người dùng đã được xác thực đầy đủ (không phải dựa trên remember-me).
6. hasAnyAuthority(String…): Cho phép truy cập nếu người dùng có một trong các quyền được chỉ định.
7. hasAnyRole(String…): Cho phép truy cập nếu người dùng có một trong các vai trò được chỉ định.
8. hasAuthority(String): Cho phép truy cập nếu người dùng có quyền được chỉ định.
9. hasIpAddress(String): Cho phép truy cập nếu yêu cầu đến từ địa chỉ IP được chỉ định.
10. hasRole(String): Cho phép truy cập nếu người dùng có vai trò được chỉ định.
11. not(): Phủ định hiệu quả của bất kỳ phương thức truy cập nào khác.
12. permitAll(): Cho phép truy cập mà không xem xét điều kiện.
13. rememberMe(): Cho phép truy cập cho người dùng được xác thực thông qua remember-me.
Với phiên bản Spring 6, nhiều phương thức đã được đánh dấu là `@Deprecated` và có thể bị loại bỏ trong phiên bản tương lai. Thay thế chúng, bạn nên sử dụng các phương thức mới được giới thiệu trong phiên bản mới nhất của Spring Security.

Hầu hết các phương thức trong bảng 5.1 cung cấp các quy tắc bảo mật cơ bản cho xử lý yêu cầu, nhưng chúng tự giới hạn, chỉ kích hoạt các quy tắc bảo mật được định nghĩa bởi những phương thức đó.
Một cách khác, bạn có thể sử dụng phương thức `access()` để cung cấp một biểu thức SpEL để khai báo các quy tắc bảo mật phong phú hơn. Spring Security mở rộng SpEL để bao gồm một số giá trị và chức năng cụ thể cho bảo mật, như được liệt kê trong bảng 5.2.

- `authentication`: Đối tượng xác thực của người dùng.
- `denyAll`: Luôn đánh giá là false.
- `hasAnyAuthority(String… authorities)`: Đúng nếu người dùng đã được cấp quyền bất kỳ trong số các quyền đã cho.
- `hasAnyRole(String… roles)`: Đúng nếu người dùng có bất kỳ vai trò nào trong số vai trò đã cho.
- `hasAuthority(String authority)`: Đúng nếu người dùng đã được cấp quyền cụ thể đã cho.
- `hasPermission(Object target, Object permission)`: Đúng nếu người dùng có quyền truy cập đối tượng cụ thể đã cho cho quyền đã cho.
- `hasPermission(Serializable targetId, String targetType, Object permission)`: Đúng nếu người dùng có quyền truy cập vào đối tượng được xác định bởi `targetId` và `targetType` cho quyền đã cho.
- `hasRole(String role)`: Đúng nếu người dùng có vai trò đã cho.
- `hasIpAddress(String ipAddress)`: Đúng nếu yêu cầu đến từ địa chỉ IP đã cho.
- `isAnonymous()`: Đúng nếu người dùng là người dùng ẩn danh.
- `isAuthenticated()`: Đúng nếu người dùng đã được xác thực.
- `isFullyAuthenticated()`: Đúng nếu người dùng đã được xác thực đầy đủ (không xác thực bằng remember-me).
- `isRememberMe()`: Đúng nếu người dùng đã được xác thực thông qua remember-me.
- `permitAll`: Luôn đánh giá là true.
- `principal`: Đối tượng chính của người dùng, thường là thông tin cơ bản về người dùng (ví dụ: tên đăng nhập).

Như bạn có thể thấy, hầu hết các phần security expression extension trong bảng 5.2 tương ứng với các phương thức tương tự trong bảng 5.1. Trên thực tế, sử dụng phương thức `access()` cùng với các biểu thức `hasRole()` và `permitAll`, bạn có thể viết như sau:

Version cũ:
 

Ở version mới, thì phương thức access() không cho phép đưa vào String, dễ nhận thấy ví dụ bên dưới sử dụng functional interface và các phương thức thay vì.
Access() chứa tham số là một functional interface AuthorizationManager<RequestAuthorizationContext>
Trong Spring Security, AuthorizationManager là một functional interface được thiết kế để kiểm tra và quyết định việc cấp quyền cho một yêu cầu xác thực cụ thể. RequestAuthorizationContext là một class đại diện cho ngữ cảnh của request HTTP trong quá trình xác thực.

AuthorizationManager<RequestAuthorizationContext>. Ngữ cảnh của request HTTP (được biểu diễn bởi RequestAuthorizationContext) cung cấp thông tin về yêu cầu, ví dụ như URL, phương thức HTTP, và các thuộc tính khác.
Việc sử dụng RequestAuthorizationContext giúp bạn có thể truy cập thông tin chi tiết của yêu cầu HTTP khi thực hiện quyết định về quyền truy cập. Điều này có thể hữu ích khi bạn cần thực hiện kiểm tra quyền truy cập dựa trên các yếu tố cụ thể của yêu cầu, chẳng hạn như URL hoặc phương thức HTTP.
Cụ thể, bạn có thể triển khai AuthorizationManager để kiểm tra quyền truy cập dựa trên RequestAuthorizationContext, và sau đó sử dụng nó trong phương thức access.





Version mới:
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http.authorizeHttpRequests((authz) -> authz
		.requestMatchers("/design", "/orders")
		.access((context, object) -> {
			boolean isUser = context.get().getAuthorities().stream()
				.anyMatch(grantedAuth -> grantedAuth.getAuthority().equals("USER"));
			boolean isTuesday = LocalDate.now().getDayOfWeek() == DayOfWeek.TUESDAY;
			return (isUser && isTuesday) 
? new AuthorizationDecision(true) 
: new AuthorizationDecision(false);
		})
		.anyRequest().permitAll());
	return http.build();
}


Với các ràng buộc bảo mật SpEL, các khả năng là vô tận. Tôi chắc chắn rằng bạn đã nghĩ ra những ràng buộc bảo mật thú vị dựa trên SpEL.

Những yêu cầu về phân quyền cho ứng dụng Taco Cloud được đáp ứng thông qua việc sử dụng `access()` và các biểu thức SpEL một cách đơn giản. Bây giờ hãy xem xét cách tùy chỉnh trang đăng nhập để phù hợp với giao diện của ứng dụng Taco Cloud.

5.3.2 Creating a custom login page
Trang đăng nhập mặc định đã tốt hơn hộp thoại HTTP basic mà bạn bắt đầu, nhưng vẫn khá đơn giản và không hoàn toàn phù hợp với giao diện của ứng dụng Taco Cloud. 
Để thay thế trang đăng nhập tích hợp sẵn, bạn cần đầu tiên thông báo cho Spring Security biết đường dẫn của trang đăng nhập tùy chỉnh của bạn sẽ là gì. Điều này có thể được thực hiện bằng cách gọi phương thức `formLogin()` trên đối tượng `HttpSecurity`, như được thể hiện dưới đây:

@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http
	.authorizeHttpRequests((authz) -> {
		authz
		.requestMatchers("/design/**", "/orders/**").hasRole("USER")
		.anyRequest().permitAll();
	})
	.formLogin(customizer -> {
		customizer.loginPage("/login");
	});
return http.build();
}

Các phương thức từ Spring Security 6.1 bị loại bỏ khỏi API và nên dùng lambda.

Cuộc gọi đến loginPage() sau đó chỉ định đường dẫn nơi trang login tùy chỉnh của bạn sẽ được cung cấp. Khi Spring Security xác định rằng user chưa được xác thực và cần đăng nhập, nó sẽ chuyển hướng họ đến địa chỉ này.
Bây giờ bạn cần cung cấp một controller xử lý các yêu cầu tại đường dẫn đó. Vì trang đăng nhập của bạn sẽ khá đơn giản chỉ là một trang view nên đủ dễ dàng để khai báo nó như một view controller trong WebConfig. Phương thức addViewControllers() sau đây thiết lập view controller của trang đăng nhập cùng với view controller ánh xạ "/"" đến trình điều khiển trang chủ

@Override
public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController("/").setViewName("home");
    registry.addViewController("/login");
}

Cuối cùng, bạn cần định nghĩa chính trang xem của trang đăng nhập. Vì bạn đang sử dụng Thymeleaf làm công cụ mô-đun, mẫu Thymeleaf sau đây nên làm việc tốt:

<body>
	<h1>Login</h1>
	
	<div th:if="${errors}">
		Unable to login. Check your username and password.
	</div>
	
	<p>New here? Click 
		<a th:href="@{/register}"> here</a> to register.
	</p>
	
	<form method="post" th:action="@{/login}" id="loginForm">
		<label for="username">Username: </label>
		<input type="text" name="username" id="username" /> <br />
		
		<label for="password">Password: </label>
		<input type="password" name="password" id="password" /> <br />
		
		<input type="submit" value="Login" />
		
	</form>
</body>
</html>

Những điều quan trọng cần lưu ý về trang đăng nhập này là đường dẫn mà nó gửi đến và tên của các trường người dùng và mật khẩu. Theo mặc định, Spring Security lắng nghe các request login tại /login và mong đợi rằng các trường name là username và password có giá trị là username và password. Tuy nhiên, điều này có thể được cấu hình. Ví dụ, cấu hình sau đây tùy chỉnh path và field name:

@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http
		.authorizeHttpRequests((authz) -> {
			authz
			.requestMatchers("/design/**", "/orders/**").hasRole("USER")
			.anyRequest().permitAll();
		})
		.formLogin(customizer -> {
			customizer
				.loginPage("/login")
				.loginProcessingUrl("/authenticate")
				.usernameParameter("user")
				.passwordParameter("pwd");
		});
	return http.build();
}

Ở đây, bạn chỉ định rằng Spring Security nên lắng nghe các request đến /authenticate để xử lý việc đăng nhập. Ngoài ra, các trường tên người dùng và mật khẩu bây giờ nên có tên là user và pwd.

Mặc định, sau khi đăng nhập thành công, người dùng sẽ được chuyển trực tiếp đến trang mà họ đang điều hướng đến khi Spring Security xác định rằng họ cần phải đăng nhập. Nếu người dùng trực tiếp điều hướng đến trang đăng nhập, một đăng nhập thành công sẽ chuyển họ đến đường dẫn gốc (ví dụ, trang chủ). Tuy nhiên, bạn có thể thay đổi điều đó bằng cách chỉ định một trang thành công mặc định, như được thể hiện dưới đây:
.formLogin(customizer -> {
	customizer
		loginPage("/login")
		.loginProcessingUrl("/authenticate")
		.usernameParameter("user")
		.passwordParameter("pwd")
		.defaultSuccessUrl("/design");
});

Như đã cấu hình ở đây, nếu người dùng đăng nhập thành công sau khi trực tiếp truy cập trang đăng nhập, họ sẽ được chuyển hướng đến trang /design. Tùy chọn, bạn có thể buộc người dùng chuyển đến trang thiết kế sau khi đăng nhập, ngay cả khi họ đã điều hướng đến nơi khác trước khi đăng nhập, bằng cách truyền giá trị true như là tham số thứ hai cho defaultSuccessUrl như sau:
.formLogin(customizer -> {
	customizer
		.loginPage("/login")
		.loginProcessingUrl("/authenticate")
		.usernameParameter("user")
		.passwordParameter("pwd")
		.defaultSuccessUrl("/design", true);
});

Đăng nhập bằng tên người dùng và mật khẩu là cách phổ biến nhất để xác thực trong một ứng dụng web. Nhưng hãy xem xét một cách khác để xác thực user sử dụng trang login của người khác.

5.3.3 Enabling third-party authentication

Bạn có thể đã thấy các liên kết hoặc nút trên trang web yêu thích của mình có chữ "Đăng nhập bằng Facebook," "Đăng nhập bằng Twitter," hoặc một cái gì đó tương tự. Thay vì yêu cầu người dùng nhập thông tin đăng nhập trên trang đăng nhập cụ thể của trang web, chúng cung cấp một cách để đăng nhập thông qua một trang web khác như Facebook mà họ có thể đã đăng nhập.

Loại xác thực này dựa trên OAuth2 hoặc OpenID Connect (OIDC). Mặc dù OAuth2 là một đặc tả về ủy quyền, và chúng ta sẽ nói thêm về cách sử dụng nó để bảo vệ các API REST trong chương 8, nhưng nó cũng có thể được sử dụng để thực hiện xác thực thông qua một trang web của bên thứ ba. OpenID Connect là một đặc tả bảo mật khác được dựa trên OAuth2 để hình thành tương tác diễn ra trong quá trình xác thực của bên thứ ba.

Để triển khai loại xác thực này trong ứng dụng Spring của bạn, bạn sẽ cần thêm OAuth2 client starter vào dự án như sau:
<dependency>
	<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>


Sau đó, ít nhất, bạn sẽ cần cấu hình thông tin về một hoặc nhiều máy chủ OAuth2 hoặc OpenID Connect mà bạn muốn xác thực. Spring Security hỗ trợ đăng nhập bằng Facebook, Google, GitHub và Okta mặc định, nhưng bạn cũng có thể cấu hình các máy khách khác bằng cách chỉ định một số thuộc tính bổ sung.

Bộ thuộc tính chung mà bạn sẽ cần cấu hình để ứng dụng của bạn hoạt động như một OAuth2/OpenID Connect client như sau:
spring:
  security:
    oauth2:
      client:
        registration:
          <oauth2 or openid provider name>:
             clientId: <client id>
                            clientSecret: <client secret>
             scope: <comma-separated list of requested scopes>

Ví dụ, giả sử cho Taco Cloud, chúng ta muốn người dùng có thể đăng nhập bằng cách sử dụng Facebook. Cấu hình sau trong application.yml sẽ thiết lập OAuth2 client:
spring:
  security:
    oauth2:
      client:
        registration:
          facebook:
            clientId: <facebook client id>
            clientSecret: <facebook client secret>
            scope: email, public_profile

Client ID và Secret là các thông tin xác thực xác định ứng dụng của bạn đối với Facebook. Bạn có thể có được Client ID và Secret bằng cách tạo một bản nhập mới cho ứng dụng tại https://developers.facebook.com/. Thuộc tính scope chỉ định quyền truy cập mà ứng dụng sẽ được cấp phép. Trong trường hợp này, ứng dụng sẽ có quyền truy cập đến địa chỉ email của người dùng và thông tin cơ bản từ hồ sơ Facebook công khai của họ.

Trong một ứng dụng đơn giản, điều này là tất cả những gì bạn cần. Khi người dùng cố gắng truy cập một trang yêu cầu xác thực, trình duyệt của họ sẽ chuyển hướng đến Facebook. Nếu họ chưa đăng nhập vào Facebook, họ sẽ được chào đón bằng trang đăng nhập Facebook. Sau khi đăng nhập vào Facebook, họ sẽ được yêu cầu ủy quyền ứng dụng của bạn và cấp quyền truy cập được yêu cầu. Cuối cùng, họ sẽ được chuyển hướng trở lại ứng dụng của bạn, nơi họ đã được xác thực.

Tuy nhiên, nếu bạn đã tùy chỉnh bảo mật bằng cách khai báo một bean SecurityFilterChain, thì bạn sẽ cần kích hoạt đăng nhập OAuth2 cùng với cấu hình bảo mật còn lại như sau:

@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http
	.authorizeHttpRequests((authz) -> {
		authz
		.requestMatchers("/design/**", "/orders/**").hasRole("USER")
		.anyRequest().permitAll();
	})
	.formLogin(customizer -> {
		customizer
		.loginPage("/login")
		.loginProcessingUrl("/authenticate")
		.usernameParameter("user")
		.passwordParameter("pwd")
		.defaultSuccessUrl("/design");
	})
	.oauth2Login(customizer -> {
	customizer.loginPage("/login");
	});
	return http.build();
}
Điều này sẽ khiến ứng dụng luôn đưa người dùng đến trang đăng nhập do ứng dụng cung cấp, nơi họ có thể chọn đăng nhập bằng tên người dùng và mật khẩu như thường lệ. Tuy nhiên, bạn cũng có thể cung cấp một liên kết trên trang đăng nhập đó cùng cơ hội để họ đăng nhập bằng Facebook. Một liên kết như vậy có thể có dạng sau trong mẫu HTML của trang đăng nhập:

<a th:href="/oauth2/authorization/facebook">Sign in with Facebook</a>

Bây giờ bạn đã xử lý việc đăng nhập, hãy chuyển sang phía bên kia của đồng xu xác thực và xem cách bạn có thể cho phép người dùng đăng xuất. Quan trọng không kém việc đăng nhập vào ứng dụng là việc đăng xuất. Để kích hoạt chức năng đăng xuất, bạn chỉ cần gọi hàm logout trên đối tượng HttpSecurity như sau:

.oauth2Login(customizer -> {
	customizer.loginPage("/login");
})
.logout(customizer -> {
	...
});
return http.build();



Điều này thiết lập một bộ lọc bảo mật mà chặn các yêu cầu POST đến /logout. Do đó, để cung cấp khả năng đăng xuất, bạn chỉ cần thêm một form và logout button vào các chế độ xem trong ứng dụng của bạn, như được hiển thị dưới đây:
<form method="POST" th:action="@{/logout}">
<input type="submit" value="Logout"/>
</form>
Khi người dùng nhấp vào nút, phiên làm việc của họ sẽ được xóa và họ sẽ đăng xuất khỏi ứng dụng. Mặc định, họ sẽ được chuyển hướng đến trang đăng nhập, nơi họ có thể đăng nhập lại. Tuy nhiên, nếu bạn muốn họ được chuyển đến một trang khác, bạn có thể gọi hàm `logoutSuccessUrl()` để chỉ định một trang đích khác sau khi đăng xuất, như thể hiện dưới đây:
.oauth2Login(customizer -> {
	customizer.loginPage("/login");
})
.logout(customizer -> {
	customizer.logoutSuccessUrl("/");
});

Trong trường hợp này, người dùng sẽ được đưa về trang chủ sau khi đăng xuất.

5.3.4 Preventing cross-site request forgery

Tấn công làm giả mạo yêu cầu từ xa (CSRF) là một loại tấn công bảo mật phổ biến. Nó liên quan đến việc đưa người dùng vào mã trên một trang web được thiết kế độc ác mà tự động (và thường là một cách âm thầm) gửi một biểu mẫu đến một ứng dụng khác thay mặt cho người dùng, người thường là nạn nhân của cuộc tấn công. Ví dụ, người dùng có thể được hiển thị một biểu mẫu trên trang web của kẻ tấn công mà tự động gửi đến một URL trên trang web ngân hàng của họ (nơi có lẽ được thiết kế kém chặt và dễ bị tấn công như vậy) để chuyển tiền. Người dùng có thể thậm chí không biết rằng cuộc tấn công đã xảy ra cho đến khi họ phát hiện tiền bị mất từ tài khoản của mình.

Để bảo vệ khỏi những cuộc tấn công như vậy, các ứng dụng có thể tạo ra một token CSRF khi hiển thị một biểu mẫu, đặt token đó trong một trường ẩn, và sau đó giữ nó để sử dụng sau này trên máy chủ. Khi biểu mẫu được gửi, token được gửi trở lại máy chủ cùng với dữ liệu biểu mẫu còn lại. Yêu cầu sau đó được chặn bởi máy chủ và so sánh với token được tạo ban đầu. Nếu token khớp, yêu cầu được phép tiếp tục. Ngược lại, biểu mẫu phải đã được tạo ra bởi một trang web độc ác mà không biết đến token được tạo ra bởi máy chủ.

May mắn thay, Spring Security có tính năng bảo vệ CSRF tích hợp sẵn. Thậm chí may mắn hơn là nó được kích hoạt mặc định và bạn không cần phải cấu hình nó một cách rõ ràng. Bạn chỉ cần đảm bảo rằng bất kỳ biểu mẫu nào mà ứng dụng của bạn gửi đi đều bao gồm một trường có name là `_csrf` chứa token CSRF. Spring Security thậm chí còn làm cho việc này trở nên dễ dàng bằng cách đặt token CSRF trong một thuộc tính yêu cầu với tên `_csrf`. Do đó, bạn có thể hiển thị token CSRF trong một trường ẩn với đoạn mã Thymeleaf sau:
<input type="hidden" name="_csrf" th:value="${_csrf.token}"/>
Nếu bạn đang sử dụng thư viện thẻ JSP của Spring MVC hoặc Thymeleaf với ngôn ngữ Spring Security, bạn thậm chí không cần phải bận tâm đến việc bao gồm một trường ẩn một cách tường minh. Trường ẩn sẽ được tạo tự động cho bạn.
Trong Thymeleaf, bạn chỉ cần đảm bảo rằng một trong các thuộc tính của phần tử `<form>` được thêm tiền tố th như là một thuộc tính Thymeleaf. Điều này thường không phải là một vấn đề, vì Thymeleaf thường cho phép hiển thị đường dẫn như là liên quan đến ngữ cảnh. Ví dụ, thuộc tính `th:action` được hiển thị dưới đây là đủ cho Thymeleaf để tạo trường ẩn cho bạn:
<form method="post" th:action="@{/login}" id="loginForm">
Có khả năng tắt chức năng hỗ trợ CSRF, nhưng tôi do dự về việc hướng dẫn bạn làm thế. Bảo vệ CSRF quan trọng và dễ xử lý trong các biểu mẫu, vì vậy hiếm khi có lý do để tắt nó. Nhưng nếu bạn khăng khăng muốn tắt nó, bạn có thể làm như sau bằng cách gọi hàm `disable()` như sau:

Một lần nữa, tôi cảnh báo bạn không nên tắt bảo vệ CSRF, đặc biệt là đối với các ứng dụng đang chạy ở môi trường sản xuất.
.oauth2Login(customizer -> {
	customizer.loginPage("/login");
})
.logout(customizer -> {
	customizer.logoutSuccessUrl("/");
})
.csrf(customizer -> {
	customizer.disable();
});

Tất cả cấu hình bảo mật của tầng web của bạn đã được thiết lập cho Taco Cloud. Trong số các điều khác, bạn hiện có một trang đăng nhập tùy chỉnh và khả năng xác thực người dùng đối với một kho người dùng JPA. Bây giờ hãy xem cách bạn có thể nhận thông tin về người dùng đã đăng nhập.

5.4 Applying method-level security

Mặc dù việc nghĩ về bảo mật ở cấp độ web-request là dễ dàng, nhưng không phải lúc nào ràng buộc bảo mật cũng được áp dụng tốt ở đây. Đôi khi, việc xác minh rằng người dùng đã xác thực và được cấp quyền đủ là tốt nhất tại điểm thực hiện hành động được bảo vệ.

Ví dụ, giả sử vì mục đích quản trị, chúng ta có một class service bao gồm một phương thức để xóa tất cả các order từ cơ sở dữ liệu. Sử dụng một OrderRepository được inject, phương thức đó có thể trông giống như sau:

public void deleteAllOrders() {
orderRepository.deleteAll();
}
Giả sử chúng ta có một controller gọi phương thức `deleteAllOrders()` như kết quả của một POST request, như dưới đây:

@Controller
@RequestMapping("/admin")
public class AdminController {
private OrderAdminService adminService;

public AdminController(OrderAdminService adminService) {
this.adminService = adminService;
}

@PostMapping("/deleteOrders")
public String deleteAllOrders() {
adminService.deleteAllOrders();
return "redirect:/admin";
}
}
Sẽ khá dễ dàng điều chỉnh SecurityConfig như sau để đảm bảo chỉ người dùng được ủy quyền mới được phép thực hiện yêu cầu POST đó:

.authorizeRequests()
...
.antMatchers(HttpMethod.POST, "/admin/**")
.access("hasRole('ADMIN')")
....

Điều này rất tốt và sẽ ngăn chặn bất kỳ người dùng không được ủy quyền nào thực hiện yêu cầu POST đến /admin/deleteOrders, dẫn đến việc tất cả các đơn đặt hàng biến mất khỏi cơ sở dữ liệu.

Nhưng giả sử rằng một số phương thức controller khác cũng gọi đến `deleteAllOrders()`. Bạn sẽ cần thêm nhiều matcher để bảo vệ các yêu cầu từ các điều khiển khác mà cần được bảo vệ.
Thay vào đó, chúng ta có thể áp dụng bảo mật trực tiếp trên phương thức `deleteAllOrders()` như sau:

@PreAuthorize("hasRole('ADMIN')")
public void deleteAllOrders() {
orderRepository.deleteAll();
}

Annotation @PreAuthorize sử dụng một biểu thức SpEL (Spring Expression Language), và nếu biểu thức đánh giá là false, phương thức sẽ không được gọi. Ngược lại, nếu biểu thức đánh giá là true, phương thức sẽ được cho phép. Trong trường hợp này, @PreAuthorize kiểm tra xem người dùng có đặc quyền ROLE_ADMIN không. Nếu có, thì phương thức sẽ được gọi và tất cả các đơn đặt hàng sẽ bị xóa. Ngược lại, nó sẽ bị dừng lại.

Trong trường hợp @PreAuthorize chặn cuộc gọi, một ngoại lệ AccessDeniedException của Spring Security sẽ được ném ra. Đây là một ngoại lệ unchecked, vì vậy bạn không cần phải bắt (catch) nó, trừ khi bạn muốn áp dụng một số hành vi tùy chỉnh xung quanh việc xử lý ngoại lệ. Nếu để ngoại lệ này không được bắt, nó sẽ nổi lên và cuối cùng sẽ được các bộ lọc của Spring Security bắt và xử lý tùy thuộc vào cấu hình, có thể là một trang HTTP 403 hoặc có thể chuyển hướng đến trang đăng nhập nếu người dùng không được xác thực.

Để @PreAuthorize hoạt động, bạn cần kích hoạt bảo mật phương thức toàn cầu. Đối với điều đó, bạn sẽ cần chú thích lớp security configuration với @EnableGlobalMethodSecurity như sau:

@Configuration
@EnableGlobalMethodSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
...
}

Bạn sẽ thấy rằng @PreAuthorize là một chú thích hữu ích cho hầu hết các nhu cầu bảo mật ở cấp độ phương thức. Tuy nhiên, hãy biết rằng nó có một phiên bản sau khi gọi ít hữu ích hơn một chút là @PostAuthorize. Chú thích @PostAuthorize hoạt động gần giống như chú thích @PreAuthorize, ngoại trừ việc biểu thức của nó sẽ không được đánh giá cho đến sau khi phương thức mục tiêu được gọi và trả về. Điều này cho phép biểu thức xem xét giá trị trả về của phương thức để quyết định liệu có cho phép gọi phương thức hay không.

Ví dụ, giả sử chúng ta có một phương thức trả về một đơn đặt hàng dựa trên ID của nó. Nếu bạn muốn hạn chế việc sử dụng nó chỉ cho phép bởi các quản trị viên hoặc bởi người dùng thuộc quyền sở hữu đơn đặt hàng, bạn có thể sử dụng @PostAuthorize như sau:

@PostAuthorize("hasRole('ADMIN') || " +
"returnObject.user.username == authentication.name")
public TacoOrder getOrder(long id) {
...
}

Trong trường hợp này, returnObject trong TacoOrder được trả về từ phương thức. Nếu thuộc tính user của nó có tên người dùng bằng với thuộc tính name của xác thực, thì nó sẽ được phép. Tuy nhiên, để biết điều đó, phương thức sẽ cần được thực thi để nó có thể trả về đối tượng TacoOrder để xem xét.

Nhưng chờ đã! Làm thế nào bạn có thể bảo vệ một phương thức khỏi việc được gọi nếu điều kiện áp dụng bảo mật phụ thuộc vào giá trị trả về từ cuộc gọi phương thức? Bài toán conundrum này được giải quyết bằng cách cho phép phương thức được gọi, sau đó ném một AccessDeniedException nếu biểu thức trả về false.

5.5 Knowing your user

Thường thì việc chỉ biết rằng người dùng đã đăng nhập và được cấp quyền là không đủ. Thông thường, cũng quan trọng để biết ai họ là, để bạn có thể tùy chỉnh trải nghiệm của họ.
Ví dụ, trong OrderController, khi bạn tạo đối tượng TacoOrder ban đầu được liên kết với biểu mẫu đặt hàng, sẽ tốt nếu bạn có thể điền trước các thông tin cho TacoOrder với tên và địa chỉ của người dùng, để họ không cần phải nhập lại cho mỗi đơn đặt hàng. Có thể thậm chí quan trọng hơn, khi bạn lưu đơn đặt hàng của họ, bạn nên liên kết đối tượng TacoOrder với Người dùng đã tạo đơn đặt hàng.

Để đạt được sự kết nối mong muốn giữa một đối tượng TacoOrder và một đối tượng Người dùng, bạn cần thêm thuộc tính mới sau vào lớp TacoOrder:
@ManyToOne
private User user;

Chú thích @ManyToOne trên thuộc tính này cho biết một đơn đặt hàng thuộc về một người dùng duy nhất và ngược lại, một người dùng có thể có nhiều đơn đặt hàng. (Do bạn đang sử dụng Lombok, bạn không cần phải định nghĩa rõ ràng các phương thức truy cập cho thuộc tính này.)

Trong OrderController, phương thức processOrder() chịu trách nhiệm lưu đơn đặt hàng. Nó sẽ cần được sửa đổi để xác định ai là người dùng đã xác thực và gọi setUser() trên đối tượng TacoOrder để kết nối đơn đặt hàng với người dùng.
Có một số cách để xác định ai là người dùng. Dưới đây là một vài cách phổ biến nhất:

- Inject một đối tượng java.security.Principal vào phương thức của controller.
- Inject một đối tượng org.springframework.security.core.Authentication vào phương thức của controller.
- Sử dụng org.springframework.security.core.context.SecurityContextHolder để lấy ra ngữ cảnh bảo mật.
- Inject một tham số phương thức được chú thích bằng @AuthenticationPrincipal. (@AuthenticationPrincipal đến từ gói org.springframework.security.core.annotation của Spring Security.)

Ví dụ, bạn có thể sửa đổi processOrder() để chấp nhận một java.security.Principal như một tham số. Sau đó, bạn có thể sử dụng principal name để tìm kiếm người dùng từ UserRepository như sau:

@PostMapping
	public String processOrder(
			@Valid TacoOrder order, Errors errors, 
			SessionStatus sessionStatus, Principal principal) {
		if(errors.hasErrors()) {
			return "orderForm";
		}
		User user = userRepository.findByUsername(principal.getName());
		order.setUser(user);
		
		log.info("Order submitted: {}", order);
		sessionStatus.setComplete();
		
		return "redirect:/";
	}

Điều này hoạt động tốt, nhưng nó tạo ra mã nguồn không liên quan đến bảo mật trong các phần khác của mã nguồn. Bạn có thể giảm bớt một số mã nguồn cụ thể cho bảo mật bằng cách sửa đổi processOrder() để chấp nhận một đối tượng Authentication làm tham số thay vì một Principal, như sau:
Úi giời, nói thẳng ra là Authentication nó mạnh mẽ hơn, thay vì Principal chỉ có mỗi phương thức getName() thì thằng kia có nhiều phương thức hữu ích hơn.

@PostMapping
	public String processOrder(
			@Valid TacoOrder order, Errors errors, 
			SessionStatus sessionStatus, Authentication authentication) {
		if(errors.hasErrors()) {
			return "orderForm";
		}
		User user = (User) authentication.getPrincipal();
		order.setUser(user);
		
		log.info("Order submitted: {}", order);
		sessionStatus.setComplete();
		
		return "redirect:/";
	}


Với đối tượng `Authentication` trong tay, bạn có thể gọi `getPrincipal()` để lấy đối tượng principal, trong trường hợp này, là một đối tượng `User`. Lưu ý rằng `getPrincipal()` trả về một đối tượng `java.util.Object`, vì vậy bạn cần chuyển đổi nó thành đối tượng `User`.

Tuy nhiên, có lẽ giải pháp sạch sẽ nhất trong tất cả là đơn giản là chấp nhận một đối tượng `User` trong `processOrder()`, nhưng chú thích nó bằng `@AuthenticationPrincipal` để nó sẽ là principal của xác thực, như sau:

@PostMapping
	public String processOrder(
			@Valid TacoOrder order, Errors errors, 
			SessionStatus sessionStatus,
			@AuthenticationPrincipal User user) {
		if(errors.hasErrors()) {
			return "orderForm";
		}
		
		order.setUser(user);
		orderRepo.save(order);
		
		log.info("Order submitted: {}", order);
		sessionStatus.setComplete();
		
		return "redirect:/";
	}

Ưu điểm của `@AuthenticationPrincipal` là nó không yêu cầu việc chuyển đổi kiểu (như trong trường hợp của `Authentication`), và nó giới hạn mã nguồn cụ thể cho bảo mật chỉ trong chính chú thích đó. Đến khi bạn nhận được đối tượng `User` trong `processOrder()`, nó đã sẵn sàng để sử dụng và gán cho `TacoOrder`.

Còn một cách khác để xác định ai là người dùng đã xác thực, mặc dù nó hơi phức tạp vì nó chứa nhiều mã nguồn cụ thể về bảo mật. Bạn có thể lấy được đối tượng `Authentication` từ SecurityContextHolder và sau đó yêu cầu principal của nó như sau:
@PostMapping
public String processOrder(
	@Valid TacoOrder order, Errors errors, 
	SessionStatus sessionStatus) {
	
if(errors.hasErrors()) {
		return "orderForm";
	}
		
	Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
	User user = (User) authentication.getPrincipal();
	
	order.setUser(user);
	orderRepo.save(order);
	
	log.info("Order submitted: {}", order);
	sessionStatus.setComplete();
	
	return "redirect:/";
}


Mặc dù đoạn mã này khá dày về mã nguồn cụ thể về bảo mật, nhưng nó có một ưu điểm so với các phương pháp khác đã mô tả: nó có thể được sử dụng ở bất cứ đâu trong ứng dụng, không chỉ trong các phương thức xử lý của controller. Điều này làm cho nó phù hợp để sử dụng ở các cấp độ thấp hơn của mã nguồn.

Chapter 06 - Working with
configuration properties

This chapter covers
 Fine-tuning autoconfigured beans
 Applying configuration properties to application
components
 Working with Spring profiles

Bạn nhớ khi iPhone lần đầu tiên xuất hiện không? Một viên thanh nhỏ bằng kim loại và kính hầu như không phù hợp với mô tả của thế giới đối với điện thoại di động. Và tuy nhiên, nó mở đầu cho thời kỳ điện thoại thông minh hiện đại, thay đổi mọi thứ về cách chúng ta giao tiếp. Mặc dù điện thoại cảm ứng có nhiều cách tiếp cận dễ dàng và mạnh mẽ hơn nhiều so với điện thoại gập trước đó, khi iPhone được công bố lần đầu, khó có thể tưởng tượng được làm thế nào một thiết bị chỉ có một nút có thể được sử dụng để thực hiện cuộc gọi.
Một cách nào đó, autoconfiguration của Spring Boot cũng giống như vậy. Autoconfiguration giúp đơn giản hóa phát triển ứng dụng Spring. Nhưng sau một thập kỷ đặt giá trị thuộc tính trong cấu hình Spring XML và gọi các phương thức setter trên các đối tượng bean, không ngay lập tức có thể nhận thức được cách đặt giá trị thuộc tính cho các bean mà không có cấu hình rõ ràng.
May mắn thay, Spring Boot cung cấp một cách để đặt giá trị thuộc tính trên các thành phần ứng dụng với các thuộc tính cấu hình. Các thuộc tính cấu hình không gì khác ngoài các thuộc tính trên các bean được chú thích bằng @ConfigurationProperties trong ngữ cảnh ứng dụng Spring. Spring sẽ tiêm giá trị từ một trong số nhiều nguồn thuộc tính, bao gồm các thuộc tính hệ thống JVM, đối số dòng lệnh và biến môi trường, vào các thuộc tính của bean. Chúng ta sẽ xem cách sử dụng @ConfigurationProperties trên các bean của chúng ta trong phần 6.2. Nhưng Spring Boot chính nó cung cấp một số bean được chú thích bằng @ConfigurationProperties mà chúng ta sẽ cấu hình trước tiên.
Trong chương này, bạn sẽ bước lùi lại một chút từ việc triển khai các tính năng mới trong ứng dụng Taco Cloud để khám phá các thuộc tính cấu hình. Những gì bạn học sẽ không nghi ngờ sẽ hữu ích khi bạn tiến lên trong các chương tiếp theo. Chúng ta sẽ bắt đầu bằng cách xem cách sử dụng các thuộc tính cấu hình để điều chỉnh những gì Spring Boot tự động cấu hình.
6.1 Fine-tuning autoconfiguration

Trước khi chúng ta đào sâu quá sâu vào với các configuration properties, quan trọng là phải thiết lập các loại cấu hình khác nhau (nhưng liên quan) sau đây trong Spring:

- Bean wiring: Configuration khai báo các application components để được tạo ra như các bean trong Spring application context và cách chúng nên được inject vào nhau.
  
- Property injection: Configuration đặt giá trị cho các bean trong Spring application context.

Trong XML và cấu hình Java của Spring, hai loại cấu hình này thường được khai báo một cách rõ ràng ở cùng một nơi. Trong cấu hình Java, một phương thức được chú thích bằng @Bean có khả năng cả tạo ra một bean và sau đó đặt giá trị cho các thuộc tính của nó. Ví dụ, xem xét phương thức @Bean sau đây khai báo một DataSource cho một cơ sở dữ liệu H2 nhúng:

@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript("taco_schema.sql")
        .addScripts("user_data.sql", "ingredient_data.sql")
        .build();
}

Ở đây, các phương thức addScript() và addScripts() đặt một số thuộc tính String với tên của các script SQL mà nên được áp dụng cho cơ sở dữ liệu khi datasource đã sẵn sàng. Trong khi đây là cách bạn có thể cấu hình một bean DataSource nếu bạn không sử dụng Spring Boot, autoconfiguration làm cho phương thức này hoàn toàn không cần thiết.

Nếu dependency của H2 có sẵn trong đường classpath khi chạy, Spring Boot tự động tạo ra một bean DataSource phù hợp trong ngữ cảnh ứng dụng Spring, áp dụng các kịch bản SQL schema.sql và data.sql.

Nhưng nếu bạn muốn đặt tên cho các kịch bản SQL làm gì? Hoặc nếu bạn cần chỉ định nhiều hơn hai kịch bản SQL? Đó là lúc configuration properties xuất hiện. Tuy nhiên, trước khi bạn có thể bắt đầu sử dụng các configuration properties, bạn cần hiểu rõ nguồn gốc của những thuộc tính đó là gì.
6.1.1 Understanding Spring’s environment abstraction

Spring environment abstraction là một điểm đến duy nhất cho bất kỳ configurable property nào. Nó trừu tượng hóa nguồn gốc của các thuộc tính để các bean cần những thuộc tính đó có thể tiêu thụ chúng từ Spring chính mình. Spring environment thu thập từ một số nguồn thuộc tính sources property, bao gồm các nguồn sau đây:

- JVM system properties.
- Biến môi trường của hệ điều hành - Operating system environment variables.
- Đối số dòng lệnh - Command-line arguments.
- Các tệp cấu hình thuộc tính ứng dụng - Application property configuration files.

Sau đó, nó tổng hợp những thuộc tính đó thành một nguồn duy nhất từ đó các bean Spring có thể được tiêm vào. Hình 6.1 minh họa cách các thuộc tính từ các nguồn thuộc tính trải qua Spring environment abstraction để đến các bean Spring.

 
Các bean được tự động cấu hình bởi Spring Boot đều có thể được cấu hình thông qua các thuộc tính lấy từ môi trường của Spring. Như một ví dụ đơn giản, giả sử bạn muốn máy chủ servlet cơ bản của ứng dụng lắng nghe yêu cầu trên một cổng khác ngoài cổng mặc định là 8080. Để làm điều đó, hãy chỉ định một cổng khác bằng cách đặt thuộc tính server.port trong tệp src/main/resources/application.properties như sau:
server.port=9090
Điều này sẽ làm cho máy chủ servlet của ứng dụng lắng nghe yêu cầu trên cổng 9090 thay vì cổng mặc định là 8080.

Tính cá nhân, tôi thích sử dụng YAML khi đặt các thuộc tính cấu hình. Do đó, thay vì sử dụng `application.properties`, tôi có thể đặt giá trị `server.port` trong tệp `src/main/resources/application.yml` như sau:

```yaml
server:
  port: 9090
```

Nếu bạn muốn cấu hình thuộc tính đó từ bên ngoài, bạn cũng có thể chỉ định cổng khi bắt đầu ứng dụng bằng một đối số dòng lệnh như sau:

```bash
$ java -jar tacocloud-0.0.5-SNAPSHOT.jar --server.port=9090
```

Nếu bạn muốn ứng dụng luôn bắt đầu trên một cổng cụ thể, bạn có thể đặt nó một lần làm biến môi trường của hệ điều hành, như được thể hiện dưới đây:

```bash
$ export SERVER_PORT=9090
```

Chú ý rằng khi đặt thuộc tính như biến môi trường, kiểu đặt tên có chút khác biệt để phù hợp với các ràng buộc được đặt trên tên biến môi trường bởi hệ điều hành. Điều này hoàn toàn chấp nhận được. Spring có khả năng sắp xếp và hiểu SERVER_PORT là server.port mà không gặp vấn đề nào.

Như tôi đã nói, chúng ta có nhiều cách để đặt các thuộc tính cấu hình. Trên thực tế, bạn có thể sử dụng một trong hàng trăm thuộc tính cấu hình để điều chỉnh cách các bean Spring hoạt động. Bạn đã thấy một số trong số đó: `server.port` trong chương này, cũng như `spring.datasource.name` và `spring.thymeleaf.cache` trong các chương trước.

Không thể xem xét tất cả các thuộc tính cấu hình có sẵn trong chương này. Tuy nhiên, hãy xem một số thuộc tính cấu hình hữu ích nhất mà bạn có thể gặp thường xuyên. Chúng ta sẽ bắt đầu với một số thuộc tính cho phép bạn điều chỉnh nguồn dữ liệu được tự động cấu hình.

6.1.2 Configuring a data source

Ở thời điểm này, ứng dụng Taco Cloud vẫn chưa hoàn thiện, nhưng bạn sẽ có nhiều chương sau để chăm sóc điều đó trước khi sẵn sàng triển khai ứng dụng. Do đó, cơ sở dữ liệu H2 nhúng mà bạn đang sử dụng làm nguồn dữ liệu là hoàn hảo cho nhu cầu của bạn - ít nhất là trong thời điểm hiện tại. Nhưng khi bạn đưa ứng dụng vào môi trường sản xuất, bạn có thể muốn xem xét một giải pháp cơ sở dữ liệu lâu dài hơn.

Mặc dù bạn có thể cấu hình một bean DataSource của riêng mình một cách rõ ràng, nhưng điều này thường là không cần thiết. Thay vào đó, việc đơn giản hóa việc cấu hình URL và thông tin đăng nhập cho cơ sở dữ liệu thông qua các thuộc tính cấu hình là cách tiện lợi hơn. Ví dụ, nếu bạn muốn bắt đầu sử dụng cơ sở dữ liệu MySQL, bạn có thể thêm các thuộc tính cấu hình sau vào `application.yml`:

spring:
   datasource:
     url: jdbc:mysql:/ /localhost/tacocloud
     username: tacouser
     password: tacopassword

Mặc dù bạn sẽ cần thêm driver JDBC phù hợp vào dự án, thường thì bạn không cần phải chỉ định class driver JDBC - Spring Boot có thể tự tìm hiểu nó từ cấu trúc URL của cơ sở dữ liệu. Nhưng nếu gặp vấn đề, bạn có thể thử đặt thuộc tính `spring.datasource.driver-class-name` như sau:

```yaml
spring:
  datasource:
    url: jdbc:mysql:/ /localhost/tacocloud
    username: tacouser
    password: tacopassword
    driver-class-name: com.mysql.jdbc.Driver
```

Spring Boot sử dụng dữ liệu kết nối này khi tự động cấu hình bean DataSource. Bean DataSource sẽ được đặt trong HikariCP connection pool nếu nó có sẵn trong classpath. Nếu không có, Spring Boot sẽ tìm kiếm và sử dụng một trong những pool kết nối sau đây khác trên classpath:

- Tomcat JDBC Connection Pool.
- Apache Commons DBCP2.

Mặc dù đây là những tùy chọn pool kết nối duy nhất có sẵn thông qua tự động cấu hình, bạn luôn có thể tùy chỉnh cấu hình một bean DataSource để sử dụng bất kỳ triển khai pool kết nối nào bạn muốn.

Trước đây trong chương này, chúng tôi gợi ý rằng có thể có một cách để chỉ định các kịch bản khởi tạo cơ sở dữ liệu để chạy khi ứng dụng bắt đầu. Trong trường hợp này, các thuộc tính `spring.datasource.schema` và `spring.datasource.data`, được hiển thị dưới đây, là hữu ích:

```yaml
spring:
  datasource:
    schema:
      - order-schema.sql
      - ingredient-schema.sql
      - taco-schema.sql
      - user-schema.sql
    data:
      - ingredients.sql
```

Có lẽ cấu hình datasource một cách tường minh không phải là phong cách của bạn. Thay vào đó, có lẽ bạn muốn cấu hình datasource của mình trong Java Naming and Directory Interface (JNDI) và để Spring tìm kiếm từ đó. Trong trường hợp đó, thiết lập datasource của bạn bằng cách cấu hình `spring.datasource.jndi-name` như sau:

```yaml
spring:
  datasource:
    jndi-name: java:/comp/env/jdbc/tacoCloudDS
```

Nếu bạn đặt thuộc tính `spring.datasource.jndi-name`, các thuộc tính kết nối nguồn dữ liệu khác (nếu được đặt) sẽ bị bỏ qua.

6.1.3 Configuring the embedded server

Bạn đã thấy cách đặt cổng của máy chủ servlet bằng cách đặt `server.port`. Nhưng điều mà tôi chưa chỉ bạn là điều gì xảy ra nếu `server.port` được đặt thành 0, như hiển thị ở đây:

```yaml
server:
  port: 0
```

Mặc dù bạn đang đặt `server.port` thành 0 một cách rõ ràng, máy chủ sẽ không bắt đầu ở cổng 0. Thay vào đó, nó sẽ bắt đầu ở một cổng có sẵn được chọn ngẫu nhiên. Điều này hữu ích khi chạy các bài kiểm tra tích hợp tự động để đảm bảo rằng bất kỳ bài kiểm tra nào đang chạy đồng thời không xung đột với một số cổng được cứng nhắc.

Nhưng không chỉ có cổng là quan trọng với máy chủ cơ bản. Một trong những công việc phổ biến nhất bạn sẽ cần thực hiện với máy chủ cơ bản là cấu hình nó để xử lý các yêu cầu HTTPS. Để làm điều đó, điều đầu tiên bạn phải làm là tạo keystore bằng tiện ích dòng lệnh keytool của JDK, như được hiển thị dưới đây:

```bash
$ keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA
```

Bạn sẽ được hỏi một số câu hỏi về tên và tổ chức của bạn, hầu hết trong số đó không liên quan. Nhưng khi được hỏi về mật khẩu, hãy nhớ mật khẩu bạn chọn. Ví dụ, trong trường hợp này, tôi đã chọn letmein làm mật khẩu.

Tiếp theo, bạn sẽ cần đặt một số thuộc tính để kích hoạt HTTPS trong máy chủ nhúng. Bạn có thể chỉ định chúng tất cả trên dòng lệnh, nhưng điều đó sẽ rất bất tiện. Thay vào đó, bạn có thể đặt chúng trong tệp `application.properties` hoặc `application.yml`. Trong `application.yml`, các thuộc tính có thể trông như sau:

```yaml
server:
  port: 8443
  ssl:
    key-store: file:///path/to/mykeys.jks
    key-store-password: letmein
    key-password: letmein
```

Ở đây, thuộc tính `server.port` được đặt thành 8443, một lựa chọn phổ biến cho máy chủ HTTPS phát triển. Thuộc tính `server.ssl.key-store` nên được đặt thành đường dẫn nơi tệp keystore được tạo. Ở đây, nó được hiển thị với URL `file:///` để tải nó từ hệ thống tệp, nhưng nếu bạn đóng gói nó trong tệp JAR ứng dụng, bạn sẽ sử dụng URL `classpath:` để tham chiếu nó. Cả hai thuộc tính `server.ssl.key-store-password` và `server.ssl.key-password` được đặt thành mật khẩu đã chọn khi tạo keystore.

Với các thuộc tính này, ứng dụng của bạn nên lắng nghe các yêu cầu HTTPS trên cổng 8443. Tùy thuộc vào trình duyệt bạn đang sử dụng, bạn có thể gặp cảnh báo về việc máy chủ không thể xác minh danh tính của nó. Điều này không phải là vấn đề khi phục vụ từ localhost trong quá trình phát triển.

6.1.4 Configuring logging

Hầu hết các ứng dụng đều cung cấp một hình thức ghi log. Thậm chí nếu ứng dụng của bạn không ghi bất cứ điều gì trực tiếp, thì thư viện mà ứng dụng của bạn sử dụng chắc chắn sẽ ghi log hoạt động của chúng.

Mặc định, Spring Boot cấu hình ghi log thông qua Logback (http://logback.qos.ch) để ghi vào bảng điều khiển ở mức INFO. Có lẽ bạn đã thấy rất nhiều mục nhập mức INFO trong nhật ký ứng dụng khi bạn chạy ứng dụng và các ví dụ khác. Nhưng để nhắc nhở, đây là một mẫu ghi log hiển thị định dạng log mặc định (được đặt vào để vừa với các lề trang):

```plaintext
2021-07-29 17:24:24.187 INFO 52240 --- [nio-8080-exec-1] com.example.demo.Hello - Here's a log entry.
2021-07-29 17:24:24.187 INFO 52240 --- [nio-8080-exec-1] com.example.demo.Hello - Here's another log entry.
2021-07-29 17:24:24.187 INFO 52240 --- [nio-8080-exec-1] com.example.demo.Hello - And here's one more.
```

Để có sự kiểm soát đầy đủ về cấu hình ghi log, bạn có thể tạo một tệp logback.xml ở gốc của classpath (trong src/main/resources). Dưới đây là một ví dụ về tệp logback.xml đơn giản mà bạn có thể sử dụng:

```xml
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
      </pattern>
    </encoder>
  </appender>
  <logger name="root" level="INFO"/>
  <root level="INFO">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
```

Với cấu hình mới này, các mục ghi log mẫu từ trước đây có thể trông như sau (được đặt vào để vừa với các lề trang):

```plaintext
17:25:09.088 [http-nio-8080-exec-1] INFO com.example.demo.Hello - Here's a log entry.
17:25:09.088 [http-nio-8080-exec-1] INFO com.example.demo.Hello - Here's another log entry.
17:25:09.088 [http-nio-8080-exec-1] INFO com.example.demo.Hello - And here's one more.
```

Ngoài ra, ngoại trừ mẫu được sử dụng cho ghi log, cấu hình Logback này có thể coi là tương đương với cấu hình mặc định bạn sẽ nhận được nếu không có tệp logback.xml. Nhưng bằng cách chỉnh sửa tệp logback.xml, bạn có thể có sự kiểm soát đầy đủ về các tệp log của ứng dụng của bạn.

LƯU Ý: Những chi tiết về nội dung có thể đi vào tệp logback.xml nằm ngoài phạm vi của cuốn sách này. Hãy tham khảo tài liệu của Logback để biết thêm thông tin.

Những thay đổi phổ biến nhất bạn sẽ thực hiện trên cấu hình ghi log là thay đổi các mức ghi log và có thể chỉ định một tệp nơi các log sẽ được ghi. Với các thuộc tính cấu hình của Spring Boot, bạn có thể thực hiện những thay đổi đó mà không cần phải tạo một tệp logback.xml.

Để đặt các mức ghi log, bạn tạo các thuộc tính có tiền tố là `logging.level`, tiếp theo là tên của logger mà bạn muốn đặt mức ghi log. Ví dụ, giả sử bạn muốn đặt mức ghi log của root thành WARN, nhưng ghi log của Spring Security ở mức DEBUG. Các mục sau đây trong `application.yml` sẽ giải quyết vấn đề đó cho bạn:

```yaml
logging:
  level:
    root: WARN
    org:
      springframework:
        security: DEBUG
```

Tuỳ chọn, bạn có thể thu gọn tên gói của Spring Security thành một dòng duy nhất để đọc dễ dàng hơn như sau:

```yaml
logging:
  level:
    root: WARN
    org.springframework.security: DEBUG
```

Giả sử bạn muốn viết các mục log vào tệp TacoCloud.log tại /var/logs/. Các thuộc tính `logging.file.path` và `logging.file.name` có thể giúp đạt được điều đó, như dưới đây:

```yaml
logging:
  file:
    path: /var/logs/
    file: TacoCloud.log
  level:
    root: WARN
    org:
      springframework:
        security: DEBUG
```
•	root: WARN: Điều này đặt mức độ ghi log cho logger gốc (root logger) của ứng dụng thành WARN. Điều này có nghĩa là chỉ những mục log có mức độ WARN trở lên mới được ghi vào log.
•	org.springframework.security: DEBUG: Điều này đặt mức độ ghi log cho logger của Spring Security thành DEBUG. Điều này có nghĩa là tất cả các mức độ ghi log từ DEBUG trở lên của Spring Security sẽ được ghi vào log. Việc này giúp theo dõi chi tiết các sự kiện quan trọng trong quá trình xử lý bảo mật.
•	Thông thường, mức độ ghi log được sắp xếp theo thứ bậc từ thấp đến cao như sau: 
TRACE, DEBUG, INFO, WARN, ERROR.

Giả sử ứng dụng có quyền ghi vào /var/logs/, các mục log sẽ được ghi vào /var/logs/TacoCloud.log. Mặc định, các tệp log xoay khi chúng đạt đến kích thước 10 MB.

6.2 Creating your own configuration properties

Như tôi đã đề cập trước đó, các configuration properties không gì khác ngoài các property của các bean đã được chỉ định để chấp nhận cấu hình từ Spring environment abstraction. Điều tôi không đề cập đến là làm cách nào những bean đó được chỉ định để tiêu thụ những cấu hình đó.

Để hỗ trợ việc chèn giá trị từ các thuộc tính cấu hình, Spring Boot cung cấp chú thích `@ConfigurationProperties`. Khi đặt trên bất kỳ bean Spring nào, nó chỉ định rằng các thuộc tính của bean đó có thể được chèn từ các thuộc tính trong môi trường Spring.

Để minh họa cách `@ConfigurationProperties` hoạt động, giả sử bạn đã thêm phương thức sau vào `OrderController` để liệt kê các đơn đặt hàng trước đó của người dùng đã xác thực:
@GetMapping
public String ordersForUser(
      @AuthenticationPrincipal User user, Model model) {

    model.addAttribute("orders",
    orderRepo.findByUserOrderByPlacedAtDesc(user));
    return "orderList";
}

Cùng với đó, bạn cũng đã thêm phương thức findByUserOrderByPlacedAtDesc() cần thiết tiếp theo vào OrderRepository:
```java
List<Order> findByUserOrderByPlacedAtDesc(User user);
```
Lưu ý rằng phương thức này trong repository được đặt tên với một điều kiện là OrderByPlacedAtDesc. Phần OrderBy chỉ định một thuộc tính theo đó kết quả sẽ được sắp xếp - trong trường hợp này là thuộc tính placedAt. Phần Desc ở cuối làm cho thứ tự được sắp xếp theo thứ tự giảm dần. Do đó, danh sách các đơn hàng được trả về sẽ được sắp xếp từ mới nhất đến cũ nhất.

Như đã viết, phương thức trong controller này có thể hữu ích sau khi người dùng đã đặt một số đơn hàng, nhưng nó có thể trở nên khó kiểm soát đối với những người yêu thích taco hết mức. Một vài đơn hàng được hiển thị trên trình duyệt là hữu ích; một danh sách không ngừng của hàng trăm đơn hàng chỉ là tiếng ồn. Giả sử bạn muốn giới hạn số đơn hàng hiển thị chỉ là 20 đơn hàng gần đây nhất. Bạn có thể thay đổi phương thức ordersForUser() như sau:
```java
@GetMapping
public String ordersForUser(
        @AuthenticationPrincipal User user, Model model) {
    Pageable pageable = PageRequest.of(0, 20);
    model.addAttribute("orders",
            orderRepo.findByUserOrderByPlacedAtDesc(user, pageable));
    return "orderList";
}
```
Kèm theo đó là những thay đổi tương ứng trong OrderRepository, như sau:
```java
List<TacoOrder> findByUserOrderByPlacedAtDesc(
        User user, Pageable pageable);
```
Ở đây, bạn đã thay đổi chữ ký của phương thức findByUserOrderByPlacedAtDesc() để chấp nhận một Pageable làm tham số. Pageable là cách Spring Data chọn một phần của kết quả thông qua số trang và kích thước trang. Trong phương thức controller ordersForUser(), bạn đã tạo một đối tượng PageRequest thực hiện Pageable để yêu cầu trang đầu tiên (trang số 0) với kích thước trang là 20 để lấy tối đa 20 đơn hàng được đặt gần đây nhất cho người dùng.

Mặc dù điều này hoạt động tuyệt vời, nhưng nó khiến tôi cảm thấy hơi bất an vì bạn đã cứng cỏi kích thước trang. Điều gì sẽ xảy ra nếu sau này bạn quyết định rằng 20 là quá nhiều đơn hàng để liệt kê và bạn muốn thay đổi nó thành 10? Bởi vì nó đã được cứng cỏi, bạn sẽ phải xây dựng lại và triển khai ứng dụng.
Thay vì cứng cỏi kích thước trang, bạn có thể đặt nó bằng một thuộc tính cấu hình tùy chỉnh. Trước tiên, bạn cần thêm một thuộc tính mới có tên là pageSize vào OrderController, sau đó đánh dấu OrderController với @ConfigurationProperties như thể hiện trong đoạn mã tiếp theo.
@Controller
@RequestMapping("/orders")
@SessionAttributes("order")
@ConfigurationProperties(prefix="taco.orders")
public class OrderController {
private int pageSize = 20;
public void setPageSize(int pageSize) {
this.pageSize = pageSize;
}
...
@GetMapping
public String ordersForUser(
@AuthenticationPrincipal User user, Model model) {
Pageable pageable = PageRequest.of(0, pageSize);
model.addAttribute("orders",
orderRepo.findByUserOrderByPlacedAtDesc(user, pageable));
return "orderList";
}
}

Sự thay đổi quan trọng nhất được thực hiện trong danh sách 6.1 là việc thêm chú thích @ConfigurationProperties. Thuộc tính prefix của nó được thiết lập là taco.orders, điều này có nghĩa là khi thiết lập thuộc tính pageSize, bạn cần sử dụng một thuộc tính cấu hình có tên là taco.orders.pageSize.

Thuộc tính mới pageSize này có giá trị mặc định là 20, nhưng bạn có thể dễ dàng thay đổi nó thành bất kỳ giá trị nào bạn muốn bằng cách thiết lập một thuộc tính taco.orders.pageSize. Ví dụ, bạn có thể đặt thuộc tính này trong tệp application.yml như sau:

taco:
orders:
pageSize: 10

Hoặc, nếu bạn cần thực hiện một thay đổi nhanh chóng trong quá trình sản xuất, bạn có thể làm điều này mà không cần phải xây dựng lại và triển khai ứng dụng bằng cách thiết lập thuộc tính taco.orders.pageSize như một biến môi trường như sau:

```bash
$ export TACO_ORDERS_PAGESIZE=10
```

Bất kỳ phương tiện nào mà một thuộc tính cấu hình có thể được thiết lập đều có thể được sử dụng để điều chỉnh kích thước trang của trang đơn hàng gần đây. Tiếp theo, chúng ta sẽ xem cách thiết lập dữ liệu cấu hình trong các giữ nguyên thuộc tính.
6.2.1 Defining configuration property holders

Không có điều gì quy định rằng @ConfigurationProperties phải được đặt trên một controller hoặc bất kỳ loại bean cụ thể nào khác. Thực tế, @ConfigurationProperties thường được đặt trên các bean có mục đích chính trong ứng dụng là giữ dữ liệu cấu hình. Điều này giúp giữ thông tin cụ thể về cấu hình ra khỏi các controllers và các lớp ứng dụng khác. Nó cũng giúp dễ dàng chia sẻ các thuộc tính cấu hình chung giữa nhiều bean có thể sử dụng thông tin đó.

Trong trường hợp thuộc tính pageSize trong OrderController, bạn có thể trích xuất nó vào một lớp riêng biệt. Đoạn mã dưới đây sử dụng lớp OrderProps như vậy.
package tacos.web;
import org.springframework.boot.context.properties.
ConfigurationProperties;
import org.springframework.stereotype.Component;
import lombok.Data;
@Component
@ConfigurationProperties(prefix="taco.orders")
@Data
public class OrderProps {
private int pageSize = 20;
}
Như bạn đã làm với OrderController, thuộc tính pageSize mặc định là 20, và OrderProps được chú thích bằng @ConfigurationProperties để có một tiền tố là taco.orders. Nó cũng được chú thích bằng @Component để việc quét thành phần tự động của Spring sẽ tự động phát hiện và tạo nó như một bean trong ngữ cảnh ứng dụng Spring. Điều này quan trọng, vì bước tiếp theo là tiêm OrderProps bean vào trong OrderController.

Không có gì đặc biệt về configuration property holders. Chúng là các bean có thuộc tính được tiêm từ môi trường Spring. Chúng có thể được tiêm vào bất kỳ bean nào khác cần sử dụng những thuộc tính đó. Đối với OrderController, điều này có nghĩa là loại bỏ thuộc tính pageSize khỏi OrderController và thay vào đó tiêm và sử dụng bean OrderProps, như thể hiện ở dưới:

private OrderProps props;
public OrderController(OrderRepository orderRepo,
OrderProps props) {
this.orderRepo = orderRepo;
this.props = props;
}
...
@GetMapping
public String ordersForUser(
@AuthenticationPrincipal User user, Model model) {
Pageable pageable = PageRequest.of(0, props.getPageSize());
model.addAttribute("orders",
orderRepo.findByUserOrderByPlacedAtDesc(user, pageable));
return "orderList";
}
Bây giờ, OrderController không còn chịu trách nhiệm xử lý các thuộc tính cấu hình của nó nữa. Điều này giữ mã trong OrderController gọn gàng hơn một chút và cho phép bạn tái sử dụng các thuộc tính trong OrderProps cho bất kỳ bean nào cần chúng. Hơn nữa, bạn đang tổng hợp các thuộc tính cấu hình liên quan đến đơn hàng ở một nơi duy nhất: lớp OrderProps. Nếu bạn cần thêm, loại bỏ, đổi tên hoặc thay đổi các thuộc tính trong đó, bạn chỉ cần thực hiện những thay đổi đó trong OrderProps. Đối với mục đích kiểm thử, việc thiết lập trực tiếp các thuộc tính cấu hình trên một OrderProps cụ thể cho kiểm thử và cung cấp nó cho controller trước khi chạy kiểm thử trở nên dễ dàng.

Ví dụ, hãy giả sử bạn đang sử dụng thuộc tính pageSize trong một số bean khác nhau khi bạn quyết định rằng sẽ tốt nhất là áp dụng một số kiểm tra hợp lý cho thuộc tính đó để giới hạn giá trị của nó không ít hơn 5 và không quá 25. Nếu không có một bean giữ giá trị, bạn sẽ phải áp dụng các chú thích kiểm tra cho OrderController, thuộc tính pageSize và tất cả các lớp khác sử dụng thuộc tính đó. Nhưng do đã trích xuất pageSize thành OrderProps, bạn chỉ cần thực hiện các thay đổi trên OrderProps, như thể hiện ở đây:

package tacos.web;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import org.springframework.boot.context.properties.
ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import lombok.Data;
@Component
@ConfigurationProperties(prefix="taco.orders")
@Data
@Validated
public class OrderProps {
@Min(value=5, message="must be between 5 and 25")
@Max(value=25, message="must be between 5 and 25")
private int pageSize = 20;
}
6.2.2 Declaring configuration property metadata

Tùy thuộc vào môi trường phát triển tích hợp (IDE) bạn đang sử dụng, bạn có thể đã chú ý rằng mục taco.orders.pageSize trong tệp application.yml (hoặc application.properties) hiển thị một cảnh báo tương tự như "Unknown Property 'taco'". Cảnh báo này xuất hiện vì có thông tin mô tả cấu hình bị thiếu đối với thuộc tính cấu hình mà bạn vừa tạo. Hình ảnh 6.2 mô tả trông như thế nào khi tôi di chuyển chuột qua phần taco của thuộc tính trong Spring Tool Suite.

 

Thông tin mô tả cho thuộc tính cấu hình là hoàn toàn tùy chọn và không ngăn cản việc hoạt động của các thuộc tính cấu hình. Nhưng thông tin mô tả có thể hữu ích để cung cấp một số tài liệu tối thiểu xung quanh các thuộc tính cấu hình, đặc biệt là trong môi trường Phần mềm Phát triển tích hợp (IDE).

Ví dụ, khi di chuột qua thuộc tính `spring.security.user.password`, bạn sẽ thấy thông tin như hiển thị trong hình ảnh 6.3. Mặc dù thông tin hỗ trợ bạn nhận được có thể là tối thiểu, nhưng có thể đủ để hiểu rõ mục đích của thuộc tính và cách sử dụng nó.
 
Để giúp những người có thể sử dụng các thuộc tính cấu hình bạn định nghĩa - ngay cả có thể là bạn chính mình - nói chung là một ý tưởng tốt để tạo một số thông tin mô tả xung quanh những thuộc tính đó. Ít nhất là nó giúp loại bỏ những cảnh báo màu vàng phiền toái trong IDE.

Để tạo thông tin mô tả cho các thuộc tính cấu hình tùy chỉnh của bạn, bạn cần tạo một tệp tin trong thư mục `META-INF` (ví dụ: trong dự án, nằm dưới `src/main/resources/META-INF`), đặt tên là `additional-spring-configuration-metadata.json`.
QUICK-FIXING MISSING METADATA
Nếu bạn đang sử dụng Spring Tool Suite, có một tùy chọn sửa lỗi nhanh chóng để tạo thông tin mô tả cho thuộc tính cấu hình bị thiếu. Đặt con trỏ chuột của bạn trên dòng có cảnh báo mô tả bị thiếu và mở cửa sổ tùy chọn sửa lỗi nhanh chóng bằng cách sử dụng CMD-1 trên Mac hoặc Ctrl-1 trên Windows và Linux (xem hình ảnh 6.4).
Sau đó, chọn tùy chọn "Create Metadata for..." để thêm một số thông tin mô tả cho thuộc tính. Nếu nó chưa tồn tại, tùy chọn sửa lỗi nhanh chóng này sẽ tạo một tệp trong META-INF/additional-spring-configuration-metadata.json và điền thông tin mô tả cho thuộc tính pageSize như được hiển thị trong mã nguồn tiếp theo:

```json
{
  "properties": [
    {
      "name": "taco.orders.page-size",
      "type": "java.lang.String",
      "description": "A description for 'taco.orders.page-size'"
    }
  ]
}
```

Lưu ý rằng tên thuộc tính được tham chiếu trong thông tin mô tả là taco.orders.page-size, trong khi tên thực tế của thuộc tính trong application.yml là pageSize. Tính linh hoạt của Spring Boot trong việc đặt tên thuộc tính cho phép có sự biến đổi trong tên thuộc tính, điều này có nghĩa là taco.orders.page-size tương đương với taco.orders.pageSize, vì vậy không quan trọng bạn chọn biểu diễn nào.

Thông tin mô tả ban đầu được viết vào additional-spring-configuration-metadata.json là một bắt đầu tốt, nhưng bạn có thể muốn chỉnh sửa nó một chút. Trước hết, thuộc tính pageSize không phải là một java.lang.String, vì vậy bạn muốn thay đổi nó thành java.lang.Integer. Và thuộc tính mô tả nên được thay đổi để mô tả chi tiết hơn về mục đích của pageSize. Mã nguồn JSON dưới đây thể hiện thông tin mô tả có thể trông như thế nào sau một số chỉnh sửa:

```json
{
  "properties": [
    {
      "name": "taco.orders.page-size",
      "type": "java.lang.Integer",
      "description": "Sets the maximum number of orders to display in a list."
    }
  ]
}
```

Với thông tin mô tả đó đã được thêm vào, các cảnh báo nên biến mất. Điều quan trọng hơn, nếu bạn di chuột qua thuộc tính taco.orders.pageSize, bạn sẽ thấy mô tả được hiển thị như trong hình ảnh 6.5.
 
 
Như bạn đã thấy, các thuộc tính cấu hình rất hữu ích để điều chỉnh cả các thành phần được tự động cấu hình cũng như các chi tiết được tiêm vào các bean ứng dụng của bạn. Nhưng nếu bạn cần cấu hình các thuộc tính khác nhau cho các môi trường triển khai khác nhau thì sao? Hãy xem cách sử dụng Spring profiles để thiết lập cấu hình cụ thể cho môi trường.

6.3 Configuring with profiles

Khi ứng dụng được triển khai trong các môi trường thực thi khác nhau, thì thường các chi tiết cấu hình khác nhau. Các chi tiết về kết nối cơ sở dữ liệu, ví dụ, có thể khác nhau giữa môi trường phát triển và môi trường kiểm định chất lượng, và chúng vẫn khác nhau trong môi trường sản xuất. Một cách để cấu hình các thuộc tính duy nhất trong một môi trường so với môi trường khác là sử dụng biến môi trường để xác định các thuộc tính cấu hình thay vì định nghĩa chúng trong application.properties và application.yml.

Ví dụ, trong quá trình phát triển, bạn có thể sử dụng cơ sở dữ liệu H2 được tự động cấu hình. Nhưng trong môi trường sản xuất, bạn có thể đặt các thuộc tính cấu hình cơ sở dữ liệu như biến môi trường như sau:
```bash
$ export SPRING_DATASOURCE_URL=jdbc:mysql:/ /localhost/tacocloud
$ export SPRING_DATASOURCE_USERNAME=tacouser
$ export SPRING_DATASOURCE_PASSWORD=tacopassword
```

Mặc dù điều này sẽ hoạt động, nhưng việc chỉ định hơn một hoặc hai thuộc tính cấu hình như biến môi trường có phần khó khăn. Hơn nữa, không có cách tốt để theo dõi các thay đổi của biến môi trường hoặc để dễ dàng quay lại các thay đổi nếu có một sai sót.

Thay vào đó, tôi thích tận dụng Spring profiles. Các profiles là một loại cấu hình có điều kiện, trong đó các bean khác nhau, các lớp cấu hình và các thuộc tính cấu hình được áp dụng hoặc bị bỏ qua dựa trên các profiles nào đang hoạt động vào thời điểm thực thi.

Ví dụ, giả sử với mục đích phát triển và gỡ lỗi, bạn muốn sử dụng cơ sở dữ liệu H2 được nhúng và bạn muốn đặt cấp độ ghi nhật ký cho mã Taco Cloud thành DEBUG. Nhưng trong môi trường sản xuất, bạn muốn sử dụng cơ sở dữ liệu MySQL bên ngoại và đặt cấp độ ghi nhật ký thành WARN. Trong tình huống phát triển, việc không đặt bất kỳ thuộc tính nguồn dữ liệu nào và nhận cơ sở dữ liệu H2 được tự động cấu hình là dễ dàng. Và đối với ghi nhật ký ở cấp độ DEBUG, bạn có thể đặt thuộc tính logging.level.tacos cho gói tacos thành DEBUG trong application.yml như sau:

```yaml
logging:
  level:
    tacos: DEBUG
```

Điều này là chính xác những gì bạn cần cho mục đích phát triển. Nhưng nếu bạn triển khai ứng dụng này trong môi trường sản xuất mà không có bất kỳ thay đổi nào khác trong application.yml, bạn vẫn có ghi nhật ký DEBUG cho gói tacos và một cơ sở dữ liệu H2 được nhúng. Những gì bạn cần là định nghĩa một profile với các thuộc tính phù hợp cho môi trường sản xuất.

6.3.1 Defining profile-specific properties

Một cách để định nghĩa các thuộc tính cụ thể cho profile là tạo một tệp YAML hoặc properties khác chỉ chứa các thuộc tính cho môi trường sản xuất. Tên tệp nên tuân theo quy ước này: `application-{tên profile}.yml` hoặc `application-{tên profile}.properties`. Sau đó, bạn có thể chỉ định các thuộc tính cấu hình phù hợp với profile đó. Ví dụ, bạn có thể tạo một tệp mới có tên là `application-prod.yml` chứa các thuộc tính sau:

```yaml
spring:
  datasource:
    url: jdbc:mysql:/ /localhost/tacocloud
    username: tacouser
    password: tacopassword
logging:
  level:
    tacos: WARN
```

Một cách khác để chỉ định các thuộc tính cụ thể cho profile chỉ hoạt động với cấu hình YAML. Điều này liên quan đến việc đặt các thuộc tính cụ thể cho profile cùng với các thuộc tính không liên quan đến profile trong `application.yml`, được ngăn cách bằng ba dấu gạch ngang và thuộc tính `spring.profiles` để đặt tên cho profile. Khi áp dụng các thuộc tính sản xuất vào `application.yml` theo cách này, toàn bộ `application.yml` sẽ trông như sau:

```yaml
logging:
  level:
    tacos: DEBUG
---
spring:
  profiles: prod
  datasource:
    url: jdbc:mysql:/ /localhost/tacocloud
    username: tacouser
    password: tacopassword
  logging:
    level:
      tacos: WARN
```

Như bạn có thể thấy, tệp `application.yml` này được chia thành hai phần bởi một bộ ba dấu gạch ngang (`---`). Phần thứ hai chỉ định một giá trị cho `spring.profiles`, cho biết các thuộc tính tiếp theo áp dụng cho profile `prod`. Phần thứ nhất, ngược lại, không chỉ định giá trị cho `spring.profiles`. Do đó, các thuộc tính của nó là chung cho tất cả các profile hoặc là các giá trị mặc định nếu profile hoạt động không có thuộc tính nào được đặt.

Bất kỳ profiles nào được kích hoạt khi ứng dụng chạy, cấp độ ghi nhật ký cho gói tacos sẽ được đặt thành DEBUG bởi thuộc tính được đặt trong profile mặc định. Nhưng nếu profile có tên là `prod` được kích hoạt, thì thuộc tính `logging.level.tacos` sẽ bị ghi đè bằng giá trị WARN. Tương tự, nếu profile `prod` được kích hoạt, thì các thuộc tính nguồn dữ liệu sẽ được đặt để sử dụng cơ sở dữ liệu MySQL bên ngoại.

Bạn có thể định nghĩa các thuộc tính cho bất kỳ profile nào bạn cần bằng cách tạo thêm tệp YAML hoặc properties với mẫu `application-{tên profile}.yml` hoặc `application-{tên profile}.properties`. Hoặc nếu bạn thích, gõ thêm ba dấu gạch ngang trong `application.yml` cùng với một thuộc tính `spring.profiles` khác để chỉ định tên profile. Sau đó, thêm tất cả các thuộc tính cụ thể cho profile bạn cần. Mặc dù không có lợi ích nào cho cách tiếp cận này, bạn có thể thấy rằng việc đặt tất cả các cấu hình profile trong một tệp YAML duy nhất hoạt động tốt khi số lượng thuộc tính là nhỏ, trong khi các tệp riêng biệt cho mỗi profile là tốt hơn khi bạn có một số lượng lớn thuộc tính.

6.3.2 Activating profiles

Thiết lập các thuộc tính cụ thể cho profile sẽ không hữu ích nếu những profile đó không được kích hoạt. Nhưng làm thế nào để kích hoạt một profile? Việc duy nhất cần để kích hoạt một profile là bao gồm nó trong danh sách tên profile được đưa vào thuộc tính `spring.profiles.active`. Ví dụ, bạn có thể đặt nó trong `application.yml` như sau:

```yaml
spring:
  profiles:
    active:
      - prod
```

Nhưng đó có lẽ là cách tồi nhất để đặt một profile active. Nếu bạn đặt profile active trong `application.yml`, sau đó profile đó trở thành profile mặc định, và bạn sẽ không đạt được bất kỳ lợi ích nào từ việc sử dụng profile để tách riêng các thuộc tính cụ thể cho production từ các thuộc tính phát triển. Thay vào đó, tôi khuyến khích bạn đặt profile(s) active bằng biến môi trường. Trên môi trường sản xuất, bạn sẽ đặt `SPRING_PROFILES_ACTIVE` như sau:

```bash
$ export SPRING_PROFILES_ACTIVE=prod
```

Từ đó, bất kỳ ứng dụng triển khai trên máy đó sẽ có profile prod active, và các thuộc tính cấu hình tương ứng sẽ có ưu tiên hơn các thuộc tính trong profile mặc định.

Nếu bạn chạy ứng dụng dưới dạng tệp JAR có thể chạy được, bạn cũng có thể đặt profile active với một đối số dòng lệnh như sau:

```bash
$ java -jar taco-cloud.jar --spring.profiles.active=prod
```

Lưu ý rằng tên thuộc tính `spring.profiles.active` chứa từ ngữ số nhiều "profiles". Điều này có nghĩa là bạn có thể chỉ định nhiều hơn một profile active. Thường, điều này được thực hiện với một danh sách được phân cách bằng dấu phẩy khi đặt nó với biến môi trường, như được thể hiện ở đây:

```bash
$ export SPRING_PROFILES_ACTIVE=prod,audit,ha
```

Nhưng trong YAML, bạn sẽ chỉ định nó như một danh sách như sau:

```yaml
spring:
  profiles:
    active:
      - prod
      - audit
      - ha
```

Điều đáng lưu ý là nếu bạn triển khai một ứng dụng Spring lên Cloud Foundry, một profile có tên là cloud sẽ tự động được kích hoạt cho bạn. Nếu Cloud Foundry là môi trường sản xuất của bạn, bạn sẽ muốn đảm bảo rằng bạn chỉ định các thuộc tính cụ thể cho production dưới profile cloud.

Như vậy, có thể thấy rằng profiles không chỉ hữu ích để đặt điều kiện cho việc đặt cấu hình trong một ứng dụng Spring. Hãy xem cách khai báo các bean cụ thể cho một profile active.

6.3.3 Conditionally creating beans with profiles
Đôi khi, việc cung cấp một tập hợp duy nhất của các bean cho các profile khác nhau là hữu ích. Thông thường, bất kỳ bean nào được khai báo trong một lớp cấu hình Java đều được tạo ra, bất kể profile nào đang được kích hoạt. Nhưng giả sử bạn cần một số bean chỉ được tạo ra nếu một profile cụ thể được kích hoạt. Trong trường hợp đó, chú thích @Profile có thể chỉ định rằng các bean chỉ áp dụng cho một profile đã cho.

Ví dụ, giả sử bạn có một bean CommandLineRunner được khai báo trong TacoCloudApplication được sử dụng để tải dữ liệu nguyên liệu vào cơ sở dữ liệu nhúng khi ứng dụng bắt đầu. Điều này rất tốt cho việc phát triển nhưng sẽ không cần thiết (và không mong muốn) trong một ứng dụng sản xuất. Để ngăn dữ liệu nguyên liệu từ việc được tải mỗi khi ứng dụng bắt đầu trong một triển khai sản xuất, bạn có thể chú thích phương thức CommandLineRunner bằng @Profile như sau:

```java
@Bean
@Profile("dev")
public CommandLineRunner dataLoader(IngredientRepository repo,
UserRepository userRepo, PasswordEncoder encoder) {
...
}
```

Hoặc giả sử bạn cần CommandLineRunner được tạo ra nếu cả hai profile dev hoặc qa đều được kích hoạt. Trong trường hợp đó, bạn có thể liệt kê các profile mà bean nên được tạo ra như sau:

```java
@Bean
@Profile({"dev", "qa"})
public CommandLineRunner dataLoader(IngredientRepository repo,
UserRepository userRepo, PasswordEncoder encoder) {
...
}
```

Bây giờ, dữ liệu nguyên liệu sẽ chỉ được tải nếu profile dev hoặc qa được kích hoạt. Điều này có nghĩa là bạn cần kích hoạt profile dev khi chạy ứng dụng trong môi trường phát triển. Sẽ thuận tiện hơn nếu CommandLineRunner bean đó được tạo ra mọi khi trừ khi profile prod được kích hoạt. Trong trường hợp đó, bạn có thể áp dụng @Profile như sau:

```java
@Bean
@Profile("!prod")
public CommandLineRunner dataLoader(IngredientRepository repo,
UserRepository userRepo, PasswordEncoder encoder) {
...
}
```

Ở đây, dấu chấm than (!) phủ định tên profile. Hiệu quả là, nó cho biết rằng CommandLineRunner bean sẽ được tạo ra nếu profile prod không được kích hoạt.

Cũng có thể sử dụng @Profile trên một toàn bộ lớp được chú thích bằng @Configuration. Ví dụ, giả sử bạn rút trích CommandLineRunner bean vào một lớp cấu hình riêng biệt có tên là DevelopmentConfig. Sau đó, bạn có thể chú thích DevelopmentConfig bằng @Profile như sau:

```java
@Profile({"!prod", "!qa"})
@Configuration
public class DevelopmentConfig {
    @Bean
    public CommandLineRunner dataLoader(IngredientRepository repo,
    UserRepository userRepo, PasswordEncoder encoder) {
    ...
    }
}
```

Ở đây, CommandLineRunner bean (cũng như bất kỳ bean khác được định nghĩa trong DevelopmentConfig) sẽ chỉ được tạo ra nếu không có profile nào là prod hoặc qa đang được kích hoạt.


Integrated Spring – Pa	rt 2

Các chương trong phần 2 bao gồm các chủ đề giúp tích hợp ứng dụng Spring của bạn với các ứng dụng khác. Chương 7 mở rộng cuộc thảo luận về Spring MVC bắt đầu từ chương 2 bằng cách xem xét cách viết REST APIs trong Spring. Chúng ta sẽ xem cách định nghĩa các REST end point trong Spring MVC, tự động tạo ra các REST end point dựa trên repository với Spring Data REST và tiêu thụ REST APIs. Chương 8 xem xét cách bảo vệ một API bằng cách sử dụng hỗ trợ OAuth 2 của Spring Security cũng như cách có được sự authorization trong mã nguồn client có thể truy cập vào các API được bảo vệ bằng OAuth 2. Trong chương 9, chúng ta sẽ xem xét việc sử dụng asynchronous communication để cho phép ứng dụng Spring gửi và nhận thông điệp sử dụng Java Message Service (JMS), RabbitMQ và Kafka. Cuối cùng, chương 10 thảo luận về khai báo application integration   bằng dự án Spring Integration. Chúng ta sẽ bao gồm xử lý dữ liệu theo thời gian thực (real time), định nghĩa luồng tích hợp (integration flow) và tích hợp với các hệ thống bên ngoài như email và hệ thống tệp.

Chapter 07-Creating REST services

This chapter covers
 Defining REST endpoints in Spring MVC
 Automatic repository-based REST endpoints
 Consuming REST APIs

Trình duyệt web đã chết. Bây giờ là gì?"
Vài năm trước, tôi nghe ai đó đề xuất rằng trình duyệt web đang tiến gần đến trạng thái kế thừa và điều gì đó khác sẽ thay thế. Nhưng điều này làm thế nào có thể xảy ra? Cái gì có thể lật đổ trình duyệt web gần như phổ biến này? Làm thế nào chúng ta sẽ tiêu thụ số lượng ngày càng tăng của các trang web và dịch vụ trực tuyến nếu không phải bằng một trình duyệt web? Chắc chắn rằng những điều này chỉ là những lời nói huyền bí của một người điên!
Chuyển đến ngày nay, và rõ ràng là trình duyệt web không biến mất. Nhưng nó không còn là phương tiện chính để truy cập internet. Thiết bị di động, máy tính bảng, đồng hồ thông minh và thiết bị dựa trên giọng nói hiện đang phổ biến. Ngay cả nhiều ứng dụng dựa trên trình duyệt thực sự đang chạy các ứng dụng JavaScript thay vì để trình duyệt làm một thiết bị dumb terminal cho nội dung được render từ máy chủ.
Với một lựa chọn lớn về các tùy chọn phía client, nhiều ứng dụng đã áp dụng một thiết kế chung trong đó giao diện người dùng được đẩy gần hơn đến client và máy chủ mở ra một API thông qua đó mọi loại client có thể tương tác với chức năng backend."

"Trong chương này, bạn sẽ sử dụng Spring để cung cấp một REST API cho ứng dụng Taco Cloud. Bạn sẽ sử dụng những kiến thức bạn đã học về Spring MVC trong chương 2 để tạo các end point RESTful với các controller Spring MVC. Bạn cũng sẽ tự động tiếp cận các end point REST cho các repository Spring mà bạn đã định nghĩa trong chương 3 và 4. Cuối cùng, chúng ta sẽ xem xét cách kiểm thử và bảo mật những end point đó.

Nhưng trước hết, bạn sẽ bắt đầu viết một số controller mới của Spring MVC, mà sẽ tiếp cận các chức năng backend thông qua các end point REST để được tiêu thụ bởi một giao diện web phong phú.

7.1 Writing RESTful controllers
Đơn giản mà nói, REST API không khác nhiều so với trang web. Cả hai đều liên quan đến việc phản hồi các yêu cầu HTTP. Nhưng điểm khác biệt chính là thay vì phản hồi những yêu cầu đó bằng HTML như trang web, REST API thường phản hồi bằng một định dạng có hướng dữ liệu như JSON hoặc XML.

Trong chương 2, bạn đã sử dụng các chú thích @GetMapping và @PostMapping để truy xuất và đăng dữ liệu lên máy chủ. Những chú thích tương tự sẽ vẫn hữu ích khi bạn định nghĩa REST API của mình. Ngoài ra, Spring MVC hỗ trợ một số chú thích khác nhau cho các loại yêu cầu HTTP khác nhau, như được liệt kê trong bảng 7.1.
 

Để xem các chú thích này hoạt động, bạn sẽ bắt đầu bằng cách tạo một điểm cuối REST đơn giản, truy xuất vài chiếc taco được tạo gần đây nhất.
7.1.1 Retrieving data from the server
"Một điều mà chúng tôi muốn ứng dụng Taco Cloud có khả năng thực hiện là cho phép các tín đồ taco thiết kế những chiếc taco riêng của họ và chia sẻ chúng với những người yêu thích taco khác. Một cách để làm điều đó là hiển thị một danh sách các taco được tạo gần đây nhất trên trang web. Để hỗ trợ tính năng đó, chúng ta cần tạo một end point xử lý các yêu cầu GET cho /api/tacos bao gồm một tham số "recent" và phản hồi bằng một danh sách các taco được thiết kế gần đây. Bạn sẽ tạo một controller mới để xử lý yêu cầu như vậy. Đoạn mã tiếp theo hiển thị controller cho công việc này.
Listing 7.1 A RESTful controller for taco design API requests 
"Có thể bạn nghĩ rằng tên của bộ điều khiển này nghe có vẻ quen thuộc một chút. Trong chương 2, bạn đã tạo một bộ điều khiển có tên tương tự là DesignTacoController xử lý các loại yêu cầu tương tự. Nhưng nơi mà bộ điều khiển đó dành cho việc tạo ra một kết quả HTML trong ứng dụng Taco Cloud, bộ điều khiển mới này là một bộ điều khiển REST, như được chỉ định bởi chú thích @RestController.

Chú thích @RestController phục vụ hai mục đích. Thứ nhất, nó là một stereotype annotation (chú thích mô phỏng) giống như @Controller và @Service mà đánh dấu một lớp để được phát hiện thông qua quét thành phần. Nhưng quan trọng nhất đối với cuộc thảo luận về REST, chú thích @RestController nói với Spring rằng tất cả các phương thức xử lý trong controller nên có giá trị trả về được ghi trực tiếp vào body của response, thay vì được mang đi trong model đến một chế độ xem để hiển thị.

Hoặc bạn có thể đã chú thích TacoController với @Controller, giống như bất kỳ bộ điều khiển Spring MVC nào khác. Nhưng sau đó, bạn sẽ cần chú thích tất cả các phương thức xử lý bằng @ResponseBody để đạt được kết quả tương tự. Một lựa chọn khác sẽ là trả về một đối tượng ResponseEntity, mà chúng ta sẽ thảo luận trong một khoảnh khắc.

Chú thích @RequestMapping ở cấp lớp hoạt động với chú thích @GetMapping trên phương thức recentTacos() để chỉ định rằng phương thức recentTacos() chịu trách nhiệm xử lý các yêu cầu GET cho /design?recent.

Bạn sẽ nhận thấy rằng chú thích @RequestMapping cũng đặt một thuộc tính produces. Điều này chỉ định rằng bất kỳ phương thức xử lý nào trong TacoController sẽ xử lý các yêu cầu chỉ khi client gửi yêu cầu với một tiêu đề Accept bao gồm "application/json", chỉ ra rằng client chỉ có thể xử lý response trong định dạng JSON. Việc sử dụng produces giới hạn API của bạn chỉ sản xuất kết quả JSON, và cho phép một controller khác (có thể là TacoController từ chương 2) xử lý các yêu cầu với các đường dẫn giống nhau, miễn là những yêu cầu đó không đòi hỏi đầu ra JSON.

Mặc dù việc đặt produces thành "application/json" hạn chế API của bạn chỉ là dựa trên JSON (điều này phù hợp với nhu cầu của bạn), bạn có thể đặt produces thành một mảng String để nhiều loại nội dung. Ví dụ, để cho phép đầu ra XML, bạn có thể thêm "text/xml" vào thuộc tính produces như sau:
@RequestMapping(path="/api/tacos", produces={"application/json", "text/xml"})
Một điều khác bạn có thể đã nhận thấy trong danh sách 7.1 là lớp được chú thích bằng @CrossOrigin. Thông thường, giao diện người dùng dựa trên JavaScript, chẳng hạn như các ứng dụng được viết trong một framework như Angular hoặc ReactJS, thường được phục vụ từ một máy chủ và/hoặc cổng khác với API (ít nhất là trong tình huống hiện tại), và trình duyệt web sẽ ngăn chặn client của bạn khỏi việc tiêu thụ API. Ràng buộc này có thể được vượt qua bằng cách bao gồm các tiêu đề CORS (chia sẻ nguồn gốc chéo) trong các phản hồi từ máy chủ. Spring giúp bạn dễ dàng áp dụng CORS với chú thích @CrossOrigin.

Trong trường hợp này, @CrossOrigin cho phép client từ localhost, cổng 8080 truy cập API. Tuy nhiên, thuộc tính origins chấp nhận một mảng, vì vậy bạn cũng có thể chỉ định nhiều giá trị, như được thể hiện dưới đây:

@RestController
@RequestMapping(path = "/api/tacos", produces = "application/json")
@CrossOrigin(origins = "http://tacocloud:8080")
public class TacoController {

Logic bên trong phương thức recentTacos() khá đơn giản. Nó tạo ra một đối tượng PageRequest chỉ định rằng bạn chỉ muốn trang đầu tiên (trang 0) của 12 kết quả, được sắp xếp theo thứ tự giảm dần của ngày tạo của taco. Nói một cách đơn giản, bạn muốn mười hai mô hình taco được tạo gần đây nhất. PageRequest được truyền vào cuộc gọi phương thức findAll() của TacoRepository, và nội dung của trang kết quả đó được trả về cho client (như bạn đã thấy trong danh sách 7.1, sẽ được sử dụng làm dữ liệu mô hình để hiển thị cho người dùng).

Bây giờ bạn đã có một phần của API Taco Cloud cho client của mình. Để kiểm thử phát triển, bạn cũng có thể muốn sử dụng các tiện ích dòng lệnh như curl hoặc HTTPie (https://httpie.org/) để kiểm tra API. Ví dụ, dòng lệnh sau cho thấy cách bạn có thể truy xuất các taco được tạo gần đây với curl:

$ curl localhost:8080/api/tacos?recent

Hoặc như thế này, nếu bạn thích sử dụng HTTPie:

$ http :8080/api/tacos?recent

Ban đầu, cơ sở dữ liệu sẽ trống rỗng, nên kết quả từ những yêu cầu này cũng sẽ trống rỗng. Chúng ta sẽ thấy trong một khoảnh khắc làm thế nào để xử lý các yêu cầu POST để lưu trữ các taco. Nhưng trong lúc chờ đợi đó, bạn có thể thêm một CommandLineRunner bean để tải trước cơ sở dữ liệu với một số dữ liệu kiểm thử. Phương thức CommandLineRunner bean sau đây cho thấy cách bạn có thể tải trước một vài nguyên liệu và vài chiếc taco:
@Bean
    CommandLineRunner dataLoader(
            IngredientRepository ingredientRepo, UserRepository userRepo,
            PasswordEncoder encoder, TacoRepository tacoRepo
        ) {
        return args -> {
            Ingredient flourTortilla = new Ingredient(
                "FLTO", "Flour Tortilla", Type.WRAP);   
            Ingredient cornTortilla = new Ingredient(
                "COTO", "Corn Tortilla", Type.WRAP);
            Ingredient groundBeef = new Ingredient(
                "GRBF", "Ground Beef", Type.PROTEIN);
            Ingredient carnitas = new Ingredient(
                "CARN", "Carnitas", Type.PROTEIN);
            Ingredient tomatoes = new Ingredient(
                "TMTO", "Diced Tomatoes", Type.VEGGIES);
            Ingredient lettuce = new Ingredient(
                "LETC", "Lettuce", Type.VEGGIES);
            Ingredient cheddar = new Ingredient(
                "CHED", "Cheddar", Type.CHEESE);
            Ingredient jack = new Ingredient(
                "JACK", "Monterrey Jack", Type.CHEESE);
            Ingredient salsa = new Ingredient(
                "SLSA", "Salsa", Type.SAUCE);
            Ingredient sourCream = new Ingredient(
                "SRCR", "Sour Cream", Type.SAUCE);
            ingredientRepo.save(flourTortilla);
            ingredientRepo.save(cornTortilla);
            ingredientRepo.save(groundBeef);
            ingredientRepo.save(carnitas);
            ingredientRepo.save(tomatoes);
            ingredientRepo.save(lettuce);
            ingredientRepo.save(cheddar);
            ingredientRepo.save(jack);
            ingredientRepo.save(salsa);
            ingredientRepo.save(sourCream);

            Taco taco1 = new Taco();
            taco1.setName("Carnivore");
            taco1.setIngredients(Arrays.asList(
                flourTortilla, groundBeef, carnitas, 
                sourCream, salsa, cheddar));
            tacoRepo.save(taco1);
            
            Taco taco2 = new Taco();
            taco2.setName("Bovine Bounty");
            taco2.setIngredients(Arrays.asList(
                cornTortilla, groundBeef, cheddar, jack, 
                sourCream));
            tacoRepo.save(taco2);
        };
    }

Bây giờ nếu bạn thử sử dụng curl hoặc HTTPie để thực hiện một yêu cầu đến điểm cuối tacos gần đây, bạn sẽ nhận được một phản hồi tương tự như sau (phản hồi được định dạng để dễ đọc):
$ curl localhost:8080/api/tacos?recent

[
{
"id": 4,
"name": "Veg-Out",
"createdAt": "2021-08-02T00:47:09.624+00:00",
"ingredients": [
{ "id": "FLTO", "name": "Flour Tortilla", "type": "WRAP" },
{ "id": "COTO", "name": "Corn Tortilla", "type": "WRAP" },
{ "id": "TMTO", "name": "Diced Tomatoes", "type": "VEGGIES" },
{ "id": "LETC", "name": "Lettuce", "type": "VEGGIES" },
{ "id": "SLSA", "name": "Salsa", "type": "SAUCE" }
]
},
{
"id": 3,
"name": "Bovine Bounty",
"createdAt": "2021-08-02T00:47:09.621+00:00",
"ingredients": [
{ "id": "COTO", "name": "Corn Tortilla", "type": "WRAP" },
{ "id": "GRBF", "name": "Ground Beef", "type": "PROTEIN" },
{ "id": "CHED", "name": "Cheddar", "type": "CHEESE" },
{ "id": "JACK", "name": "Monterrey Jack", "type": "CHEESE" },
{ "id": "SRCR", "name": "Sour Cream", "type": "SAUCE" }
]
},
{
"id": 2,
"name": "Carnivore",
"createdAt": "2021-08-02T00:47:09.520+00:00",
"ingredients": [
{ "id": "FLTO", "name": "Flour Tortilla", "type": "WRAP" },
{ "id": "GRBF", "name": "Ground Beef", "type": "PROTEIN" },
{ "id": "CARN", "name": "Carnitas", "type": "PROTEIN" },
{ "id": "SRCR", "name": "Sour Cream", "type": "SAUCE" },
{ "id": "SLSA", "name": "Salsa", "type": "SAUCE" },
{ "id": "CHED", "name": "Cheddar", "type": "CHEESE" }
]
}
]

Bây giờ, giả sử bạn muốn cung cấp một end point để truy xuất một taco duy nhất thông qua ID của nó. Bằng cách sử dụng một biến đặt chỗ trong đường dẫn của phương thức xử lý và chấp nhận một path variable, bạn có thể bắt giữ ID và sử dụng nó để tìm kiếm đối tượng Taco thông qua repository như sau:

@GetMapping("/{id}")
public Optional<Taco> tacoById(@PathVariable("id") Long id) {
    return tacoRepo.findById(id);
}

Vì đường dẫn cơ bản của bộ điều khiển là /api/tacos, phương thức điều khiển này xử lý các yêu cầu GET cho /api/tacos/{id}, trong đó phần {id} của đường dẫn là một biến đặt chỗ. Giá trị thực tế trong yêu cầu được đưa cho tham số id, được ánh xạ với biến đặt chỗ {id} thông qua @PathVariable.

Bên trong phương thức tacoById(), tham số id được chuyển vào phương thức findById() của repository để lấy thông tin về Taco. Phương thức findById() của repository trả về một Optional <Taco>, vì có thể có trường hợp không có taco nào phù hợp với ID đã cho. Optional <Taco> được trả về trực tiếp từ phương thức của bộ điều khiển.

Sau đó, Spring lấy Optional <Taco> và gọi phương thức get() của nó để tạo ra phản hồi. Nếu ID không khớp với bất kỳ taco đã biết nào, cơ thể phản hồi sẽ chứa "null" và mã trạng thái HTTP của phản hồi sẽ là 200 (OK). Khách hàng sẽ nhận được một phản hồi mà nó không thể sử dụng, nhưng mã trạng thái chỉ ra mọi thứ đều ổn. Một cách tiếp cận tốt hơn là trả về một phản hồi với mã trạng thái HTTP 404 (NOT FOUND).

Hiện tại, không có cách dễ dàng để trả về mã trạng thái 404 từ tacoById(). Nhưng nếu bạn thực hiện một số điều chỉnh nhỏ, bạn có thể đặt mã trạng thái một cách thích hợp, như được thể hiện ở đây:

@GetMapping("/{id}")
public ResponseEntity<Taco> tacoById(@PathVariable("id") Long id) {
Optional<Taco> optTaco = tacoRepo.findById(id);
if(optTaco.isPresent()) {
     return new ResponseEntity<>(optTaco.get(), HttpStatus.OK);
}
return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
}
Bây giờ, thay vì trả về một đối tượng Taco, tacoById() trả về một ResponseEntity<Taco>. Nếu taco được tìm thấy, bạn bọc đối tượng Taco trong một ResponseEntity với mã trạng thái HTTP là OK (giống như trước đó). Nhưng nếu taco không được tìm thấy, bạn bọc một null trong một ResponseEntity cùng với một mã trạng thái HTTP là NOT FOUND để chỉ ra rằng client đang cố gắng truy xuất một taco không tồn tại.

Định nghĩa một end point trả thông tin chỉ là bắt đầu. Nếu API của bạn cần nhận dữ liệu từ client, hãy xem làm thế nào bạn có thể viết các phương thức controller xử lý dữ liệu đầu vào từ các yêu cầu.

7.1.2 Sending data to the server

Cho đến nay, API của bạn có thể trả về đến một tá mười hai taco được tạo gần đây nhất. Nhưng làm thế nào những taco đó được tạo ra ban đầu?

Mặc dù bạn có thể sử dụng một CommandLineRunner bean để nạp trước cơ sở dữ liệu với một số dữ liệu taco thử nghiệm, nhưng cuối cùng dữ liệu taco sẽ đến từ người dùng khi họ tạo ra những chiếc taco của họ. Do đó, chúng ta sẽ cần viết một phương thức trong TacoController để xử lý các yêu cầu chứa các thiết kế taco và lưu chúng vào cơ sở dữ liệu. Bằng cách thêm phương thức postTaco() sau vào TacoController, bạn cho phép bộ điều khiển thực hiện chính xác điều đó:

@PostMapping(consumes = "application/json")
@ResponseStatus(HttpStatus.CREATED)
public Taco postTaco(@RequestBody Taco taco) {
    return tacoRepo.save(taco);
}

Vì postTaco() sẽ xử lý một yêu cầu HTTP POST, nó được chú thích bằng @PostMapping thay vì @GetMapping. Bạn không đang chỉ định một thuộc tính path ở đây, vì vậy phương thức postTaco() sẽ xử lý các yêu cầu cho /api/tacos như đã được chỉ định ở cấp độ class trong @RequestMapping trên TacoController.

Tuy nhiên, bạn đã đặt thuộc tính consumes. Thuộc tính consumes được sử dụng để yêu cầu đầu vào, tương tự như produces được sử dụng để yêu cầu đầu ra. Ở đây, bạn sử dụng consumes để chỉ định rằng phương thức chỉ sẽ xử lý các yêu cầu mà Content-type tương ứng với application/json.

Tham số Taco của phương thức được chú thích với @RequestBody để chỉ định rằng nội dung của yêu cầu sẽ được chuyển đổi thành một đối tượng Taco và được gắn liền với tham số. Chú thích này quan trọng nếu thiếu nó, Spring MVC sẽ giả định rằng bạn muốn các request parameters (hoặc là các tham số truy vấn hoặc là các tham số biểu mẫu) được gắn liền với đối tượng Taco. Nhưng chú thích @RequestBody đảm bảo rằng JSON trong phần request body sẽ được gắn liền với đối tượng Taco.

Sau khi postTaco() nhận được đối tượng Taco, nó chuyển nó đến phương thức save() trên TacoRepository.

Bạn cũng có thể đã nhận thấy rằng tôi đã chú thích phương thức postTaco() bằng @ResponseStatus(HttpStatus.CREATED). Dưới điều kiện bình thường (khi không có ngoại lệ nào được ném), tất cả các phản hồi sẽ có mã trạng thái HTTP là 200 (OK), chỉ ra rằng yêu cầu đã thành công. Mặc dù một phản hồi HTTP 200 luôn được chào đón, nhưng đôi khi nó không đủ mô tả. Trong trường hợp yêu cầu POST, mã trạng thái HTTP là 201 (CREATED) mô tả rõ hơn. Nó cho biết cho khách hàng rằng không chỉ yêu cầu thành công mà còn có một tài nguyên được tạo ra là kết quả. Luôn luôn là một ý tưởng tốt sử dụng @ResponseStatus khi thích hợp để truyền đạt mã trạng thái HTTP mô tả và chính xác nhất đến khách hàng.

Mặc dù bạn đã sử dụng @PostMapping để tạo một tài nguyên Taco mới, các yêu cầu POST cũng có thể được sử dụng để cập nhật tài nguyên. Tuy nhiên, thông thường, yêu cầu POST được sử dụng cho việc tạo tài nguyên, và các yêu cầu PUT và PATCH được sử dụng để cập nhật tài nguyên. Hãy xem làm thế nào bạn có thể cập nhật dữ liệu bằng cách sử dụng @PutMapping và @PatchMapping.

7.1.3 Updating data on the server

Trước khi bạn viết bất kỳ mã điều khiển nào để xử lý các lệnh HTTP PUT hoặc PATCH, bạn nên dành một khoảnh khắc để xem xét vấn đề lớn: tại sao có hai phương thức HTTP khác nhau để cập nhật tài nguyên?

Mặc dù đúng là PUT thường được sử dụng để cập nhật dữ liệu tài nguyên, nhưng thực sự nó là ngược của GET về mặt ngữ nghĩa. Trong khi yêu cầu GET được sử dụng để chuyển dữ liệu từ máy chủ đến máy khách, yêu cầu PUT được sử dụng để gửi dữ liệu từ máy khách đến máy chủ.

Theo cách đó, PUT thực sự được thiết kế để thực hiện một hoạt động thay thế toàn bộ thay vì một hoạt động cập nhật. Ngược lại, mục đích của HTTP PATCH là thực hiện một bản vá hoặc cập nhật một phần dữ liệu tài nguyên.

Ví dụ, giả sử bạn muốn có khả năng thay đổi địa chỉ trên một đơn đặt hàng. Một cách chúng ta có thể đạt được điều này thông qua REST API là sử dụng một yêu cầu PUT được xử lý như sau:

@PutMapping(path = "/{orderId}", consumes = "application/json")
   public TacoOrder putOrder(@PathVariable("orderId") Long orderId,
       @RequestBody TacoOrder order) {
       order.setId(orderId);
       return orderRepo.save(order);
} 


Điều này có thể hoạt động, nhưng nó sẽ đòi hỏi client phải gửi toàn bộ dữ liệu đơn hàng trong yêu cầu PUT. Ngữ nghĩa của PUT là "đặt dữ liệu này tại URL này," về cơ bản là thay thế bất kỳ dữ liệu nào đang ở đó. Nếu bất kỳ thuộc tính nào của đơn hàng bị bỏ sót, giá trị của thuộc tính đó sẽ bị ghi đè bằng null. Thậm chí cả các taco trong đơn hàng cũng cần được đặt cùng với dữ liệu đơn hàng, nếu không chúng sẽ bị xóa khỏi đơn hàng.

Nếu PUT thực hiện một việc thay thế toàn bộ dữ liệu tài nguyên, thì làm thế nào bạn nên xử lý yêu cầu chỉ để cập nhật một phần? Đó là điều mà các yêu cầu HTTP PATCH và @PatchMapping của Spring phù hợp. Dưới đây là cách bạn có thể viết một phương thức controller để xử lý một yêu cầu PATCH cho một đơn hàng:

@PatchMapping(path = "/{orderId}", consumes = "application/json")
    public TacoOrder pathOrder(@PathVariable("orderId") Long orderId, @RequestBody TacoOrder patch) {
        TacoOrder order = orderRepo.findById(orderId).get();
        if (patch.getDeliveryName() != null) {
            order.setDeliveryName(patch.getDeliveryName());
        }
        if (patch.getDeliveryStreet() != null) {
            order.setDeliveryStreet(patch.getDeliveryStreet());
        }
        if (patch.getDeliveryCity() != null) {
            order.setDeliveryCity(patch.getDeliveryCity());
        }
        if (patch.getDeliveryState() != null) {
            order.setDeliveryState(patch.getDeliveryState());
        }
        if (patch.getDeliveryZip() != null) {
            order.setDeliveryZip(patch.getDeliveryZip());
        }
        if (patch.getCcNumber() != null) {
            order.setCcNumber(patch.getCcNumber());
        }
        if (patch.getCcExpiration() != null) {
            order.setCcExpiration(patch.getCcExpiration());
        }
        if (patch.getCcCVV() != null) {
            order.setCcCVV(patch.getCcCVV());
        }
        return orderRepo.save(order);
    }

Điều quan trọng cần lưu ý ở đây là phương thức patchOrder() được chú thích với @PatchMapping thay vì @PutMapping, chỉ định rằng nó sẽ xử lý các yêu cầu HTTP PATCH thay vì PUT.

Nhưng điều duy nhất bạn chắc chắn đã chú ý là phương thức patchOrder() phức tạp hơn một chút so với phương thức putOrder(). Điều này là do các chú thích ánh xạ của Spring MVC, bao gồm @PatchMapping và @PutMapping, chỉ định loại yêu cầu mà một phương thức nên xử lý. Các chú thích này không quyết định cách mà yêu cầu sẽ được xử lý. Mặc dù PATCH ngữ nghĩa là một cập nhật một phần, nhưng đến bạn để viết mã trong phương thức xử lý thực sự thực hiện cập nhật đó.

Trong trường hợp của phương thức putOrder(), bạn đã chấp nhận toàn bộ dữ liệu cho một đơn hàng và lưu nó, tuân thủ ngữ nghĩa của HTTP PUT. Nhưng để phương thức patchMapping() tuân thủ ngữ nghĩa của HTTP PATCH, phần thân của phương thức yêu cầu sự thông minh hơn. Thay vì hoàn toàn thay thế đơn hàng bằng dữ liệu mới được gửi vào, nó kiểm tra từng trường của đối tượng TacoOrder đầu vào và áp dụng bất kỳ giá trị không phải null nào cho đơn hàng hiện tại. Tiếp cận này cho phép client chỉ gửi các thuộc tính mà nên được thay đổi và cho phép máy chủ giữ lại dữ liệu hiện tại cho bất kỳ thuộc tính nào không được chỉ định bởi client.

Có nhiều cách để PATCH
Phương pháp patching được áp dụng trong phương thức patchOrder() có những hạn chế sau đây:
- Nếu giá trị null được sử dụng để chỉ định không có thay đổi, làm thế nào client có thể biểu thị rằng một trường nên được đặt thành null?
- Không có cách nào để xóa hoặc thêm một tập hợp con các mục từ một bộ sưu tập. Nếu client muốn thêm hoặc xóa một mục từ một bộ sưu tập, nó phải gửi toàn bộ bộ sưu tập đã được thay đổi.

Thực sự không có quy tắc cứng nhắc về cách xử lý PATCH requests hoặc dữ liệu đầu vào nên trông như thế nào. Thay vì gửi dữ liệu miền thực tế, client có thể gửi mô tả cụ thể về các thay đổi cần áp dụng. Tất nhiên, bộ xử lý yêu cầu sẽ phải được viết để xử lý các chỉ thị patch thay vì dữ liệu miền.

Cả trong @PutMapping và @PatchMapping, hãy lưu ý rằng đường dẫn yêu cầu đề cập đến tài nguyên sẽ được thay đổi. Điều này giống như cách các phương thức được chú thích bằng @GetMapping xử lý đường dẫn.

Bạn đã thấy cách lấy và gửi tài nguyên với @GetMapping và @PostMapping. Và bạn đã thấy hai cách khác nhau để cập nhật một tài nguyên với @PutMapping và @PatchMapping. Tất cả những gì còn lại là xử lý các yêu cầu để xóa một tài nguyên. 

7.1.4 Deleting data from the server 

Đôi khi, dữ liệu đơn giản không còn cần thiết nữa. Trong những trường hợp đó, một client nên có khả năng yêu cầu xóa một tài nguyên bằng yêu cầu HTTP DELETE. Chú thích @DeleteMapping của Spring MVC rất hữu ích để khai báo các phương thức xử lý các yêu cầu DELETE. Ví dụ, giả sử bạn muốn API của mình cho phép xóa một tài nguyên đơn đặt hàng. Phương thức controller sau đây sẽ giải quyết công việc:

@DeleteMapping(path = "/{orderId}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteOrder(@PathVariable("orderId") Long id) {
    try {
        orderRepo.deleteById(id);
    } catch (EmptyResultDataAccessException e) {}
}

Tới thời điểm này, khái niệm về một chú thích ánh xạ khác nên đã quen thuộc với bạn. Bạn đã thấy @GetMapping, @PostMapping, @PutMapping và @PatchMapping — mỗi cái chỉ định rằng một phương thức sẽ xử lý yêu cầu cho các phương thức HTTP tương ứng của chúng. Chắc chắn rằng việc sử dụng @DeleteMapping để chỉ định rằng phương thức deleteOrder() chịu trách nhiệm xử lý yêu cầu DELETE cho /orders/{orderId} sẽ không làm bạn ngạc nhiên.

Đoạn mã bên trong phương thức là cái thực sự thực hiện công việc xóa đơn hàng. Trong trường hợp này, nó nhận ID đơn hàng, được cung cấp dưới dạng biến đường dẫn trong URL, và chuyển nó đến phương thức deleteById() của repository. Nếu đơn hàng tồn tại khi phương thức đó được gọi, nó sẽ bị xóa. Nếu đơn hàng không tồn tại, một EmptyResultDataAccessException sẽ được ném ra.

Tôi đã chọn bắt EmptyResultDataAccessException và không làm gì cả với nó. Ý tưởng ở đây là nếu bạn cố gắng xóa một nguồn tài nguyên không tồn tại, kết quả sẽ giống như nếu nó tồn tại trước khi bị xóa — nghĩa là, nguồn tài nguyên sẽ không tồn tại. Việc nó có tồn tại trước đó không quan trọng. Hoặc ngược lại, tôi có thể đã viết deleteOrder() để trả về một ResponseEntity, thiết lập body là null và mã trạng thái HTTP là NOT FOUND.

Điều duy nhất cần lưu ý trong phương thức deleteOrder() là nó được chú thích bằng @ResponseStatus để đảm bảo rằng mã trạng thái HTTP của phản hồi là 204 (NO CONTENT). Không cần phải truyền thông tin nguồn tài nguyên nào đó lại cho client khi nguồn tài nguyên đó không còn tồn tại, vì vậy phản hồi cho các yêu cầu DELETE thường không có body và do đó, nên truyền mã trạng thái HTTP để thông báo cho client biết không cần mong đợi bất kỳ nội dung nào.

API của Taco Cloud của bạn đang bắt đầu hình thành. Bây giờ, một client có thể được viết để tiêu thụ API này, hiển thị nguyên liệu, chấp nhận đơn hàng và hiển thị các taco được tạo gần đây. Chúng ta sẽ thảo luận về việc viết mã client REST một chút sau trong phần 7.3. Nhưng trước tiên, hãy xem cách tạo các điểm cuối API REST khác: tự động dựa trên các repository Spring Data.

7.2 Enabling data-backed services

Như bạn đã thấy trong chương 3, Spring Data thực hiện một loại ma thuật đặc biệt bằng cách tự động tạo ra các triển khai repository dựa trên các giao diện bạn định nghĩa trong mã nguồn của mình. Nhưng Spring Data còn một mẹo khác có thể giúp bạn định nghĩa API cho ứng dụng của bạn.

Spring Data REST là một thành viên khác trong họ Spring Data, tự động tạo ra các API REST cho các repository được tạo bởi Spring Data. Chỉ cần thêm Spring Data REST vào dự án của bạn, bạn sẽ có một API với các hoạt động cho mỗi giao diện repository bạn đã định nghĩa.

Để bắt đầu sử dụng Spring Data REST, thêm dependency sau vào dự án của bạn:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>


Có tin hay không, chỉ cần có Spring Data REST starter trong dự án đã sử dụng Spring Data cho các repository tự động là đủ để mở một REST API. Bằng cách đơn giản là bao gồm Spring Data REST starter trong build, ứng dụng tự động được cấu hình để tạo ra tự động một REST API cho bất kỳ repository nào đã được tạo bởi Spring Data (bao gồm cả Spring Data JPA, Spring Data Mongo, và cũng có thể là các loại khác).

Các end point REST mà Spring Data REST tạo ra ít nhất cũng tốt như (và có thể thậm chí là tốt hơn) những end point mà bạn tự tạo ra. Vì vậy, tại điểm này, hãy thoải mái thực hiện một số công việc phá hủy và loại bỏ bất kỳ lớp nào được chú thích bằng @RestController mà bạn đã tạo ra cho đến bây giờ trước khi tiếp tục.

Để thử các điểm cuối được cung cấp bởi Spring Data REST, bạn có thể khởi động ứng dụng và bắt đầu kiểm tra một số URL. Dựa trên bộ repository bạn đã định nghĩa cho Taco Cloud, bạn nên có thể thực hiện các yêu cầu GET cho tacos, ingredients, orders, và users.

Ví dụ, bạn có thể lấy danh sách tất cả các nguyên liệu bằng cách thực hiện yêu cầu GET cho /ingredients. Sử dụng curl, bạn có thể nhìn thấy một cái gì đó giống như thế này (đã được rút gọn để chỉ hiển thị nguyên liệu đầu tiên):

$ curl localhost:8080/ingredients
{
"_embedded" : {
"ingredients" : [ {
"name" : "Flour Tortilla",
"type" : "WRAP",
"_links" : {
"self" : {
"href" : "http://localhost:8080/ingredients/FLTO"
},
"ingredient" : {
"href" : "http://localhost:8080/ingredients/FLTO"
}
}
},
...
]
},
"_links" : {
"self" : {
"href" : "http://localhost:8080/ingredients"
},
"profile" : {
"href" : "http://localhost:8080/profile/ingredients"
}
}
}

Wow! Chỉ cần thêm một phụ thuộc vào dự án, bạn không chỉ có được một end point cho ingredients mà còn nhận được các nguồn dữ liệu trả về cũng chứa các liên kết siêu văn bản! Các liên kết siêu văn bản này là các hiện thực của Hypermedia như Engine of Application State, hoặc viết tắt là HATEOAS. Một client tiêu thụ API này có thể (tùy chọn) sử dụng các liên kết siêu văn bản này như một hướng dẫn để điều hướng qua API và thực hiện yêu cầu tiếp theo.

Dự án Spring HATEOAS (https://spring.io/projects/spring-hateoas) cung cấp hỗ trợ tổng quát để thêm các liên kết siêu văn bản trong các phản hồi của Spring MVC controller. Nhưng Spring Data REST tự động thêm các liên kết này vào các phản hồi của nó đối với các API được tạo ra.

To HATEOAS or not to HATEOAS?
Ý tưởng chung của HATEOAS là nó cho phép một client điều hướng qua một API giống như cách mà một người có thể điều hướng trên một trang web: bằng cách theo dõi các liên kết. Thay vì mã hóa chi tiết API trong một client và yêu cầu client xây dựng URL cho mỗi yêu cầu, client có thể chọn một liên kết, theo tên, từ danh sách các liên kết siêu văn bản và sử dụng nó để thực hiện yêu cầu tiếp theo. Điều này giúp client không cần phải được mã hóa để biết cấu trúc của một API và thay vào đó có thể sử dụng chính API làm bản đồ đường dẫn thông qua API.

Tuy nhiên, các liên kết siêu văn bản thêm một lượng dữ liệu nhỏ vào payload và tăng thêm một số phức tạp yêu cầu client biết cách điều hướng bằng cách sử dụng các liên kết siêu văn bản đó. Vì lý do này, những người phát triển API thường bỏ qua việc sử dụng HATEOAS, và những người phát triển client thường đơn giản là bỏ qua các liên kết siêu văn bản nếu có trong một API.
Ngoại trừ các liên kết siêu văn bản miễn phí bạn nhận được từ các phản hồi của Spring Data REST, chúng ta sẽ bỏ qua HATEOAS và tập trung vào API đơn giản không sử dụng siêu văn bản.

Giả vờ như là một client của API này, bạn cũng có thể sử dụng curl để theo dõi liên kết tự thân (self link) cho mục the flour tortilla như sau:

{
  "name" : "Flour Tortilla",
  "type" : "WRAP",
  "createdAt" : "2023-11-17T08:45:02.511+00:00",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/ingredients/FLTO"
    },
    "ingredient" : {
      "href" : "http://localhost:8080/ingredients/FLTO"
    }
  }
}


Để tránh bị phân tâm quá nhiều, chúng ta sẽ không dành quá nhiều thời gian trong cuốn sách này để khai thác từng endpoint và tùy chọn mà Spring Data REST đã tạo ra. Nhưng bạn nên biết rằng nó cũng hỗ trợ các phương thức POST, PUT và DELETE cho các endpoint mà nó tạo ra. Đúng vậy: bạn có thể POST tới /ingredients để tạo một thành phần mới và DELETE /ingredients/FLTO để xóa bỏ bánh tortilla bột từ menu.

Một điều bạn có thể muốn làm là đặt một base path cho API để các endpoint của nó là riêng biệt và không xung đột với bất kỳ bộ controller nào bạn viết. Để điều chỉnh base path cho API, đặt thuộc tính spring.data.rest.base-path như được hiển thị dưới đây:

spring:
    data:
       rest:
         base-path: /data-api  

Điều này đặt base path cho các end point Spring Data REST thành /data-api. Mặc dù bạn có thể đặt base path thành bất cứ điều gì bạn muốn, việc chọn /data-api đảm bảo rằng các end point được tiết lộ bởi Spring Data REST không xung đột với bất kỳ controller nào khác, bao gồm cả những controller mà đường dẫn bắt đầu bằng "/api" mà chúng ta đã tạo ở đầu chương này.

Do đó, end point của ingredients giờ đây là /data-api/ingredients. Hãy thử nghiệm đường dẫn cơ bản mới này bằng cách yêu cầu một danh sách tacos như sau:
$ curl http://localhost:8080/data-api/tacos
{
  "timestamp": "2018-02-11T16:22:12.381+0000",
  "status": 404,
  "error": "Not Found",
  "message": "No message available",
  "path": "/api/tacos"
}
Ôi chao! Điều này không hoạt động đúng như mong đợi. Bạn có một thực thể Ingredient và một giao diện IngredientRepository, mà Spring Data REST đã tiết lộ với một điểm cuối /data-api/ingredients. Vì vậy, nếu bạn có một thực thể Taco và một giao diện TacoRepository, tại sao Spring Data REST không cung cấp cho bạn một điểm cuối /data-api/tacos?

7.2.1 Adjusting resource paths and relation names

Thực sự, Spring Data REST thực sự cung cấp cho bạn một điểm cuối để làm việc với tacos. Nhưng mặc dù Spring Data REST có thể thông minh, nhưng nó chỉ là một chút kém phần ấn tượng trong cách nó tiết lộ điểm cuối tacos.

Khi tạo điểm cuối cho các kho Spring Data, Spring Data REST cố gắng làm cho tên lớp thực thể liên quan thành số nhiều. Đối với thực thể Ingredient, điểm cuối là /data-api/ingredients. Đối với thực thể TacoOrder, nó là /data-api/orders. Đến đây, vẫn ổn.

Nhưng đôi khi, như với "taco," nó phạm phải một từ và phiên bản số nhiều của nó không chính xác. Như nó quyết định, Spring Data REST đã làm số nhiều từ "taco" thành "tacoes," vì vậy để yêu cầu tacos, bạn phải tuân theo và yêu cầu /data-api/tacoes, như được hiển thị dưới đây:

$ curl localhost:8080/data-api/tacoes
{
"_embedded" : {
"tacoes" : [ {
"name" : "Carnivore",
"createdAt" : "2018-02-11T17:01:32.999+0000",
"_links" : {
"self" : {
"href" : "http://localhost:8080/data-api/tacoes/2"
},
….


Bạn có thể đang tự hỏi làm thế nào tôi biết rằng "taco" sẽ được biến đổi sai thành "tacoes". Như nói trước đó, Spring Data REST cũng mở ra một nguồn thông tin chính là nguồn gốc (home resource), hiển thị các liên kết cho tất cả các điểm cuối được mở ra. Chỉ cần thực hiện một yêu cầu GET đến đường dẫn cơ sở của API để nhận thông tin như sau:
http://localhost:8080/data-api

{
  "_links" : {
    "ingredients" : {
      "href" : "http://localhost:8080/data-api/ingredients{?page,size,sort}",
      "templated" : true
    },
    "users" : {
      "href" : "http://localhost:8080/data-api/users{?page,size,sort}",
      "templated" : true
    },
    "tacoOrders" : {
      "href" : "http://localhost:8080/data-api/tacoOrders{?page,size,sort}",
      "templated" : true
    },
    "tacoes" : {
      "href" : "http://localhost:8080/data-api/tacoes{?page,size,sort}",
      "templated" : true
    },
    "profile" : {
      "href" : "http://localhost:8080/data-api/profile"
    }
  }
}

Như bạn có thể thấy, nguồn thông tin chính hiển thị các liên kết cho tất cả các thực thể của bạn. Mọi thứ trông khá tốt, trừ cho liên kết "tacoes", nơi cả tên mối quan hệ và URL đều có sự biến đổi số ít kỳ quặc của từ "taco".

Thông tin tích cực là bạn không cần phải chấp nhận chi tiết nhỏ này của Spring Data REST. Bằng cách thêm chú thích đơn giản sau vào lớp Taco, bạn có thể điều chỉnh cả tên mối quan hệ và đường dẫn đó:



@Data
@Entity
@Table(name = "TACO")
@RestResource(rel = "tacos", path = "tacos")
public class Taco {

Chú thích @RestResource cho phép bạn đặt bất kỳ tên mối quan hệ và đường dẫn nào cho thực thể theo ý muốn của bạn. Trong trường hợp này, bạn đang đặt cả hai chúng là "tacos". Bây giờ khi bạn yêu cầu nguồn thông tin chính, bạn sẽ thấy liên kết tacos với việc biến đổi số nhiều đúng, như sau:

{
  "_links" : {
    "tacos" : {
      "href" : "http://localhost:8080/data-api/tacos{?page,size,sort}",
      "templated" : true
    },

Điều này cũng giải quyết vấn đề đường dẫn cho end point để bạn có thể gửi các yêu cầu đến /data-api/tacos để làm việc với các nguồn lực taco.

Nói về việc sắp xếp mọi thứ, hãy xem cách bạn có thể sắp xếp kết quả từ các end point Spring Data REST.

7.2.2 Paging and sorting

Bạn có thể đã nhận thấy rằng các liên kết trong nguồn thông tin chính đều cung cấp các tham số tùy chọn page, size và sort. Mặc định, các yêu cầu đối với một nguồn tài nguyên bộ sưu tập như /data-api/tacos sẽ trả về tối đa 20 mục mỗi trang từ trang đầu tiên. Nhưng bạn có thể điều chỉnh kích thước trang và trang hiển thị bằng cách chỉ định các tham số page và size trong yêu cầu của bạn.

Ví dụ, để yêu cầu trang đầu tiên của các tacos với kích thước trang là 5, bạn có thể thực hiện yêu cầu GET sau đây (sử dụng curl):
```bash
$ curl "localhost:8080/data-api/tacos?size=5"
```

Giả sử có nhiều hơn năm tacos để xem, bạn có thể yêu cầu trang thứ hai của tacos bằng cách thêm tham số page như sau:
```bash
$ curl "localhost:8080/data-api/tacos?size=5&page=1"
```

Lưu ý rằng tham số page được đánh chỉ số từ 0, điều này có nghĩa là yêu cầu trang 1 thực sự đang yêu cầu trang thứ hai. (Bạn cũng sẽ nhận thấy rằng nhiều shell dòng lệnh bị nhầm lẫn với dấu và trong yêu cầu, đó là lý do tôi đã đặt dấu ngoặc kép cho toàn bộ URL trong lệnh curl trước đó.)

Tham số sort cho phép bạn sắp xếp danh sách kết quả theo bất kỳ thuộc tính nào của thực thể. Ví dụ, bạn cần một cách để lấy 12 tacos được tạo gần đây nhất để hiển thị trên giao diện người dùng. Bạn có thể làm điều đó bằng cách chỉ định sự kết hợp sau của các tham số phân trang và sắp xếp:
```bash
$ curl "localhost:8080/data-api/tacos?sort=createdAt,desc&page=0&size=12"
```

Ở đây, tham số sort chỉ định rằng bạn nên sắp xếp theo thuộc tính createdDate và nó nên được sắp xếp theo thứ tự giảm dần (để tacos mới nhất đứng đầu). Các tham số page và size chỉ định rằng bạn nên xem trang đầu tiên của 12 tacos.

Điều này chính xác như gì UI cần để hiển thị những tacos được tạo gần đây nhất. Điều này tương tự như /api/tacos?recent endpoint bạn đã định nghĩa trong TacoController ở đầu chương trình này.

Bây giờ hãy chuyển sang cách viết mã client để tiêu thụ các điểm cuối API chúng ta đã tạo.

7.3 Consuming REST services

Bạn đã bao giờ đến xem phim và khi bắt đầu, bạn phát hiện ra rằng bạn là người duy nhất trong rạp chứ? Đó thực sự là một trải nghiệm tuyệt vời khi có thể xem một bộ phim như là một buổi xem riêng tư. Bạn có thể chọn bất kỳ ghế nào bạn muốn, nói chuyện với các nhân vật trên màn hình, và có thể thậm chí mở điện thoại và tweet mà không ai phải tức giận vì làm phiền trải nghiệm xem phim của họ. Và phần tốt nhất là không có ai khác ở đó làm hỏng bộ phim cho bạn cả!
Điều này không xảy ra với tôi thường xuyên. Nhưng khi xảy ra, tôi đã tự hỏi điều gì sẽ xảy ra nếu tôi không xuất hiện. Liệu họ có vẫn chiếu bộ phim không? Liệu anh hùng có cứu được ngày không? Liệu nhân viên rạp có vẫn lau dọn rạp sau khi bộ phim kết thúc không?
Một bộ phim mà không có khán giả giống như một API mà không có client. Nó đã sẵn sàng chấp nhận và cung cấp dữ liệu, nhưng nếu API không được kích hoạt bao giờ, nó có phải là một API không? Giống như con mèo Schrödinger, chúng ta không thể biết liệu API có hoạt động hay trả về các phản hồi HTTP 404 cho đến khi chúng ta đưa ra một yêu cầu đối với nó.

Không hiếm khi các ứng dụng Spring vừa cung cấp một API và thực hiện các yêu cầu đối với API của ứng dụng khác. Trong thực tế, điều này trở nên phổ biến trong thế giới của các dịch vụ nhỏ. Do đó, đáng giá một chút thời gian để xem xét cách sử dụng Spring để tương tác với REST API.

Một ứng dụng Spring có thể tiêu thụ một REST API bằng cách sử dụng:
- RestTemplate: Một client REST đơn giản và đồng bộ được cung cấp bởi Spring Framework.
- Traverson: Một bọc xung quanh RestTemplate của Spring HATEOAS, để tạo ra một client REST đồng bộ nhận biết siêu liên kết. Được lấy cảm hứng từ một thư viện JavaScript cùng tên.
- WebClient: Một client REST reactive và bất đồng bộ.

Hiện tại, chúng ta sẽ tập trung vào việc tạo client với RestTemplate. Chúng tôi sẽ để lại thảo luận về WebClient cho đến khi chúng ta đề cập đến framework web reactive của Spring trong chương 12. Nếu bạn quan tâm đến việc viết client nhận biết siêu liên kết, hãy xem tài liệu Traverson tại http://mng.bz/aZno.
Việc tương tác với một nguồn tài nguyên REST từ phía client, nơi công việc thường xuyên là nhàm chán và đầy đủ mã nguồn mẫu. Cụ thể, việc làm việc với các thư viện HTTP cấp thấp đòi hỏi client phải thực hiện nhiều công việc trùng lặp và mã nguồn mẫu để thực hiện các yêu cầu HTTP cơ bản. RestTemplate được giới thiệu như là một giải pháp để giảm bớt những công việc này, giúp giảm độ phức tạp và nhàm chán trong quá trình tương tác với nguồn tài nguyên REST

RestTemplate cung cấp 41 phương thức để tương tác với nguồn tài nguyên REST. Thay vì xem xét tất cả các phương thức mà nó cung cấp, thì việc chỉ xem xét một tá động tác duy nhất, mỗi cái đều được quá tải để bằng với bộ sưu tập đầy đủ 41 phương thức, là dễ dàng hơn. Có 12 động tác được mô tả trong bảng 7.2.

Dưới đây là giải thích ngắn gọn cho mỗi phương thức RestTemplate:

1. **`delete(…)`**: Thực hiện một yêu cầu HTTP DELETE đối với một nguồn tài nguyên tại một URL cụ thể.

2. **`exchange(…)`**: Thực thi một phương thức HTTP cụ thể đối với một URL, trả về một ResponseEntity chứa một đối tượng được ánh xạ từ phần thân của phản hồi.

3. **`execute(…)`**: Thực thi một phương thức HTTP cụ thể đối với một URL, trả về một đối tượng được ánh xạ từ response body.

4. **`getForEntity(…)`**: Gửi một yêu cầu HTTP GET, trả về một ResponseEntity chứa một đối tượng được ánh xạ từ response body.

5. **`getForObject(…)`**: Gửi một yêu cầu HTTP GET, trả về một đối tượng được ánh xạ từ response body.

6. **`headForHeaders(…)`**: Gửi một yêu cầu HTTP HEAD, trả về các HTTP Headers cho URL nguồn tài nguyên cụ thể.

7. **`optionsForAllow(…)`**: Gửi một yêu cầu HTTP OPTIONS, trả về Allow Header cho URL cụ thể.

8. **`patchForObject(…)`**: Gửi một yêu cầu HTTP PATCH, trả về đối tượng kết quả được ánh xạ từ response body.

9. **`postForEntity(…)`**: Gửi dữ liệu bằng phương thức POST đến một URL, trả về một ResponseEntity chứa một đối tượng được ánh xạ từ response body.

10. **`postForLocation(…)`**: Gửi dữ liệu bằng phương thức POST đến một URL, trả về URL của nguồn tài nguyên mới được tạo.

11. **`postForObject(…)`**: Gửi dữ liệu bằng phương thức POST đến một URL, trả về một đối tượng được ánh xạ từ response body.

12. **`put(…)`**: Gửi dữ liệu tài nguyên bằng phương thức PUT đến URL cụ thể.

Ngoại trừ TRACE, RestTemplate có ít nhất một phương thức cho mỗi trong các phương thức HTTP tiêu chuẩn. Ngoài ra, execute() và exchange() cung cấp các phương thức tổng quát cấp thấp để gửi các yêu cầu với bất kỳ phương thức HTTP nào.

Hầu hết các phương thức trong bảng 7.2 được nạp chồng thành ba dạng phương thức sau đây:
- Một chấp nhận một chuỗi đặc tả URL với các tham số URL được chỉ định trong danh sách đối số biến.
- Một chấp nhận một chuỗi đặc tả URL với các tham số URL được chỉ định trong một Map<String, String>.
- Một chấp nhận một java.net.URI như là đặc tả URL, không hỗ trợ URL có tham số.

Khi bạn hiểu rõ 12 hoạt động được cung cấp bởi RestTemplate và cách hoạt động của mỗi dạng biến, bạn sẽ có khả năng viết các client REST tiêu thụ tài nguyên.

Để sử dụng RestTemplate, bạn có thể tạo một thể hiện tại điểm cần nó, như sau:
```java
RestTemplate rest = new RestTemplate();
```
hoặc bạn có thể khai báo nó như là một bean và tiêm nó vào nơi bạn cần, như sau:
```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```
Hãy xem xét các hoạt động của RestTemplate bằng cách xem xét những hoạt động hỗ trợ bốn phương thức HTTP chính: GET, PUT, DELETE và POST. Chúng ta sẽ bắt đầu với getForObject() và getForEntity() - những phương thức GET.

7.3.1 GETting resources

Giả sử bạn muốn lấy một ingredient từ API của Taco Cloud. Đối với việc này, bạn có thể sử dụng getForObject() của RestTemplate để lấy ingredient. Ví dụ, đoạn mã sau sử dụng RestTemplate để lấy một đối tượng Ingredient dựa trên ID của nó:



public Ingredient getIngredientById(String ingredientId) {
    return rest.getForObject("http://localhost:8080/ingredients/{id}", 
    		Ingredient.class, ingredientId);
}

Ở đây, bạn đang sử dụng biến thể của `getForObject()` nhận một chuỗi URL và sử dụng danh sách biến cho các biến URL. Tham số `ingredientId` được chuyển vào `getForObject()` được sử dụng để điền vào chỗ giữ chỗ `{id}` trong URL đã cung cấp. Mặc dù chỉ có một biến URL trong ví dụ này, nhưng quan trọng là biết rằng các tham số biến được gán cho các chỗ giữ chỗ theo thứ tự chúng được cung cấp.

Tham số thứ hai cho `getForObject()` là loại dữ liệu mà phản hồi nên được ràng buộc. Trong trường hợp này, dữ liệu phản hồi (có thể ở định dạng JSON) sẽ được giải mã thành một đối tượng `Ingredient` sẽ được trả về.

Một cách khác, bạn có thể sử dụng một `Map` để xác định các biến URL, như được thể hiện dưới đây:
public Ingredient getIngredientById(String ingredientId) {
        Map<String, String> urlVariables = new HashMap<>();
        urlVariables.put("id", ingredientId);
        return rest.getForObject("http://localhost:8080/ingredients/{id}", 
             Ingredient.class, urlVariables);
    }

Trong trường hợp này, giá trị của `ingredientId` được ánh xạ vào một khóa là `id`. Khi yêu cầu được thực hiện, giữ chỗ {id} được thay thế bằng mục nhập trong Map có khóa là id.

Việc sử dụng một tham số URI đòi hỏi một chút công việc hơn, yêu cầu bạn phải tạo đối tượng URI trước khi gọi `getForObject()`. Tuy nhiên, nó giống với cả hai biến thể khác, như được thể hiện ở đây:

public Ingredient getIngredientById(String ingredientId) {
        Map<String, String> urlVariables = new HashMap<>();
        urlVariables.put("id", ingredientId);
        URI url = UriComponentsBuilder
                    .fromHttpUrl("http://localhost:8080/ingredients/{id}")
                    .build(urlVariables);
        return rest.getForObject(url, Ingredient.class);
    }

Ở đây, đối tượng URI được định nghĩa từ một chuỗi mô tả fromHttpUrl, và các chỗ giữ chỗ của nó được điền từ các entry trong một Map, tương tự như biến thể trước của `getForObject()`. Phương thức `getForObject()` là một cách không rườm rà để truy xuất một nguồn tài nguyên. Nhưng nếu client cần nhiều hơn chỉ nội dung cơ bản, bạn có thể muốn xem xét việc sử dụng `getForEntity()`.

`getForEntity()` hoạt động theo cách tương tự như `getForObject()`, nhưng thay vì trả về một đối tượng domain biểu thị nội dung phản hồi, nó trả về một đối tượng `ResponseEntity` bao bọc đối tượng domain đó. `ResponseEntity` cung cấp quyền truy cập vào các chi tiết phản hồi bổ sung, như các tiêu đề phản hồi.

Ví dụ, giả sử rằng ngoài dữ liệu ingredient, bạn muốn kiểm tra tiêu đề Date từ phản hồi. Với `getForEntity()`, điều này trở nên đơn giản, như được thể hiện trong đoạn mã sau:

public Ingredient getIngredientById(String ingredientId) {
        ResponseEntity<Ingredient> responseEntity = 
            rest.getForEntity("http://localhost:8080/ingredients/{id}", 
                Ingredient.class, ingredientId);
        LOGGER.info("Fetched time: {}", responseEntity.getHeaders().getDate());
        return responseEntity.getBody();	
    }

Phương thức `getForEntity()` được ghi đè với cùng các tham số như `getForObject()`, vì vậy bạn có thể cung cấp các biến URL dưới dạng list variables with Map hoặc gọi `getForEntity()` với một đối tượng URI.

7.3.2 PUTting resources

Để gửi các yêu cầu HTTP PUT, RestTemplate cung cấp phương thức `put()`. Tất cả ba biến thể được ghi đè của `put()` đều chấp nhận một Đối tượng sẽ được chuỗi hóa và gửi đến URL được cung cấp. Đối với URL chính nó, nó có thể được chỉ định dưới dạng đối tượng URI hoặc dưới dạng chuỗi. Giống như `getForObject()` và `getForEntity()`, biến URL có thể được cung cấp dưới dạng danh sách biến tham số hoặc dưới dạng một Map.

Giả sử bạn muốn thay thế một ingredient tài nguyên bằng dữ liệu từ một đối tượng Ingredient mới. Đoạn mã sau sẽ giải quyết vấn đề:

public void updateIngredient(Ingredient ingredient) {
    rest.put("http://locahost:8080/ingredients/{id}", 
       ingredient, ingredient.getId());
}


Ở đây, URL được cung cấp dưới dạng chuỗi và có một placeholder được thay thế bằng thuộc tính id của đối tượng Ingredient được cung cấp. Dữ liệu sẽ được gửi là chính đối tượng Ingredient. Phương thức `put()` trả về void, vì vậy không cần thêm bất kỳ xử lý nào để xử lý giá trị trả về.

7.3.3 DELETEing resources

Giả sử Taco Cloud không còn cung cấp một nguyên liệu nào đó và muốn hoàn toàn xóa nó khỏi danh sách lựa chọn. Để thực hiện điều này, bạn có thể gọi phương thức `delete()` từ RestTemplate như sau:
public void deleteIngredient(Ingredient ingredient) {
   rest.delete("http://localhost:8080/ingredients/{id}", 
       ingredient.getId());
}

Trong ví dụ này, chỉ có URL (được chỉ định dưới dạng chuỗi) và một giá trị biến URL được cung cấp cho `delete()`. Nhưng giống như với các phương thức RestTemplate khác, URL có thể được chỉ định dưới dạng đối tượng URI hoặc các tham số URL được cung cấp dưới dạng một Map.

7.3.4 POSTing resource data
Bây giờ, giả sử bạn thêm một ingredient mới vào menu Taco Cloud. Một yêu cầu HTTP POST đến end point .../ingredients với dữ liệu nguyên liệu trong phần thân yêu cầu sẽ làm cho điều đó xảy ra. RestTemplate có ba cách để gửi một yêu cầu POST, mỗi cách đều có các biến thể được nạp chồng giống nhau để chỉ định URL. Nếu bạn muốn nhận ingredient mới tạo ra sau yêu cầu POST, bạn sẽ sử dụng postForObject() như sau:
public Ingredient createIngredient(Ingredient ingredient) {
   return rest.postForObject("http://localhost:8080/ingredients", 
       ingredient, Ingredient.class);
}

Biến thể này của phương thức postForObject() nhận một chuỗi chỉ định URL, đối tượng cần được gửi đến máy chủ và kiểu miền mà phần thân phản hồi nên được ràng buộc. Mặc dù bạn không tận dụng nó trong trường hợp này, một tham số thứ tư có thể là một Map của giá trị biến URL hoặc một danh sách biến thể tham số để thay thế vào URL.

Nếu client của bạn cần biết về vị trí của tài nguyên mới được tạo, bạn có thể sử dụng phương thức `postForLocation()` như sau:

public java.net.URI createIngredientLocation(Ingredient ingredient) {
   return rest.postForLocation("http://localhost:8080/ingredients", 
       ingredient);
}

Lưu ý rằng `postForLocation()` hoạt động giống như `postForObject()`, ngoại trừ việc nó trả về một URI của tài nguyên mới được tạo thay vì đối tượng tài nguyên chính nó. URI được trả về dựa trên tiêu đề Location của phản hồi. Trong trường hợp bạn cần cả vị trí và dữ liệu phản hồi, bạn có thể gọi `postForEntity()` như sau:

public Ingredient createIngredientResponseEntity(Ingredient ingredient) {
        ResponseEntity<Ingredient> responseEntity = 
            rest.postForEntity("http://localhost:8080/ingredients", 
                ingredient, Ingredient.class);
        LOGGER.info("New resource created at {}", 
            responseEntity.getHeaders().getLocation());
        return responseEntity.getBody();
    }

Mặc dù các phương thức của RestTemplate khác nhau về mục đích, nhưng chúng khá tương tự trong cách sử dụng. Điều này giúp bạn dễ dàng trở thành người thành thạo với RestTemplate và sử dụng nó trong mã nguồn client của bạn.



Chapter 8 -Securing REST
This chapter covers
 Securing APIs with OAuth 2
 Creating an authorization server
 Adding a resource server to an API
 Consuming OAuth 2–secured APIs

Bạn đã bao giờ tận dụng dịch vụ đỗ xe trên tay không chưa? Đó là một khái niệm đơn giản: bạn giao chìa khóa xe của mình cho một nhân viên đỗ xe gần lối vào của một cửa hàng, khách sạn, rạp chiếu phim hoặc nhà hàng, và họ sẽ giải quyết việc tìm chỗ đỗ xe cho bạn. Sau đó, họ sẽ trả lại xe cho bạn khi bạn yêu cầu. Có lẽ vì tôi đã xem Ferris Bueller's Day Off quá nhiều lần, nhưng tôi luôn cảm thấy ngần ngại khi giao chìa khóa xe của mình cho một người lạ và hy vọng rằng họ sẽ chăm sóc xe của tôi tốt.

Tuy nhiên, dịch vụ đỗ xe không tận cùng việc tin tưởng vào ai đó để chăm sóc chiếc xe của bạn. Nhiều chiếc xe mới cung cấp "chìa khóa đỗ xe", một chiếc chìa khóa đặc biệt chỉ có thể được sử dụng để mở cửa xe và khởi động động cơ. Như vậy, mức độ tin tưởng bạn cấp phép là có giới hạn. Người đỗ xe không thể mở ngăn đựng găng tay hoặc cốp xe bằng chìa khóa đỗ xe.

Trong một ứng dụng phân tán, niềm tin là quan trọng giữa các hệ thống phần mềm. Ngay cả trong tình huống đơn giản khi một ứng dụng khách tiêu thụ một API backend, điều này là quan trọng. Chắc chắn rằng người dùng ứng dụng được tin tưởng và bất kỳ ai cố gắng sử dụng cùng một API đều bị chặn. Và, giống như việc tin tưởng người đỗ xe, mức độ niềm tin bạn cấp phép cho một ứng dụng khách nên bị giới hạn chỉ vào những chức năng cần thiết để ứng dụng khách thực hiện công việc của mình.

Bảo mật một REST API khác biệt so với bảo mật một ứng dụng web dựa trên trình duyệt. Trong chương này, chúng ta sẽ tìm hiểu về OAuth 2, một đặc điểm ủy quyền được tạo ra đặc biệt cho bảo mật API. Trong quá trình làm điều này, chúng ta sẽ xem xét sự hỗ trợ của Spring Security cho OAuth 2. Nhưng trước hết, hãy tạo nền tảng bằng cách xem cách OAuth 2 hoạt động.

8.1 Introducing OAuth 2

Giả sử chúng ta muốn tạo một ứng dụng back-office mới để quản lý ứng dụng Taco Cloud. Cụ thể hơn, hãy nói rằng chúng ta muốn ứng dụng mới này có khả năng quản lý các Ingredient có sẵn trên trang web chính của Taco Cloud.
Trước khi chúng ta bắt đầu viết mã cho ứng dụng quản trị, chúng ta cần thêm một số end point mới vào API của Taco Cloud để hỗ trợ quản lý nguyên liệu. Controller REST trong đoạn mã sau đây cung cấp ba end point cho việc liệt kê, thêm và xóa nguyên liệu.
@RestController
@RequestMapping(path = "/api/ingredients", produces = "application/json")
@CrossOrigin(origins = "http:localhost:8080")
public class IngredientController {
    
    @Autowired
    private IngredientRepository ingredientRepo;

    @GetMapping
    public Iterable<Ingredient> allIngredients() {
        return ingredientRepo.findAll();
    }

    @PostMapping
    @ResponseStatus()
    public Ingredient saveIngredient (@RequestBody Ingredient ingredient) { 
        return ingredientRepo.save(ingredient);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus()
    public void deleteIngredient(@PathVariable("id") String ingredientId) {
        ingredientRepo.deleteById(ingredientId);
    }
}



Tuyệt vời! Bây giờ tất cả chúng ta cần là bắt đầu với ứng dụng quản trị, gọi các điểm cuối trên ứng dụng chính Taco Cloud khi cần để thêm và xóa nguyên liệu.

Nhưng chờ đã - chưa có bảo mật xung quanh API đó. Nếu ứng dụng backend của chúng ta có thể thực hiện các yêu cầu HTTP để thêm và xóa nguyên liệu, bất cứ ai khác cũng có thể làm điều đó. Ngay cả khi sử dụng ứng dụng dòng lệnh curl, ai đó có thể thêm một nguyên liệu mới như sau:

$ curl localhost:8080/ingredients \
-H"Content-type: application/json" \
-d'{"id":"FISH","name":"Stinky Fish", "type":"PROTEIN"}'

Họ thậm chí có thể sử dụng curl để xóa các nguyên liệu hiện có như sau:
$ curl localhost:8080/ingredients/GRBF -X DELETE

API này là một phần của ứng dụng chính và có sẵn cho toàn thế giới; thực tế, end point GET được sử dụng bởi giao diện người dùng của ứng dụng chính trong home.html. Do đó, rõ ràng là chúng ta cần bảo mật ít nhất các end point POST và DELETE.
Một lựa chọn là sử dụng Basic authentication HTTP để bảo mật các end point /ingredients. Điều này có thể được thực hiện bằng cách thêm @PreAuthorize vào các phương thức xử lý như sau:

@DeleteMapping("/{id}")
    @PreAuthorize("#{hasRole('ADMIN')}")
    public void deleteIngredient(@PathVariable("id") String ingredientId) {
        ingredientRepo.deleteById(ingredientId);
    }


Tùy thuộc vào cơ sở dữ liệu và schema đang sử dụng, các ràng buộc integrities có thể ngăn cản việc xóa nếu một nguyên liệu đã là một phần của một chiếc taco hiện tại. Nhưng vẫn có thể có khả năng xóa một nguyên liệu nếu schema cơ sở dữ liệu cho phép.

Hoặc, các end point có thể được bảo vệ trong cấu hình bảo mật như sau:
@Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((authz) -> {
                authz
                .requestMatchers("/design/**", "/orders/**").hasRole("USER")
                .anyRequest().permitAll();
            })
            .authorizeHttpRequests(authz -> {
                authz 
                    .requestMatchers(HttpMethod.POST, "/ingredients").hasRole("ADMIN")
                    .requestMatchers(HttpMethod.DELETE, "/ingredients/**").hasRole("ADMIN");
            })


Có nên sử dụng tiền tố "ROLE_" hay không
Trong Spring Security, quyền có thể có nhiều dạng, bao gồm vai trò (roles), quyền hạn (permissions), và (như chúng ta sẽ thấy sau) phạm vi OAuth2. Vai trò, cụ thể, là một dạng chuyên biệt của quyền hạn được tiền tố bằng "ROLE_".

Khi làm việc với các phương thức hoặc biểu thức SpEL (Spring Expression Language) liên quan trực tiếp đến vai trò, như hasRole(), tiền tố "ROLE_" được suy luận. Do đó, việc gọi hasRole("ADMIN") nội tại đang kiểm tra một quyền hạn có tên là "ROLE_ADMIN". Bạn không cần phải sử dụng rõ ràng tiền tố "ROLE_" khi gọi các phương thức và hàm này (và thực tế, làm như vậy sẽ dẫn đến việc có hai tiền tố "ROLE_").

Các phương thức và hàm Spring Security khác xử lý quyền hạn một cách chung chung cũng có thể được sử dụng để kiểm tra vai trò. Nhưng trong những trường hợp đó, bạn phải thêm rõ ràng tiền tố "ROLE_". Ví dụ, nếu bạn chọn sử dụng hasAuthority() thay vì hasRole(), bạn cần truyền vào "ROLE_ADMIN" thay vì "ADMIN".

Mặc dù HTTP Basic có thể khóa chặt API, nhưng nó khá... à... cơ bản. Nó đòi hỏi rằng cả client và API cần phải có thông tin chung về thông tin đăng nhập của người dùng, có thể làm trùng lặp thông tin. Hơn nữa, mặc dù thông tin đăng nhập HTTP Basic được mã hóa Base64 trong request header, nếu một hacker nào đó có cách nào đó chặn được yêu cầu, thông tin đăng nhập có thể dễ dàng được thu thập, giải mã và sử dụng cho mục đích xấu. Nếu điều đó xảy ra, mật khẩu sẽ cần phải được thay đổi, do đó đòi hỏi cập nhật và xác thực lại trên tất cả các client.

Điều gì sẽ xảy ra nếu thay vì yêu cầu người quản trị xác định bản thân mình trong mỗi yêu cầu, API chỉ đơn giản yêu cầu một token chứng minh rằng họ được ủy quyền để truy cập các tài nguyên? Điều này sẽ tương tự như một vé vào sự kiện thể thao. Để vào trận đấu, người ở cổng không cần biết bạn là ai; họ chỉ cần biết bạn có một vé hợp lệ. Nếu có, bạn được phép truy cập.
Điều này khoảng giống như cách xác thực OAuth 2 hoạt động. Các client yêu cầu một access token  - tương tự như một chìa khóa valet - từ authorization server, với sự cho phép rõ ràng của người dùng. Token này cho phép họ tương tác với một API thay mặt người dùng đã ủy quyền cho client. Bất cứ lúc nào, token có thể hết hạn hoặc bị thu hồi mà không cần thay đổi mật khẩu của người dùng. Trong trường hợp đó, khách hàng chỉ cần yêu cầu một token truy cập mới để có thể tiếp tục đóng vai trò thay mặt cho người dùng. Quy trình này được minh họa trong hình 8.1.

OAuth 2 là một đặc tả bảo mật rất phong phú mang đến nhiều cách sử dụng khác nhau. Quy trình được mô tả trong hình 8.1 được gọi là phân quyền mã ủy quyền - authorization code grant. Các quy trình khác được hỗ trợ bởi đặc tả OAuth 2 bao gồm:

- Phân quyền ngầm định (Implicit grant) — Giống như phân quyền mã ủy quyền, phân quyền ngầm định chuyển hướng trình duyệt của người dùng đến máy chủ ủy quyền authorization server để nhận sự đồng thuận của người dùng. Tuy nhiên, khi chuyển hướng trở lại, thay vì cung cấp một mã ủy quyền trong yêu cầu, token truy cập được cấp ngầm định trong yêu cầu. Mặc dù ban đầu được thiết kế cho các khách hàng JavaScript chạy trong trình duyệt, quy trình này hiện không còn được khuyến khích nhiều, và phân quyền mã ủy quyền được ưa chuộng hơn.

- Phân quyền thông tin người dùng (hoặc mật khẩu) — Trong quy trình này, không có chuyển hướng nào xảy ra, và có thể thậm chí không có trình duyệt web tham gia. Thay vào đó, ứng dụng khách hàng thu được thông tin đăng nhập của người dùng và trao đổi chúng trực tiếp để nhận một token truy cập. Quy trình này dường như phù hợp cho các ứng dụng không phải dựa trên trình duyệt, nhưng ứng dụng hiện đại thường ưa chuộng yêu cầu người dùng truy cập trang web trong trình duyệt của họ và thực hiện phân quyền thông tin người dùng để tránh việc xử lý thông tin đăng nhập của người dùng.

- Phân quyền thông tin khách hàng (Client credentials grant) — Quy trình này tương tự như phân quyền thông tin người dùng, ngoại trừ việc thay vì trao đổi thông tin đăng nhập của người dùng để nhận một token truy cập, ứng dụng khách hàng trao đổi thông tin đăng nhập của chính nó để nhận một token truy cập. Tuy nhiên, token cấp phép bị hạn chế trong phạm vi thực hiện các thao tác không liên quan đến người dùng và không thể được sử dụng để đại diện cho một người dùng.

Đối với mục đích của chúng ta, chúng ta sẽ tập trung vào quy trình phân quyền mã ủy quyền authorization code grant để nhận một token truy cập JSON Web Token (JWT). Điều này sẽ bao gồm việc tạo ra một số ứng dụng làm việc cùng nhau, bao gồm các yếu tố sau:

- Máy chủ ủy quyền — Nhiệm vụ của máy chủ ủy quyền là xin phép từ người dùng thay mặt cho ứng dụng khách hàng. Nếu người dùng cấp phép, máy chủ ủy quyền cung cấp một access token cho ứng dụng khách hàng, mà nó có thể sử dụng để truy cập xác thực vào một API.

- Máy chủ tài nguyên — Máy chủ tài nguyên chỉ là một cái tên khác cho một API được bảo vệ bằng OAuth 2. Mặc dù máy chủ tài nguyên là một phần của API chính nó, nhưng để thảo luận, hai khái niệm này thường được xem xét như là hai khái niệm riêng biệt. Máy chủ tài nguyên giới hạn quyền truy cập vào tài nguyên của mình trừ khi yêu cầu cung cấp một token truy cập hợp lệ với phạm vi quyền cần thiết. Đối với mục đích của chúng ta, API Taco Cloud mà chúng ta đã bắt đầu trong chương 7 sẽ phục vụ như máy chủ tài nguyên, sau khi chúng ta thêm một số cấu hình bảo mật vào nó.

- Ứng dụng khách hàng — Ứng dụng khách hàng là một ứng dụng muốn tiêu thụ một API nhưng cần phép mà nó có thể thực hiện được. Chúng ta sẽ xây dựng một ứng dụng quản trị đơn giản cho Taco Cloud để có thể thêm các ingredient mới.

- Người dùng — Đây là con người sử dụng ứng dụng khách hàng và cấp phép cho ứng dụng thực hiện quyền truy cập vào API máy chủ tài nguyên thay mặt họ.

Trong quy trình phân quyền mã ủy quyền, một loạt các chuyển hướng trình duyệt giữa ứng dụng khách hàng và máy chủ ủy quyền xảy ra khi ứng dụng khách hàng nhận một token truy cập. Quy trình bắt đầu với ứng dụng khách hàng chuyển hướng trình duyệt của người dùng đến máy chủ ủy quyền, yêu cầu quyền cụ thể (hoặc "phạm vi"). Máy chủ ủy quyền sau đó yêu cầu người dùng đăng nhập và đồng thuận với quyền được yêu cầu. Sau khi người dùng đã đồng thuận, máy chủ ủy quyền chuyển hướng trình duyệt trở lại ứng dụng khách hàng với một mã được ứng dụng có thể trao đổi để nhận một token truy cập. Khi ứng dụng khách hàng có token truy cập, nó có thể được sử dụng để tương tác với API máy chủ tài nguyên bằng cách truyền nó trong tiêu đề "Authorization" của mọi yêu cầu.

Mặc dù chúng ta sẽ hạn chế tập trung vào một ứng dụng cụ thể của OAuth 2, bạn được khuyến khích nghiên cứu sâu hơn về chủ đề này bằng cách đọc đặc tả OAuth 2 (https://oauth.net/2/) hoặc đọc một trong những cuốn sách sau đây về chủ đề:

OAuth 2 in Action: https://www.manning.com/books/oauth-2-in-action
Microservices Security in Action: https://www.manning.com/books/microservicessecurity-
in-action
API Security in Action: https://www.manning.com/books/api-security-in-action
Bạn cũng có thể muốn xem một dự án liveProject có tên "Bảo vệ Dữ liệu Người Dùng với Spring Security và OAuth2" (http://mng.bz/4KdD).
Trong vài năm qua, dự án Spring Security for OAuth đã cung cấp hỗ trợ cho cả OAuth 1.0a và OAuth 2. Nó đã phân biệt rõ với Spring Security nhưng được phát triển bởi cùng một nhóm. Tuy nhiên, trong những năm gần đây, nhóm Spring Security đã tích hợp các thành phần khách hàng và máy chủ tài nguyên vào Spring Security chính mình.

Đối với máy chủ ủy quyền, quyết định đã được đưa ra rằng nó sẽ không được bao gồm trong Spring Security. Thay vào đó, nhà phát triển được khuyến khích sử dụng máy chủ ủy quyền từ các nhà cung cấp khác nhau như Okta, Google và những người khác. Nhưng, do yêu cầu từ cộng đồng phát triển, nhóm Spring Security đã bắt đầu một dự án Máy chủ ủy quyền Spring.2 Dự án này được gán nhãn là "thử nghiệm" và dự kiến sẽ dần dần trở thành một dự án do cộng đồng quản lý, nhưng nó là một cách tuyệt vời để bắt đầu với OAuth 2 mà không cần đăng ký cho một trong những triển khai máy chủ ủy quyền khác.

Trong phần còn lại của chương này, chúng ta sẽ thấy cách sử dụng OAuth 2 bằng cách sử dụng Spring Security. Trong quá trình này, chúng ta sẽ tạo ra hai dự án mới, một dự án máy chủ ủy quyền và một dự án khách hàng, và chúng ta sẽ sửa đổi dự án Taco Cloud hiện tại của chúng ta sao cho API của nó hoạt động như một máy chủ tài nguyên. Chúng ta sẽ bắt đầu bằng cách tạo một máy chủ ủy quyền bằng dự án Máy chủ ủy quyền Spring.

8.2 Creating an authorization server

Nhiệm vụ chính của máy chủ ủy quyền là cung cấp một access token thay mặt cho người dùng. Như đã đề cập trước đó, chúng ta có nhiều triển khai máy chủ ủy quyền để lựa chọn, nhưng chúng ta sẽ sử dụng Spring Authorization Server cho dự án của mình. Spring Authorization Server là một dự án thử nghiệm và không triển khai tất cả các loại cấp phép OAuth 2, nhưng nó triển khai cấp phép mã ủy quyền và cấp phép thông tin khách hàng.

Máy chủ ủy quyền là một ứng dụng riêng biệt so với bất kỳ ứng dụng nào cung cấp API và cũng khác biệt so với client. Do đó, để bắt đầu với Spring Authorization Server, bạn sẽ muốn tạo một dự án Spring Boot mới, chọn ít nhất các bộ starter web và security. Đối với máy chủ ủy quyền của chúng ta, người dùng sẽ được lưu trữ trong một cơ sở dữ liệu quan hệ bằng cách sử dụng JPA, vì vậy hãy chắc chắn thêm starter JPA và các phụ thuộc H2 vào. Và nếu bạn đang sử dụng Lombok để xử lý các phương thức getter, setter, constructors, và các thứ khác, thì hãy chắc chắn bao gồm nó.
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
</dependency>

Tiếp theo, vì chúng ta sẽ chạy tất cả trên máy tính phát triển của chúng ta (ít nhất là vào lúc này), bạn muốn đảm bảo rằng không có xung đột cổng giữa ứng dụng chính Taco Cloud và máy chủ ủy quyền. Thêm mục sau vào tệp application.yml của dự án sẽ làm cho máy chủ ủy quyền sẵn có trên cổng 9000:

server:
    port: 9000



Bây giờ hãy đào sâu vào cấu hình bảo mật cơ bản sẽ được sử dụng bởi máy chủ ủy quyền. Mã nguồn tiếp theo hiển thị một lớp cấu hình Spring Security rất đơn giản cho phép đăng nhập dựa trên biểu mẫu và yêu cầu rằng tất cả các yêu cầu phải được xác thực.
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        return http.authorizeHttpRequests(auth -> {
            auth
                .anyRequest().authenticated()
        })
        .formLogin(customize -> {
            
        })
        .build();
    }

    @Bean
    UserDetailsService userDetailsService(UserRepository userRepo) {
        return username -> userRepo.findByUsername(username);
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

Chú ý rằng `UserDetailsService` bean tương tác với một `UserRepository` để tìm kiếm người dùng theo username của họ. Để tiếp tục cấu hình máy chủ ủy quyền, chúng ta sẽ bỏ qua các chi tiết của `UserRepository`, nhưng đủ để nói rằng nó giống như một số repository dựa trên Spring Data mà chúng ta đã tạo kể từ chương 3.

Điều đáng chú ý duy nhất về `UserRepository` là (để thuận tiện trong việc kiểm thử), bạn có thể sử dụng nó trong một bean `CommandLineRunner` để điền trước cơ sở dữ liệu với một vài người dùng kiểm thử như sau:
@Bean
    ApplicationRunner dataLoader(UserRepository repo, PasswordEncoder encoder) {
        return args -> {
            User user01 = new User();
            user01.setUsername("habuma");
            user01.setPassword(encoder.encode("password"));
            user01.setAuthorities(List.of(new SimpleGrantedAuthority("ROLE_ADMIN")));
                        
            User user02 = new User();
            user01.setUsername("tacochef");
            user01.setPassword(encoder.encode("password"));
            user01.setAuthorities(List.of(new SimpleGrantedAuthority("ROLE_ADMIN")));

            repo.save(user01);
            repo.save(user02);
        };
    }

Bây giờ chúng ta có thể bắt đầu áp dụng cấu hình để kích hoạt một máy chủ ủy quyền. Bước đầu tiên trong quá trình cấu hình máy chủ ủy quyền là tạo một lớp cấu hình mới mà nhập một số cấu hình chung cho máy chủ ủy quyền. Mã nguồn dưới đây cho AuthorizationServerConfig là một bắt đầu tốt:
@Configuration(proxyBeanMethods = false)
public class AuthorizationServerConfig {

    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    SecurityFilterChain authorizationServerConfiguration(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfiguration
            .applyDefaultSecurity(http);
        return 
        http
            .formLogin(Customizer.withDefaults())
            .build();
    }
}

Phương thức bean `authorizationServerSecurityFilterChain()` định nghĩa một Security-FilterChain thiết lập một số hành vi mặc định cho máy chủ ủy quyền OAuth 2 và một trang đăng nhập mặc định. Chú thích `@Order` được gán giá trị `Ordered.HIGHEST_PRECEDENCE` để đảm bảo rằng, nếu có những bean khác của loại này được khai báo vì lý do nào đó, bean này sẽ có ưu tiên hơn so với những bean khác. 

Đối với hầu hết, đây là một cấu hình mẫu. Nếu bạn muốn, bạn có thể đi sâu hơn và tùy chỉnh cấu hình. Nhưng hiện tại, chúng ta chỉ sẽ sử dụng các giá trị mặc định.

Một thành phần không phải là boilerplate – bản mẫu, và do đó không được cung cấp bởi 
OAuth2AuthorizationServerConfiguration, là nguồn dữ liệu về client. Một client repository tương tự như một user details service hoặc user repository, ngoại trừ việc thay vì duy trì chi tiết về người dùng, nó duy trì chi tiết về các clients có thể yêu cầu quyền trên thay mặt của người dùng. Nó được định nghĩa bởi giao diện `RegisteredClientRepository`, có dạng như sau:

public interface RegisteredClientRepository {
    
    @Nullable
    RegisteredClient findById(String id);

    @Nullable
    RegisteredClient findByClientId(String clientId);
}


Trong môi trường sản xuất, bạn có thể viết một triển khai tùy chỉnh của RegisteredClientRepository để lấy chi tiết của client từ một cơ sở dữ liệu hoặc từ một nguồn khác. Tuy nhiên, mặc định, Spring Authorization Server cung cấp một triển khai in-memory hoàn hảo cho mục đích giới thiệu và kiểm thử. Bạn được khuyến khích triển khai RegisteredClientRepository theo cách bạn muốn. Nhưng với mục đích của chúng ta, chúng ta sẽ sử dụng triển khai in-memory để đăng ký một client duy nhất với máy chủ ủy quyền. Thêm phương thức bean sau vào AuthorizationServerConfig:
@Bean
    RegisteredClientRepository registeredClientRepository (PasswordEncoder encoder) {
        RegisteredClient registeredClient = 
            RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("taco-admin-client")
                .clientSecret(encoder.encode("secret"))
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:9090/login/oauth2/code/taco-admin-client")
                .scope("writeIngredientsaaa")
                .scope("deleteIngredientsaaa")
                .scope(OidcScopes.OPENID)
                .clientSettings(clientSettings -> clientSettings.requireUserConsent(true))
                .build();
        return new InMemoryRegisteredClientRepository(registeredClient);
    }

Như bạn có thể thấy, có rất nhiều chi tiết liên quan đến một `RegisteredClient`. Nhưng đi từ đầu xuống, đây là cách client của chúng ta được định nghĩa:

- **ID:** Một bộ nhận diện ngẫu nhiên và duy nhất.
- **Client ID:** Tương tự như một username, nhưng thay vì là người dùng, đó là một client. Trong trường hợp này, là "taco-admin-client".
- **Client secret:** Tương tự như mật khẩu cho client. Ở đây, chúng ta sử dụng từ "secret" cho client secret.
- **Authorization grant type:** Các loại cấp quyền OAuth 2 mà client này sẽ hỗ trợ. Trong trường hợp này, chúng ta bật cấp quyền authorization code và cấp token mới (authorization code and refresh token).
- **Redirect URL:** Một hoặc nhiều URL đã đăng ký mà máy chủ ủy quyền có thể chuyển hướng đến sau khi quyền được cấp. Điều này thêm một cấp độ bảo mật khác, ngăn chặn một số ứng dụng tùy ý từ việc nhận mã xác thực mà nó có thể trao đổi để nhận một token.
- **Scope:** Một hoặc nhiều phạm vi OAuth 2 mà client này được phép yêu cầu. Ở đây, chúng ta đang đặt ba phạm vi: "writeIngredients", "deleteIngredients", và hằng số OidcScopes.OPENID, giải quyết thành "openid". Phạm vi "openid" sẽ cần thiết sau này khi chúng ta sử dụng máy chủ ủy quyền như một giải pháp đăng nhập duy nhất cho ứng dụng quản trị Taco Cloud.
- **Client settings:** Đây là một lambda cho phép chúng ta tùy chỉnh cài đặt của client. Trong trường hợp này, chúng ta đang yêu cầu sự đồng ý rõ ràng của người dùng trước khi cấp phạm vi được yêu cầu. Nếu thiếu điều này, phạm vi sẽ được cấp ngầm sau khi người dùng đăng nhập.

Cuối cùng, vì authorization server của chúng ta sẽ tạo ra các token JWT, các token sẽ cần bao gồm một chữ ký được tạo bằng cách sử dụng một JSON Web key (JWK)3 như là chìa khóa ký. Do đó, chúng ta sẽ cần một vài bean để tạo ra một JWK. Thêm phương thức bean (và các phương thức trợ giúp riêng tư) sau vào AuthorizationServerConfig để xử lý điều đó cho chúng ta:

@Bean
    JWKSource<SecurityContext> jwkSource() throws NoSuchAlgorithmException {
        RSAKey rsaKey = generateRsa();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return (jwkSelector, securityContext) -> jwkSelector.select(jwkSet);
    }

    private static RSAKey generateRsa() throws NoSuchAlgorithmException {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        return new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(UUID.randomUUID().toString())
            .build();
    }

    private static KeyPair generateRsaKey() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }

    @Bean
    JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }


Có vẻ như có nhiều điều đang diễn ra ở đây. Nhưng để tóm tắt, JWKSource tạo ra các cặp khóa RSA 2048 bit sẽ được sử dụng để sign ký token. Token sẽ được ký bằng cách sử dụng khóa riêng tư. Máy chủ nguồn tài nguyên resource server sau đó có thể xác minh rằng token nhận được trong một yêu cầu là hợp lệ bằng cách lấy khóa công khai từ máy chủ ủy quyền. Chúng ta sẽ nói thêm về điều đó khi chúng ta tạo máy chủ nguồn tài nguyên.
Tất cả các thành phần của máy chủ ủy quyền của chúng ta hiện đã hoàn tất. Tất cả những gì còn lại để làm là khởi động nó và thử nghiệm. Xây dựng và chạy ứng dụng, và bạn sẽ có một máy chủ ủy quyền lắng nghe trên cổng 9000.
Bởi vì chúng ta chưa có một client, bạn có thể giả mạo là một client bằng cách sử dụng trình duyệt web và công cụ dòng lệnh curl. Bắt đầu bằng cách chỉ đến trình duyệt web của bạn tại http://localhost:9000/oauth2/authorize?response_type=code&client_id=tacoadmin-client&redirect_uri=http://127.0.0.1:9090/login/oauth2/code/taco-admin-client&-scope=writeIngredients+deleteIngredients.4 Bạn nên thấy một trang đăng nhập giống như hình 8.2.

 

Sau khi đăng nhập (với "tacochef" và "password," hoặc một cặp tên người dùng-mật khẩu nào đó trong cơ sở dữ liệu dưới TacoUserRepository), bạn sẽ được yêu cầu đồng ý cho các phạm vi được yêu cầu trên một trang giống như hình 8.3.

 
Sau khi đồng ý, trình duyệt sẽ được chuyển hướng trở lại đến URL của client. Chúng ta chưa có một client nên có thể không có gì ở đó và bạn có thể nhận được một lỗi. Nhưng không sao cả chúng ta giả vờ là client, nên chúng ta sẽ lấy authorization code từ URL một cách tự động.

Nhìn vào thanh địa chỉ của trình duyệt, bạn sẽ thấy rằng URL có một tham số là "code." Sao chép giá trị toàn bộ của tham số đó và sử dụng nó trong dòng lệnh curl sau đây thay vì $code:

$ curl localhost:9000/oauth2/token \
-H "Content-type: application/x-www-form-urlencoded" \
-d "grant_type=authorization_code" \
-d "redirect_uri=http://127.0.0.1:9090/login/oauth2/code/taco-admin-client" \
-d "code=authorization_code" \
-u taco-admin-client:secret

Lưu ý: Hãy thay thế "authorization_code " bằng giá trị thực tế bạn đã sao chép từ URL.

Ở đây, chúng tôi đang trao đổi mã ủy quyền mà chúng tôi nhận được để nhận một access token. Phần nội dung của yêu cầu được định dạng theo kiểu "application/x-www-form-urlencoded" và gửi các thông tin bao gồm grant type ("authorization_code"), redirect URI (để tăng cường bảo mật thêm), và mã ủy quyền chính nó. Nếu mọi thứ diễn ra đúng, bạn sẽ nhận được một phản hồi dưới dạng JSON, có vẻ như sau khi được định dạng:

{
  "access_token":"eyJraWQ...",
  "refresh_token":"HOzHA5s...",
  "scope":"deleteIngredients writeIngredients",
  "token_type":"Bearer",
  "expires_in":"299"
}
Thuộc tính "access_token" chứa access token mà một client có thể sử dụng để gửi các yêu cầu đến API. Trên thực tế, nó thường dài hơn so với những gì được hiển thị ở đây. Tương tự, "refresh_token" đã được rút gọn ở đây để tiết kiệm không gian. Nhưng access token có thể được gửi trong các yêu cầu đến resource server để truy cập vào các tài nguyên đòi hỏi phạm vi "writeIngredients" hoặc "deleteIngredients". Access token sẽ hết hạn sau 299 giây (hoặc ít hơn 5 phút), vì vậy chúng ta cần phải nhanh chóng sử dụng nó. Tuy nhiên, nếu nó hết hạn, chúng ta có thể sử dụng refresh token để lấy access token mới mà không cần phải đi qua quy trình ủy quyền từ đầu.

Vậy, làm thế nào chúng ta có thể sử dụng access token? Có lẽ, chúng ta sẽ gửi nó trong một yêu cầu đến API của Taco Cloud như một phần của tiêu đề "Authorization" có thể giống như sau:
$ curl localhost:8080/ingredients \
  -H"Content-type: application/json" \
  -H"Authorization: Bearer eyJraWQ..." \
  -d'{"id":"FISH","name":"Stinky Fish", "type":"PROTEIN"}'	

Tại thời điểm này, token không có ý nghĩa gì đối với chúng ta. Điều này xảy ra vì API của Taco Cloud của chúng ta chưa được kích hoạt để trở thành một resource server. Nhưng thay vì có một resource server và client API thực tế, chúng ta vẫn có thể kiểm tra access token bằng cách sao chép và dán nó vào mẫu tại https://jwt.io. Kết quả sẽ trông giống như hình 8.4.

 

Như bạn có thể thấy, mã token được giải mã thành ba phần: tiêu đề (header), nội dung (payload), và chữ ký (signature). Nếu nhìn kỹ vào phần nội dung, bạn sẽ thấy rằng mã token này được phát hành thay mặt cho người dùng có tên là "tacochef" và mã token này có các phạm vi là "writeIngredients" và "deleteIngredients". Đúng như chúng ta đã yêu cầu!

Sau khoảng 5 phút, mã token truy cập sẽ hết hạn. Bạn vẫn có thể xem nó trong công cụ kiểm tra lỗi tại https://jwti.io, nhưng nếu nó được sử dụng trong một yêu cầu thực tế đến một API, nó sẽ bị từ chối. Tuy nhiên, bạn có thể yêu cầu một mã access token mới mà không cần phải thực hiện lại quy trình cấp mã ủy quyền. Bạn chỉ cần thực hiện một yêu cầu mới đến máy chủ xác thực bằng cách sử dụng quyền "refresh_token" và truyền refresh token như là giá trị của tham số "refresh_token". Sử dụng `curl`, một yêu cầu như vậy sẽ trông như sau:

```bash
$ curl localhost:9000/oauth2/token \
-H "Content-type: application/x-www-form-urlencoded" \
-d "grant_type=refresh_token&refresh_token=HOzHA5s..." \
-u taco-admin-client:secret
```

Phản hồi từ yêu cầu này sẽ giống như phản hồi từ yêu cầu đã đổi mã ủy quyền thành mã token truy cập ban đầu, chỉ khác biệt là có một mã token truy cập mới và mới tinh.

Mặc dù việc dán mã token truy cập vào https://jwt.io có vẻ thú vị, nhưng sức mạnh và mục đích thực sự của mã token truy cập là để truy cập vào một API. Vì vậy, hãy xem làm thế nào để kích hoạt một máy chủ tài nguyên trên API Taco Cloud.

8.3 Securing an API with a resource server

Máy chủ tài nguyên thực sự chỉ là một bộ lọc đặt trước một API, đảm bảo rằng các yêu cầu cho tài nguyên đòi hỏi xác thực bao gồm một mã token truy cập hợp lệ với phạm vi yêu cầu. Spring Security cung cấp một triển khai máy chủ tài nguyên OAuth2 mà bạn có thể thêm vào một API hiện tại bằng cách thêm phụ thuộc sau vào công cụ xây dựng dự án như sau:

<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>


Bạn cũng có thể thêm dependency resource server bằng cách chọn phụ thuộc "OAuth2 Resource Server" từ Initializr khi tạo một dự án.

Với phụ thuộc đã được thêm, bước tiếp theo là khai báo rằng các yêu cầu POST đến /ingredients yêu cầu phạm vi "writeIngredients" và rằng các yêu cầu DELETE đến /ingredients yêu cầu phạm vi "deleteIngredients". Đoạn mã sau đây từ lớp SecurityConfig của dự án mô tả cách thực hiện điều đó:

@Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(auth -> {
                auth
                    .antMatchers(HttpMethod.POST, "/data-api/ingredients")
                        .hasAuthority("SCOPE_writeIngredients")
                    .antMatchers(HttpMethod.DELETE, "/data-api/ingredients")
                        .hasAuthority("SCOPE_deleteIngredients");
            })
    }


Đối với mỗi trong số các điểm cuối (endpoints), phương thức `.hasAuthority()` được gọi để chỉ định phạm vi (scope) yêu cầu. Lưu ý rằng các phạm vi này được thêm tiền tố là "SCOPE_" để chỉ định rằng chúng nên được so sánh với các phạm vi OAuth 2 trong access token được gửi trên yêu cầu đến những nguồn tài nguyên đó.
Trong cùng lớp cấu hình đó, chúng ta cũng cần kích hoạt resource server, như được thể hiện dưới đây:

@Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> {
                auth
                    .antMatchers(HttpMethod.POST, "/data-api/ingredients")
                        .hasAuthority("SCOPE_writeIngredients")
                    .antMatchers(HttpMethod.DELETE, "/data-api/ingredients")
                        .hasAuthority("SCOPE_deleteIngredients");
            })
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
    }


Phương thức `oauth2ResourceServer()` ở đây được truyền một lambda để cấu hình resource server. Ở đây, nó đơn giản chỉ kích hoạt việc sử dụng JWT tokens (không phải là opaque tokens) để resource server có thể kiểm tra nội dung của token để xem những quyền hạn bảo mật nào nó bao gồm. Cụ thể, nó sẽ kiểm tra xem token có bao gồm phạm vi "write-Ingredients" và/hoặc "deleteIngredients" cho hai điểm cuối mà chúng ta đã bảo vệ hay không.

Tuy nhiên, resource server sẽ không tin tưởng vào giá trị của token ngay từ đầu. Để chắc chắn rằng token được tạo ra bởi một authorization server đáng tin cậy thay mặt người dùng, nó sẽ xác minh chữ ký của token bằng cách sử dụng khóa công khai phù hợp với khóa riêng tư đã được sử dụng để tạo ra chữ ký của token. Tuy nhiên, chúng ta cần cấu hình resource server để biết nơi lấy khóa công khai. Thuộc tính sau đây sẽ chỉ định URL JWK set trên authorization server, từ đó resource server sẽ tải khóa công khai:
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:9000/oauth2/jwks

Và bây giờ, resource server của chúng ta đã sẵn sàng! Hãy xây dựng ứng dụng Taco Cloud và khởi động nó. Sau đó, bạn có thể thử nghiệm nó bằng cách sử dụng curl như sau:

http POST localhost:8080/ingredients id=CRKT name="Legless Crickets" type=PROTEIN
Yêu cầu sẽ thất bại với mã phản hồi HTTP 401. Điều này xảy ra vì chúng ta đã cấu hình điểm cuối để yêu cầu phạm vi "writeIngredients" cho điểm cuối đó, và chúng ta không đã cung cấp một access token hợp lệ với phạm vi đó trong yêu cầu.

Để thực hiện một yêu cầu thành công và thêm một mục nguyên liệu mới, bạn cần có một access token được tạo ra bằng cách sử dụng quy trình chúng ta đã sử dụng trong phần trước, đồng thời đảm bảo rằng chúng ta yêu cầu các phạm vi "writeIngredients" và "deleteIngredients" khi chuyển hướng trình duyệt đến authorization server. Sau đó, cung cấp access token trong header "Authorization" bằng cách sử dụng curl như sau (thay thế "$token" bằng access token thực tế):

http POST localhost:8080/ingredients \
  id=SHMP \
  name="Coconut Shrimp" \
  type=PROTEIN \
  "Authorization:Bearer $token"
Lần này, thành phần nguyên liệu mới sẽ được tạo. Bạn có thể xác minh điều này bằng cách sử dụng curl hoặc HTTP client bạn chọn để thực hiện một yêu cầu GET đến điểm cuối /ingredients như sau:

$ curl localhost:8080/ingredients
[
{
"id": "FLTO",
"name": "Flour Tortilla",
"type": "WRAP"
},
...
{
"id": "SHMP",
"name": "Coconut Shrimp",
"type": "PROTEIN"
}
]

Bây giờ, Coconut Shrimp được bao gồm ở cuối danh sách tất cả các nguyên liệu trả về từ điểm cuối /ingredients. Thành công!

Hãy nhớ rằng token truy cập sẽ hết hạn sau 5 phút. Nếu bạn để token hết hạn, các yêu cầu sẽ bắt đầu trả lại mã phản hồi HTTP 401 lại. Nhưng bạn có thể lấy một token truy cập mới bằng cách thực hiện một yêu cầu đến máy chủ xác thực bằng cách sử dụng refresh token bạn đã nhận cùng với token truy cập (thay thế refresh token thực tế cho "$refresh-Token"), như được hiển thị ở đây:
 

http POST localhost:9000/oauth2/token \
  grant_type=refresh_token \
  refresh_token=$refreshToken \
  "Authorization: Basic $(echo -n 'taco-admin-client:secret' | base64)"

Với một token truy cập mới được tạo, bạn có thể tiếp tục tạo nguyên liệu mới một cách thoải mái.

Bây giờ chúng ta đã bảo mật điểm cuối /ingredients, có lẽ là một ý tưởng tốt để áp dụng các kỹ thuật tương tự để bảo mật các điểm cuối khác có thể nhạy cảm trong API của chúng ta. Đối với ví dụ, điểm cuối /orders có thể không nên mở cho bất kỳ loại yêu cầu nào, thậm chí là yêu cầu HTTP GET, vì điều này có thể cho phép một hacker dễ dàng lấy thông tin của khách hàng. Tôi để lại cho bạn quyết định cách bảo mật điểm cuối /orders và phần còn lại của API theo cách bạn thấy đúng.

Việc quản trị ứng dụng Taco Cloud bằng cách sử dụng curl hoạt động tốt để nghịch ngợm và hiểu cách các token OAuth 2 đóng một phần trong việc cho phép truy cập vào một nguồn tài nguyên. Nhưng cuối cùng, chúng ta muốn một ứng dụng client thực sự có thể được sử dụng để quản lý ingredients. Hãy bây giờ chuyển sự chú ý của chúng ta sang việc tạo một ứng dụng khách hàng có khả năng OAuth để nhận các token truy cập và thực hiện yêu cầu đến API.

8.4 Developing the client

Trong quy trình ủy quyền OAuth 2, vai trò của ứng dụng client là để có được access token và thực hiện các yêu cầu đến máy chủ tài nguyên thay mặt người dùng. Vì chúng ta đang sử dụng quy trình mã xác nhận của OAuth 2, điều này có nghĩa là khi ứng dụng client xác định rằng người dùng chưa được xác thực, nó nên chuyển hướng trình duyệt của người dùng đến máy chủ ủy quyền để có được sự đồng thuận từ phía người dùng. Sau đó, khi máy chủ ủy quyền chuyển hướng kiểm soát trở lại cho ứng dụng client, ứng dụng client phải trao đổi mã xác nhận nó nhận được để có được mã truy cập.
Điều quan trọng nhất là: ứng dụng client sẽ cần hỗ trợ OAuth 2 của Spring Security trong classpath của mình. Dependency starter sau đây sẽ giúp thực hiện điều đó:
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

Không chỉ cung cấp cho ứng dụng khả năng client OAuth 2 mà chúng ta sẽ tận dụng ngay sau đây, mà nó cũng giúp đưa vào Spring Security chính nó theo cách gián tiếp. Điều này cho phép chúng ta viết một số cấu hình bảo mật cho ứng dụng. Bean SecurityFilterChain sau đây thiết lập Spring Security sao cho tất cả các yêu cầu đều yêu cầu xác thực:
public class SecurityConfig {
    
    @Bean
    SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> {
                auth.anyRequest().authenticated()
            })
            .oauth2Login(auth -> {
                auth
                    .loginPage("/oauth2/authorization/taco-admin-client");
            })
            .oauth2Client(Customizer.withDefaults());
        return http.build();
    }
}


Hơn nữa, bean SecurityFilterChain này cũng kích hoạt các thành phần phía client của OAuth 2. Cụ thể, nó thiết lập một trang đăng nhập tại đường dẫn /oauth2/authorization/tacoadmin-client. Nhưng đây không phải là một trang đăng nhập thông thường yêu cầu tên người dùng và mật khẩu. Thay vào đó, nó chấp nhận một mã xác nhận, trao đổi nó để có được một mã truy cập và sử dụng mã truy cập đó để xác định danh tính của người dùng. Nói một cách khác, đây là đường dẫn mà máy chủ ủy quyền sẽ chuyển hướng đến sau khi người dùng đã cấp quyền.

Chúng ta cũng cần cấu hình các chi tiết về máy chủ ủy quyền và chi tiết OAuth 2 của ứng dụng của chúng ta. Điều này được thực hiện trong các thuộc tính cấu hình, như trong tệp application.yml sau đây, cấu hình cho một client có tên là taco-admin-client:

spring:
  security:
    oauth2:
      client:
        registration:
          taco-admin-client:
            provider: tacocloud
            client-id: taco-admin-client
            client-secret: secret
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:9090/login/oauth2/code/{registrationId}
            scope: writeIngredients,deleteIngredients,openid


Đoạn mã này đăng ký một client với Spring Security OAuth 2 có tên là taco-admin-client. Chi tiết đăng ký bao gồm thông tin chứng thực của client (client-id và client-secret), loại cấp quyền (authorization-grant-type), các phạm vi đang được yêu cầu (scope) và URI chuyển hướng (redirect-uri). Lưu ý rằng giá trị được đưa vào redirect-uri có một placeholder tham chiếu đến ID đăng ký của client, đó là tacoadmin-client. Do đó, URI chuyển hướng được đặt thành http://127.0.0.1:9090/login/oauth2/code/taco-admin-client, có cùng đường dẫn mà chúng ta đã cấu hình làm đăng nhập OAuth 2 trước đó.

Nhưng vậy máy chủ ủy quyền chính nó ở đâu? Làm thế nào chúng ta cho client biết rằng nó nên chuyển hướng trình duyệt của người dùng? Đó là nhiệm vụ của thuộc tính provider, mặc dù gián tiếp. Thuộc tính provider được đặt thành tacocloud, đó là một tham chiếu đến một bộ cấu hình riêng biệt mô tả máy chủ ủy quyền của nhà cung cấp tacocloud. Cấu hình của nhà cung cấp đó được thiết lập trong cùng tệp application.yml như sau:

spring:
  security:
    oauth2:
      client:
        registration:
          taco-admin-client:
            provider: tacocloud
            client-id: taco-admin-client
            client-secret: secret
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:9090/login/oauth2/code/{registrationId}
            scope: writeIngredients,deleteIngredients,openid
        provider:
          tacocloud:
            issuer-uri: http://authserver:9000

Đối với cấu hình nhà cung cấp, duy nhất thuộc tính cần thiết là issuer-uri. Thuộc tính này xác định URI cơ sở cho máy chủ ủy quyền. Trong trường hợp này, nó đề cập đến một máy chủ có tên là authserver. Giả sử bạn đang chạy các ví dụ này ở cấp độ local, đây chỉ là một tên địa chỉ khác cho localhost. Trên hầu hết các hệ điều hành dựa trên Unix, điều này có thể được thêm vào tệp /etc/hosts của bạn với dòng sau đây:
127.0.0.1 authserver
Hãy tham khảo tài liệu của hệ điều hành của bạn để biết chi tiết về cách tạo các mục nhập host tùy chỉnh nếu /etc/hosts không phải là cách hoạt động trên máy của bạn.

Xây dựng trên URL base, Spring Security OAuth 2 client sẽ giả định các giá trị mặc định hợp lý cho URL authorization, URL token và các chi tiết khác của máy chủ ủy quyền. Tuy nhiên, nếu vì một lý do nào đó máy chủ ủy quyền bạn đang làm việc với khác biệt so với các giá trị mặc định đó, bạn có thể cấu hình rõ ràng các chi tiết ủy quyền như sau:

        provider:
          tacocloud:
            issuer-uri: http://localhost:9000
            authorization-uri: http://localhost:9000/oauth2/authorize
            token-uri: http://localhost:9000/oauth2/authorize/token
            jwk-set-uri: http://localhost:9000/oauth2/jwks
            user-info-uri: http://localhost:9000/userinfo
            user-name-attribute: sub


Chúng ta đã thấy hầu hết các URI này, như là URI ủy quyền, URI mã thông báo và URI JWK Set. Tuy nhiên, thuộc tính user-info-uri là mới. URI này được client sử dụng để lấy thông tin người dùng quan trọng, đặc biệt là tên người dùng của người dùng. Một yêu cầu đến URI đó nên trả về một phản hồi JSON bao gồm thuộc tính được chỉ định trong username-attribute để xác định người dùng. Tuy nhiên, khi sử dụng Spring Authorization Server, bạn không cần phải tạo điểm cuối cho URI đó; Spring Authorization Server sẽ tự động tiết lộ điểm cuối user-info.

Bây giờ tất cả các thành phần đã được thiết lập để ứng dụng có thể xác thực và có được một access token từ máy chủ ủy quyền. Mà không cần thêm bất kỳ hành động nào, bạn có thể khởi chạy ứng dụng, thực hiện một yêu cầu đến bất kỳ URL nào trên ứng dụng đó, và được chuyển hướng đến máy chủ ủy quyền để xác thực. Khi máy chủ ủy quyền chuyển hướng trở lại, sau đó bản chất hoạt động của thư viện client OAuth 2 của Spring Security sẽ trao đổi mã nhận được trong chuyển hướng để có được một access token. Bây giờ, làm thế nào chúng ta có thể sử dụng mã đó?
Hãy giả sử rằng chúng ta có một bean service tương tác với API Taco Cloud bằng RestTemplate. Implementation RestIngredientService sau đây cho thấy một class như vậy cung cấp hai phương thức: 
một để lấy list ingredients và một để lưu một ingredient mới:

public class RestIngredientService implements IngredientService {
    
    RestTemplate rest;

    public RestIngredientService(RestTemplate rest) {
        this.rest = rest;
    }

    @Override
    public Ingredient addIngredient(Ingredient ingredient) {
        return rest.postForObject(
            "http://localhost:8080/data-api/ingredients", 
            ingredient, 
            Ingredient.class);        
    }

    @Override
    public Iterable<Ingredient> findAll() {
        return Arrays.asList(rest.getForObject(
            "http://localhost:8080/data-api/ingredients",  Ingredient[].class));
    }
    
}

Yêu cầu HTTP GET cho điểm cuối /ingredients không được bảo vệ, nên phương thức findAll() nên hoạt động đúng, miễn là API Taco Cloud đang lắng nghe trên localhost, cổng 8080. Nhưng phương thức addIngredient() có thể sẽ thất bại với phản hồi HTTP 401 vì chúng ta đã bảo vệ yêu cầu POST đến /ingredients để yêu cầu phạm vi "writeIngredients". Điều duy nhất để vượt qua điều đó là gửi một mã truy cập với phạm vi "writeIngredients" trong tiêu đề Authorization của yêu cầu.
May mắn thay, thư viện OAuth 2 client của Spring Security nên có access token sẵn có sau khi hoàn thành quy trình mã xác nhận. Tất cả những gì chúng ta cần làm là đảm bảo rằng access token kết thúc trong yêu cầu. Để làm điều đó, hãy thay đổi constructor để đính kèm một request interceptor vào RestTemplate nó tạo như sau:

public RestIngredientService(String accessToken) {
        this.rest = new RestTemplate();
        if(accessToken != null) {
            this.rest.getInterceptors().add(getBearerTokenInterceptor(accessToken));
        }
    }

    private ClientHttpRequestInterceptor getBearerTokenInterceptor(String accessToken) {
        ClientHttpRequestInterceptor interceptor = new ClientHttpRequestInterceptor() {

            @Override
            public ClientHttpResponse intercept(HttpRequest request, byte[] body,  ClientHttpRequestExecution execution)
                    throws IOException {
                request.getHeaders().add("Authorization", "Bearer " + accessToken);
                return execution.execute(request, body);
            }
        };
        return interceptor;
    }


Bây giờ, constructor nhận một tham số String là token. Sử dụng token này, nó đính kèm một client request interceptor thêm tiêu đề Authorization vào mọi yêu cầu được thực hiện bởi RestTemplate sao cho giá trị của tiêu đề là "Bearer" theo sau là giá trị của token. Vì mục đích giữ constructor gọn gàng, interceptor của client được tạo trong một phương thức trợ giúp riêng tư.

Chỉ còn một câu hỏi: mã truy cập đến từ đâu? Phương thức bean sau đây là nơi phép màu diễn ra:

@Bean
    @RequestScope
    IngredientService ingredientService(OAuth2AuthorizedClientService clientService) {
        Authentication authentication = 
            SecurityContextHolder.getContext().getAuthentication();
        
        String accessToken = null;
        if(authentication.getClass().isAssignableFrom(OAuth2AuthenticationToken.class)) {
            OAuth2AuthenticationToken oauthToken = 
                (OAuth2AuthenticationToken) authentication;
            String clientRegistrationId = 
                oauthToken.getAuthorizedClientRegistrationId();
            if(clientRegistrationId.equals("taco-admin-client")) {
                OAuth2AuthorizedClient client = 
                    clientService.loadAuthorizedClient(clientRegistrationId, oauthToken.getName());
                    accessToken = client.getAccessToken().getTokenValue();
            }
        }
        return new RestIngredientService(accessToken);
    }

Để bắt đầu, hãy chú ý rằng bean được khai báo là có phạm vi request sử dụng chú thích @RequestScope. Điều này có nghĩa là một phiên bản mới của bean sẽ được tạo trên mỗi request. Bean phải có phạm vi yêu cầu vì nó cần lấy thông tin xác thực từ SecurityContext, mà được điền vào trên mỗi yêu cầu bởi một trong những bộ lọc của Spring Security; không có SecurityContext nào khi ứng dụng khởi động và tạo các bean có phạm vi mặc định.

Trước khi trả về một phiên bản RestIngredientService, phương thức bean kiểm tra xem xác thực có thực sự được triển khai dưới dạng OAuth2AuthenticationToken hay không. Nếu có, điều đó có nghĩa là nó sẽ có token Sau đó, nó xác minh rằng token này thuộc về client có tên là taco-admin-client. Nếu có, nó rút token từ authorized client và truyền nó qua constructor của RestIngredientService. Với token ấy trong tay, RestIngredientService sẽ không gặp khó khăn gì khi thực hiện các yêu cầu đến các end point của API Taco Cloud thay mặt cho người dùng đã ủy quyền cho ứng dụng.

Chapter 09 - Sending messages
Asynchronously

This chapter covers
 Asynchronous messaging
 Sending messages with JMS, RabbitMQ,
and Kafka
 Pulling messages from a broker
 Listening for messages

Là 4:55 chiều vào thứ Sáu. Bạn chỉ còn vài phút nữa để bắt đầu kỳ nghỉ mong chờ từ lâu. Bạn có đủ thời gian để lái xe đến sân bay và bắt chuyến bay của mình. Nhưng trước khi gói hành lý và rời đi, bạn cần đảm bảo rằng sếp và đồng nghiệp của bạn biết tình trạng công việc mà bạn đã làm, để vào thứ Hai họ có thể tiếp tục từ nơi bạn đã dừng lại. Thật không may, một số đồng nghiệp của bạn đã rời khỏi nơi làm việc để bắt đầu cuối tuần, và sếp của bạn đang bận trong một cuộc họp. Bạn sẽ làm gì?

Cách tiếp cận thực tế nhất để thông báo tình trạng của bạn và vẫn kịp thời gian chuyến bay là gửi một email nhanh cho sếp và đồng nghiệp của bạn, mô tả tiến độ của bạn và hứa sẽ gửi một bức thiếp sau. Bạn không biết họ đang ở đâu hoặc khi nào họ sẽ đọc email, nhưng bạn biết rằng họ sẽ cuối cùng quay trở lại bàn làm việc và đọc nó. Trong khi đó, bạn đang trên đường đến sân bay.

Giao tiếp đồng bộ - Synchronous communication, như chúng ta đã thấy với REST, có đúng đắn của nó. Nhưng nó không phải là duy nhất phong cách giao tiếp giữa ứng dụng mà nhà phát triển có sẵn. Tin nhắn không đồng bộ là một cách gửi tin nhắn gián tiếp từ một ứng dụng sang ứng dụng khác mà không cần đợi phản hồi. Sự gián đoạn này mang lại sự kết nối lỏng lẻo và khả năng mở rộng lớn hơn giữa các ứng dụng đang giao tiếp.

Trong chương này, chúng ta sẽ sử dụng tin nhắn không đồng bộ để gửi đơn đặt hàng từ trang web Taco Cloud đến một ứng dụng riêng biệt trong nhà bếp của Taco Cloud, nơi các chiếc taco sẽ được chuẩn bị. Chúng ta sẽ xem xét ba lựa chọn mà Spring cung cấp cho tin nhắn không đồng bộ - asynchronous messaging: Java Message Service (JMS), RabbitMQ và Advanced Message Queueing Protocol (AMQP), và Apache Kafka. Ngoài việc gửi và nhận tin nhắn cơ bản, chúng ta sẽ xem xét sự hỗ trợ của Spring cho POJO được định hình bởi tin nhắn: một cách nhận tin nhắn giống như Enterprise JavaBeans' message-driven beans (MDBs).

9.1 Sending messages with JMS

JMS là một tiêu chuẩn Java định nghĩa một API chung để làm việc với các trình điều khiển tin nhắn. Được giới thiệu lần đầu vào năm 2001, JMS đã trở thành phương pháp tiếp cận tiêu biểu cho giao tiếp không đồng bộ trong Java trong một khoảng thời gian rất dài. Trước khi có JMS, mỗi trình điều khiển tin nhắn đều có một API độc quyền, làm cho mã giao tiếp tin nhắn của ứng dụng ít có khả năng di động giữa các trình điều khiển. Nhưng với JMS, tất cả các phiên bản tuân thủ có thể làm việc thông qua một giao diện chung, giống như JDBC đã đưa ra một giao diện chung cho các hoạt động cơ sở dữ liệu quan hệ.
Spring hỗ trợ JMS thông qua một sự trừu tượng dựa trên template được biết đến là JmsTemplate. Sử dụng JmsTemplate, việc gửi messages qua các hàng đợi và chủ đề từ phía producers và nhận những tin nhắn đó từ phía consumers trở nên dễ dàng. Spring cũng hỗ trợ khái niệm của message-driven POJOs: các đối tượng Java đơn giản phản ứng với messages đến trên một hàng đợi hoặc chủ đề một cách bất đồng bộ asynchronous.
Chúng ta sẽ khám phá sự hỗ trợ của Spring cho JMS, bao gồm JmsTemplate và POJO định hình bởi tin nhắn. Trọng tâm của chúng ta sẽ là sự hỗ trợ của Spring cho giao tiếp bằng JMS, nhưng nếu bạn muốn biết thêm về JMS, hãy tham khảo ActiveMQ in Action của Bruce Snyder, Dejan Bosanac và Rob Davies (Manning, 2011).
Trước khi bạn có thể send and receive messages, bạn cần một message broker đã sẵn sàng để truyền tải những messages đó giữa producers và consumers.. Hãy bắt đầu cuộc khám phá của chúng ta về Spring JMS bằng cách thiết lập một message broker trong Spring.
9.1.1 Setting up JMS

Trước khi bạn có thể sử dụng JMS, bạn phải thêm một client JMS vào dự án của mình. Với Spring Boot, điều này không thể đơn giản hơn. Bạn chỉ cần thêm một phụ thuộc khởi đầu vào bản dựng. Tuy nhiên, trước hết, bạn phải quyết định liệu bạn sẽ sử dụng Apache ActiveMQ hay trình điều khiển tin nhắn mới hơn là Apache ActiveMQ Artemis.
Nếu bạn đang sử dụng ActiveMQ, bạn cần thêm phụ thuộc sau vào tệp pom.xml của dự án của bạn:
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
Nếu bạn chọn ActiveMQ Artemis, phụ thuộc khởi đầu sẽ trông như sau:
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-artemis</artifactId>
</dependency>

Artemis là một sự triển khai lại hệ thống của ActiveMQ thế hệ tiếp theo, làm cho ActiveMQ trở thành một lựa chọn kế thừa. Do đó, đối với Taco Cloud, bạn sẽ chọn Artemis. Tuy nhiên, sự lựa chọn này cuối cùng chỉ ảnh hưởng ít đến cách bạn viết mã để gửi và nhận tin nhắn. Sự khác biệt đáng kể duy nhất sẽ nằm ở cách bạn cấu hình Spring để tạo kết nối đến trình điều khiển tin nhắn.

RUNNING AN ARTEMIS BROKER Bạn sẽ cần có một Artemis broker đang chạy để có thể chạy mã mà chúng tôi trình bày trong chương này. Nếu bạn chưa có một phiên bản Artemis đang chạy, bạn có thể làm theo hướng dẫn từ tài liệu Artemis tại http://mng.bz/Xr81.

Mặc định, Spring cho rằng Artemis broker của bạn đang lắng nghe trên localhost ở cổng 61616. Điều này thích hợp cho mục đích phát triển, nhưng khi bạn đã sẵn sàng triển khai ứng dụng của mình, bạn sẽ cần thiết lập một số thuộc tính để thông báo cho Spring cách truy cập broker. Các thuộc tính mà bạn sẽ thấy hữu ích nhất được liệt kê trong bảng 9.1.

 


Ví dụ, hãy xem một mục sau từ tệp application.yml có thể được sử dụng trong một môi trường không phải là phát triển:

spring:
   artemis:
     host: artemis.tacocloud.com
     port: 61617
     user: tacoweb
     password: l3tm31n

Điều này cấu hình Spring để tạo kết nối đến một trình điều khiển Artemis đang lắng nghe tại artemis.tacocloud.com, cổng 61617. Nó cũng đặt thông tin đăng nhập cho ứng dụng sẽ tương tác với trình điều khiển đó. Thông tin đăng nhập là tùy chọn, nhưng nó được khuyến khích đối với triển khai sản xuất.

Nếu bạn sử dụng ActiveMQ thay vì Artemis, bạn sẽ cần sử dụng các thuộc tính cụ thể cho ActiveMQ được liệt kê trong bảng 9.2.
 

Lưu ý rằng thay vì cung cấp các thuộc tính riêng biệt cho hostname và port của broker, địa chỉ của một trình điều khiển ActiveMQ được chỉ định bằng một thuộc tính duy nhất, đó là spring.activemq.broker-url. URL này nên là một URL tcp://, như được thể hiện trong đoạn YAML sau:

spring:
   activemq:
     broker-url: tcp://activemq.tacocloud.com
     user: tacoweb
     password: l3tm31n

9.1.2 Sending messages with JmsTemplate

Với phụ thuộc starter JMS (cả Artemis và ActiveMQ) trong dự án, Spring Boot sẽ tự động cấu hình một JmsTemplate (cùng với những thứ khác) mà bạn có thể inject và sử dụng để gửi và nhận message.

JmsTemplate là trung tâm của sự hỗ trợ tích hợp JMS của Spring. Giống như các thành phần khác trong Spring hướng mẫu, JmsTemplate loại bỏ nhiều mã mẫu nếu không sẽ cần thiết để làm việc với JMS. Nếu không có JmsTemplate, bạn sẽ cần viết mã để tạo kết nối và phiên với message broker và thêm mã để xử lý bất kỳ ngoại lệ nào có thể xảy ra trong quá trình gửi một tin nhắn. JmsTemplate tập trung vào điều bạn thực sự muốn làm: gửi một tin nhắn.

JmsTemplate có một số phương thức hữu ích cho việc gửi tin nhắn, bao gồm các phương thức sau:

// Send raw messages
void send(MessageCreator messageCreator) throws JmsException;
void send(Destination destination, MessageCreator messageCreator)
throws JmsException;
void send(String destinationName, MessageCreator messageCreator)
throws JmsException;

// Send messages converted from objects
void convertAndSend(Object message) throws JmsException;
void convertAndSend(Destination destination, Object message)
throws JmsException;
void convertAndSend(String destinationName, Object message)
throws JmsException;

// Send messages converted from objects with post-processing
void convertAndSend(Object message, MessagePostProcessor postProcessor) 
throws JmsException;
void convertAndSend(Destination destination, Object message,
MessagePostProcessor postProcessor) throws JmsException;
void convertAndSend(String destinationName, Object message,
MessagePostProcessor postProcessor) throws JmsException;

Như bạn có thể thấy, thực sự chỉ có hai phương thức, là send() và convertAndSend(), mỗi cái đều được ghi đè để hỗ trợ các tham số khác nhau. Nếu bạn nhìn kỹ hơn, bạn sẽ nhận thấy rằng các hình thức khác nhau của convertAndSend() có thể được chia thành hai loại con. Để hiểu rõ về những phương thức này làm gì, hãy xem xét phân chia sau đây:

- Ba phương thức send() yêu cầu một MessageCreator để sản xuất một đối tượng Message.
- Ba phương thức convertAndSend() chấp nhận một Object và tự động chuyển đổi đối tượng đó thành một Message ngầm đằng sau.
- Ba phương thức convertAndSend() tự động chuyển đổi một Object thành một Message nhưng cũng chấp nhận một MessagePostProcessor để cho phép tùy chỉnh của Message trước khi gửi.

Hơn nữa, mỗi trong ba loại phương thức này bao gồm ba phương thức ghi đè được phân biệt bằng cách cách mà đích JMS (hàng đợi hoặc chủ đề) được chỉ định, như sau:

- Một phương thức không chấp nhận tham số đích destination và gửi tin nhắn đến một đích mặc định.
- Một phương thức chấp nhận một đối tượng Destination để chỉ định đích cho tin nhắn.
- Một phương thức chấp nhận một chuỗi để chỉ định tên của đích destinationName cho tin nhắn.

Đặt những phương thức này vào công việc, hãy xem xét JmsOrderMessagingService trong đoạn mã tiếp theo, sử dụng dạng cơ bản nhất của phương thức send().

package tacos.messaging;

import tacos.TacoOrder;

public interface OrderMessagingService {
    void sendOrder(TacoOrder order);
}

@Service
public class JmsOrderMessagingService implements OrderMessagingService{
    private JmsTemplate jms;

    @Autowired
    public JmsOrderMessagingService(JmsTemplate jms) {
        this.jms = jms;
    }

    @Override
    public void sendOrder(TacoOrder order) {
        jms.send(new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createObjectMessage(order);
            }
        });
//        jms.send(session -> session.createMessage(order));
    }

}

Phương thức `sendOrder()` gọi `jms.send()`, truyền vào một triển khai của lớp ẩn danh (anonymous inner-class) của MessageCreator. Triển khai này ghi đè phương thức `createMessage()` để tạo một đối tượng message mới từ đối tượng TacoOrder được cung cấp.
Do lớp cụ thể của JMS JmsOrderMessagingService triển khai giao diện OrderMessagingService chung hơn, chúng ta có thể đưa dịch vụ này vào hoạt động bằng cách tiêm (inject) nó vào trong OrderApiController và gọi sendOrder() khi một đơn hàng được tạo, như được thể hiện ở đây:

@RestController
@RequestMapping(path = "/api/orders", produces = "application/json")
@CrossOrigin(origins = "http://localhost:8080")
public class OrderApiController {

    private OrderRepository repo;
    private OrderMessagingService messageService;

    public OrderApiController(OrderRepository repo,
                              OrderMessagingService messageService) {
        this.repo = repo;
        this.messageService = messageService;
    }

    @PostMapping(consumes = "application/json")
    @ResponseStatus(HttpStatus.CREATED)
    public TacoOrder postOrder(@RequestBody TacoOrder order) {
        messageService.sendOrder(order);
        return repo.save(order);
    }

    // ...
}

Bây giờ khi bạn tạo một đơn hàng qua trang web của Taco Cloud, một tin nhắn nên được gửi đến trình điều khiển (broker) để định tuyến đến một ứng dụng khác sẽ nhận đơn hàng. Tuy nhiên, chúng ta vẫn chưa có gì để nhận tin nhắn đó. Tuy nhiên, bạn có thể sử dụng bảng Artemis broker để xem nội dung của hàng đợi. Xem tài liệu Artemis tại http://mng.bz/aZx9 để biết chi tiết về cách thực hiện điều này.

Nhưng lưu ý rằng cuộc gọi tới jms.send() không chỉ định một địa điểm đích. Để làm việc này, bạn cũng phải chỉ định tên địa điểm mặc định với thuộc tính `spring.jms.template.default-destination`. Ví dụ, bạn có thể đặt thuộc tính này trong tệp application.yml của bạn như sau:

spring:
  artemis:
    broker-url: http://localhost:8161
    user: root
    password: 123456
  jms:
    template:
      default-destination: tacocloud.order.queue

Trong nhiều trường hợp, việc sử dụng một địa điểm mặc định là lựa chọn dễ nhất. Nó cho phép bạn chỉ định tên địa điểm một lần, giúp mã chỉ quan tâm đến việc gửi tin nhắn, mà không cần quan tâm nơi chúng được gửi đến. Nhưng nếu bạn bao giờ cần gửi một tin nhắn đến một địa điểm khác ngoài địa điểm mặc định, bạn sẽ cần chỉ định địa điểm đó như một tham số cho phương thức `send()`.

Một cách để làm điều này là bằng cách truyền một đối tượng `Destination` như là tham số đầu tiên cho `send()`. Cách đơn giản nhất để làm điều này là khai báo một bean `Destination` và sau đó tiêm nó vào bean thực hiện gửi tin nhắn. Ví dụ, bean sau đây khai báo `Destination` cho hàng đợi đơn hàng của Taco Cloud:
import org.apache.activemq.artemis.jms.client.ActiveMQQueue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.jms.Destination;

@Configuration
public class MessagingConfig {

    @Bean
    public Destination orderQueue() {
        return new ActiveMQQueue("tacocloud.order.queue");
    }
}

Phương thức bean này có thể được thêm vào bất kỳ lớp cấu hình nào trong ứng dụng sẽ gửi hoặc nhận tin nhắn qua JMS. Để có tổ chức tốt nhất, nên thêm nó vào một lớp cấu hình được chỉ định cho cấu hình tin nhắn, chẳng hạn như `MessagingConfig`.

Quan trọng để lưu ý rằng `ActiveMQQueue` được sử dụng ở đây thực sự là từ Artemis (từ gói `org.apache.activemq.artemis.jms.client`). Nếu bạn đang sử dụng ActiveMQ (không phải Artemis), cũng có một lớp có tên là `ActiveMQQueue` (từ gói `org.apache.activemq.command`). Nếu bean `Destination` này được tiêm vào `JmsOrderMessagingService`, bạn có thể sử dụng nó để chỉ định địa điểm khi gọi `send()` như sau:

@Service
public class JmsOrderMessagingService implements OrderMessagingService{
    private JmsTemplate jms;
    private Destination orderQueue;

    @Autowired
    public JmsOrderMessagingService(JmsTemplate jms, Destination orderQueue) {
        this.jms = jms;
        this.orderQueue = orderQueue;
    }

    @Override
    public void sendOrder(TacoOrder order) {
        jms.send(
                orderQueue,
                session -> session.createObjectMessage(order));
    }

}


Việc chỉ định địa điểm với một đối tượng `Destination` như vậy mang lại cho bạn cơ hội để cấu hình `Destination` với nhiều thông tin hơn chỉ là tên địa điểm. Tuy nhiên, trong thực tế, bạn hầu như không bao giờ chỉ định bất cứ điều gì ngoài tên địa điểm. Thường thì dễ hơn là chỉ đơn giản gửi tên như là tham số đầu tiên cho `send()`, như được hiển thị ở đây:

@Override
public void sendOrder(TacoOrder order) {
    jms.send(
            "tacocloud.order.queue",
            session -> session.createObjectMessage(order));
}

Mặc dù phương thức send() không quá khó sử dụng (đặc biệt là khi MessageCreator được đưa ra dưới dạng lambda), một chút phức tạp được thêm vào bằng việc yêu cầu bạn cung cấp một MessageCreator. Liệu có đơn giản hơn nếu bạn chỉ cần chỉ định đối tượng sẽ được gửi (và tùy chọn là đích đến)? Điều này mô tả một cách ngắn gọn cách convertAndSend() hoạt động. Hãy xem xét:

CONVERTING MESSAGES BEFORE SENDING

Phương thức JmsTemplatesconvertAndSend() đơn giản hóa việc xuất bản tin nhắn bằng cách loại bỏ nhu cầu cung cấp một MessageCreator. Thay vào đó, bạn truyền đối tượng sẽ được gửi trực tiếp vào convertAndSend(), và đối tượng đó sẽ được chuyển đổi thành một Message trước khi được gửi đi.
Ví dụ, việc triển khai lại của phương thức sendOrder() sau sử dụng convertAndSend() để gửi một TacoOrder đến một đích đặt tên là như sau:
@Override
public void sendOrder(TacoOrder order) {
    jms.convertAndSend(orderQueue, order);
}

Tương tự như phương thức send(), convertAndSend() cũng sẽ chấp nhận cả một Destination hoặc giá trị String để chỉ định đích đến, hoặc bạn có thể bỏ qua đích đến hoàn toàn để gửi tin nhắn đến đích mặc định.
Bất kỳ hình thức nào của convertAndSend() bạn chọn, đối tượng TacoOrder được truyền vào convertAndSend() sẽ được chuyển đổi thành một Message trước khi được gửi đi. Dưới bề mặt, điều này được thực hiện thông qua một triển khai của MessageConverter thực hiện công việc chuyển đổi đối tượng miền ứng dụng thành đối tượng Message.
CONFIGURING A MESSAGE CONVERTER

MessageConverter là một interface được định nghĩa bởi Spring chỉ có hai phương thức sau đây cần được triển khai:

public interface MessageConverter {
    Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;

    Object fromMessage(Message message) throws JMSException, MessageConversionException;
}

Mặc dù giao diện này đơn giản đủ để triển khai, nhưng thường thì bạn sẽ không cần tạo một triển khai tùy chỉnh. Spring đã cung cấp sẵn một số triển khai, như những cái mô tả trong bảng 9.3.

Message converter	What it does
MappingJackson2MessageConverter	Sử dụng thư viện Jackson 2 JSON để chuyển đổi messages ↔ JSON
MarshallingMessageConverter	Sử dụng JAXB (Java Architecture for XML Binding) để chuyển đổi Message ↔ XML
MessagingMessageConverter	Chuyển đổi một Message từ messaging abstraction ↔ Message bằng cách sử dụng một MessageConverter cơ bản cho dữ liệu và một JmsHeaderMapper để ánh xạ các Header JMS ↔  Header standard message.
SimpleMessageConverter	Chuyển đổi một String ↔ TextMessage, byte arrays ↔ BytesMessage, một Map ↔ MapMessage, và một Serializable ↔ ObjectMessage

SimpleMessageConverter là giá trị mặc định, nhưng nó yêu cầu đối tượng được gửi phải triển khai Serializable. Điều này có thể là một ý tưởng tốt, nhưng bạn có thể muốn sử dụng một trong những bộ chuyển đổi thông điệp khác, chẳng hạn như MappingJackson2MessageConverter, để tránh ràng buộc đó.

Để áp dụng một bộ chuyển đổi thông điệp khác, bạn chỉ cần khai báo một phiên bản của bộ chuyển đổi được chọn như là một bean. Ví dụ, khai báo bean sau sẽ cho phép MappingJackson2MessageConverter được sử dụng thay vì SimpleMessageConverter:

@Configuration
public class MessagingConfig {

    @Bean
    public MappingJackson2MessageConverter messageConverter() {
        MappingJackson2MessageConverter messageConverter =
                new MappingJackson2MessageConverter();
        messageConverter.setTypeIdPropertyName("_typeId");
        return messageConverter;
    }

    // …

Phương thức bean này có thể được đặt trong bất kỳ lớp cấu hình nào trong ứng dụng có gửi và nhận tin nhắn với JMS, bao gồm cả cùng với bean Destination trong MessagingConfig.

Lưu ý rằng bạn đã gọi setTypeIdPropertyName() trên MappingJackson2MessageConverter trước khi trả về nó. Điều này rất quan trọng, vì nó cho phép bên nhận receiver biết được type cần chuyển đổi một tin nhắn đến. Theo mặc định, nó sẽ chứa tên đầy đủ của lớp đang được chuyển đổi. Nhưng phương thức này hơi cứng nhắc một chút, yêu cầu receiver cũng phải có cùng loại, với tên đầy đủ lớp giống nhau.

Để tạo ra tính linh hoạt hơn, bạn có thể ánh xạ một type name tổng hợp với loại thực sự bằng cách gọi setTypeIdMappings() trên message converter. Ví dụ, thay đổi sau đây trong phương thức bean của message converter ánh xạ một ID loại TacoOrder tổng hợp với lớp TacoOrder:

// Flexibility
public MappingJackson2MessageConverter messageConverter() {
    MappingJackson2MessageConverter messageConverter =
            new MappingJackson2MessageConverter();
    messageConverter.setTypeIdPropertyName("_typeId");
    Map<String, Class<?>> typeIdMappings = new HashMap<>();
    typeIdMappings.put("order", TacoOrder.class);
    messageConverter.setTypeIdMappings(typeIdMappings);

    return messageConverter;
}

Thay vì gửi đầy đủ của classname trong thuộc tính _typeId của message, giá trị TacoOrder sẽ được gửi. Trong ứng dụng nhận, một message converter tương tự sẽ đã được cấu hình, ánh xạ TacoOrder với sự hiểu biết riêng của nó về một đơn hàng là gì. Implementation của order có thể ở trong một gói khác, có một tên khác, và thậm chí có một tập con của các thuộc tính của TacoOrder của bên gửi.

POSTPROCESSING MESSAGES

Hãy giả sử rằng ngoài kinh doanh trực tuyến có lợi nhuận, Taco Cloud đã quyết định mở một số cửa hàng bán taco truyền thống. Vì bất kỳ nhà hàng nào của họ cũng có thể là một trung tâm đáp ứng đơn hàng cho kinh doanh trực tuyến, họ cần một cách để giao tiếp nguồn gốc của một đơn hàng đến những nhà bếp tại các nhà hàng. Điều này sẽ cho phép nhân viên nhà bếp sử dụng một quy trình khác cho đơn đặt hàng từ cửa hàng so với đơn đặt hàng trực tuyến.

Một giải pháp hợp lý là thêm một thuộc tính source mới vào đối tượng TacoOrder để mang thông tin này, điền giá trị WEB cho các đơn đặt hàng được đặt trực tuyến và giá trị STORE cho các đơn đặt hàng được đặt trong cửa hàng. Nhưng điều này sẽ yêu cầu một sự thay đổi cả trong lớp TacoOrder của trang web và lớp TacoOrder của ứng dụng nhà bếp khi thực tế chỉ cần thông tin này cho người chuẩn bị taco.

Một giải pháp dễ dàng hơn là thêm một custom header vào tin nhắn để mang thông tin source của đơn đặt hàng. Nếu bạn đang sử dụng phương thức send() để gửi các taco orders, điều này có thể dễ dàng thực hiện bằng cách gọi setStringProperty() trên đối tượng Message như sau:

Vấn đề ở đây là bạn không sử dụng phương thức send(). Bằng cách chọn sử dụng convertAndSend(), đối tượng Message được tạo ra tự động, và bạn không có quyền truy cập vào nó. May mắn thay, bạn có cách để điều chỉnh một Message được tạo ra tự động trước khi nó được gửi đi. Bằng cách truyền vào một MessagePostProcessor làm tham số cuối cùng cho convertAndSend(), bạn có thể thực hiện bất cứ điều gì với Message sau khi nó đã được tạo ra. Đoạn mã sau vẫn sử dụng convertAndSend(), nhưng cũng sử dụng một MessagePostProcessor để thêm tiêu đề X_ORDER_SOURCE vào trước khi tin nhắn được gửi đi:

@Override
public void sendOrder(TacoOrder order) {
    jms.convertAndSend(orderQueue, order
            , message -> {
                message.setStringProperty("X_ORDER_SOURCE", "WEB");
                return message;
            });
}
Mặc dù bạn chỉ cần MessagePostProcessor cụ thể này cho một lời gọi convertAndSend() này, nhưng có thể bạn sẽ thấy mình đang sử dụng cùng một MessagePostProcessor cho nhiều lời gọi convertAndSend() khác nhau. Trong những trường hợp đó, có thể một tham chiếu phương thức method references, như được hiển thị dưới đây, là một lựa chọn tốt hơn so với một lambda, tránh việc trùng lặp mã không cần thiết.

Method References -> Method for lambda -> biến lambda thành phương thức và dùng nhiều lần

@Override
public void sendOrder(TacoOrder order) {
    jms.convertAndSend("tacocloud.order.queue", order
            , this::addOrderSource);
}

private Message addOrderSource(Message message) throws JMSException {
    message.setStringProperty("X_ORDER_SOURCE", "WEB");
    return message;
}

Bạn đã thấy một số cách để gửi tin nhắn. Nhưng việc gửi một tin nhắn không có ý nghĩa nếu không có ai nhận nó. Hãy xem cách bạn có thể nhận tin nhắn với Spring JMS.

9.1.3 Receiving JMS messages

Khi đến việc tiêu thụ tin nhắn, bạn có sự lựa chọn giữa một mô hình kéo, trong đó mã của bạn yêu cầu một tin nhắn và đợi cho đến khi một tin nhắn được gửi đến, hoặc một mô hình đẩy, trong đó tin nhắn được chuyển đến mã của bạn khi chúng có sẵn.

JmsTemplate cung cấp một số phương thức để nhận tin nhắn, nhưng tất cả đều sử dụng một mô hình kéo. Bạn gọi một trong những phương thức đó để yêu cầu một tin nhắn và luồng sẽ bị chặn cho đến khi có một tin nhắn sẵn có (có thể ngay lập tức hoặc có thể mất một thời gian).

Ngược lại, bạn cũng có khả năng sử dụng mô hình đẩy, trong đó bạn xác định một bộ lắng nghe tin nhắn được gọi mọi khi một tin nhắn sẵn có.

Cả hai lựa chọn đều phù hợp cho nhiều trường hợp sử dụng. Thông thường được chấp nhận rằng mô hình đẩy là lựa chọn tốt nhất, vì nó không chặn một luồng. Nhưng trong một số trường hợp sử dụng, một bộ lắng nghe có thể quá tải nếu tin nhắn đến quá nhanh. Mô hình kéo cho phép một người tiêu thụ thông báo rằng họ đã sẵn sàng xử lý một tin nhắn mới.

Hãy xem cả hai cách nhận tin nhắn. Chúng ta sẽ bắt đầu với mô hình kéo được cung cấp bởi JmsTemplate.

RECEIVING WITH JMSTEMPLATE

JmsTemplate cung cấp một số phương thức để rút tin nhắn từ broker, bao gồm các phương thức sau:



Message receive() throws JmsException;
Message receive(Destination destination) throws JmsException;
Message receive(String destinationName) throws JmsException;
Object receiveAndConvert() throws JmsException;
Object receiveAndConvert(Destination destination) throws JmsException;
Object receiveAndConvert(String destinationName) throws JmsException;

Như bạn thấy, sáu phương thức này tương ứng với các phương thức send() và convertAndSend() từ JmsTemplate. Các phương thức receive() nhận một Message nguyên thủy, trong khi các phương thức receiveAndConvert() sử dụng một message converter được cấu hình để chuyển đổi message thành các loại domain . Và đối với mỗi trong số chúng, bạn có thể chỉ định hoặc một Destination hoặc một destinationName, hoặc bạn có thể rút một tin nhắn từ đích mặc định.

Để xem chúng hoạt động, bạn sẽ viết một số mã rút một TacoOrder từ đích tacocloud.order.queue. Dưới đây là một ví dụ về OrderReceiver, một component Service nhận dữ liệu đơn hàng bằng cách sử dụng JmsTemplate.receive():

Listing 9.2 Pulling orders from a queue 
@Component
public class JmsOrderReceiver implements OrderReceiver {
    private JmsTemplate jms;
    private MessageConverter converter;

    private Destination orderQueue;

    @Autowired
    public JmsOrderReceiver(JmsTemplate jms, MessageConverter converter
            , Destination orderQueue) {
        this.jms = jms;
        this.converter = converter;
        this.orderQueue = orderQueue;
    }

    @Override
    public TacoOrder receiveOrder() {
        Message message = jms.receive(orderQueue);
        return (TacoOrder) converter.fromMessage(message);
    }
}

Ở đây, bạn đã sử dụng một chuỗi để chỉ định destinationName lấy một đơn đặt hàng. Phương thức receive() trả về một Message chưa được chuyển đổi. Nhưng điều bạn thực sự cần là đối tượng TacoOrder nằm bên trong Message, vì vậy ngay lập tức sau đó, bạn sử dụng một message converter được chèn để chuyển đổi message. Thuộc tính type ID trong message sẽ hướng dẫn converter chuyển đổi nó thành một TacoOrder, nhưng nó được trả về dưới dạng một Object đòi hỏi phải ép kiểu trước khi bạn có thể trả về nó.

Việc nhận một đối tượng Message nguyên thủy có thể hữu ích trong một số trường hợp nơi bạn cần kiểm tra các thuộc tính và tiêu đề của message. Nhưng thường thì bạn chỉ cần dữ liệu của gói tin. Chuyển đổi gói tin đó thành một loại domain là một quy trình hai bước và yêu cầu message converter được chèn vào component. Khi bạn chỉ quan tâm đến dữ liệu của message, phương thức receiveAndConvert() đơn giản hơn nhiều. Đoạn mã dưới đây cho thấy cách JmsOrderReceiver có thể được sửa lại để sử dụng receiveAndConvert() thay vì receive():

Listing 9.3 Receiving an already-converted TacoOrder object 
// Trường hợp tối giản chỉ cần dữ liệu domain
@Override
public TacoOrder receiveOrder() throws JMSException {
    return (TacoOrder) jms.receiveAndConvert(orderQueue);
}

Phiên bản mới của JmsOrderReceiver có một phương thức receiveOrder() đã được giảm xuống chỉ còn một dòng. Ngoài ra, bạn không còn cần phải chèn một MessageConverter, vì toàn bộ quá trình chuyển đổi tin nhắn sẽ được thực hiện tự động trong receiveAndConvert().

Trước khi tiếp tục, hãy xem xét cách receiveOrder() có thể được sử dụng trong ứng dụng nhà bếp của Taco Cloud. Một người chuẩn bị thức ăn tại một trong những nhà bếp của Taco Cloud có thể nhấn một nút hoặc thực hiện một số hành động để chỉ định rằng họ đã sẵn sàng bắt đầu làm tacos. Tại thời điểm đó, receiveOrder() sẽ được gọi và cuộc gọi tới receive() hoặc receiveAndConvert() sẽ bị chặn. Không có gì khác sẽ xảy ra cho đến khi một tin đặt hàng sẵn sàng. Khi một đơn đặt hàng đến, nó sẽ được trả về từ receiveOrder(), và thông tin của nó sẽ được sử dụng để hiển thị chi tiết đơn đặt hàng cho người chuẩn bị thức ăn để bắt đầu công việc. Điều này dường như là một lựa chọn tự nhiên cho mô hình kéo.

Bây giờ hãy xem cách mô hình đẩy hoạt động bằng cách khai báo một listener JMS.

DECLARING MESSAGE LISTENERS

Khác với mô hình kéo, nơi cần phải có một cuộc gọi rõ ràng tới receive() hoặc receiveAndConvert() để nhận một tin nhắn, một message listener là một thành phần chủ động đang ở trạng thái không hoạt động cho đến khi có một message đến.

Để tạo một message listener phản ứng với message JMS, bạn chỉ cần đánh dấu một phương thức trong một thành phần với @JmsListener. Đoạn mã dưới đây cho thấy một thành phần mới là OrderListener lắng nghe passively cho các tin nhắn, thay vì yêu cầu một cách tích cực.

@Profile("jms-listener")
@Component
public class OrderListener {

    private KitchenUI ui;

    @Autowired
    public OrderListener(KitchenUI ui) {
        this.ui = ui;
    }

    @JmsListener(destination = "tacocloud.order.queue")
    public void receiveOrder(TacoOrder order) {
        ui.displayOrder(order);
    }
}

@Component
@Slf4j
public class KitchenUI {
    public void displayOrder(TacoOrder order) {
        log.info("RECEIVE ORDER: " + order);
    }
}

Phương thức receiveOrder() được đánh dấu bằng @JmsListener để "lắng nghe" các message trên đích "tacocloud.order.queue". Nó không xử lý JmsTemplate, cũng không được gọi rõ ràng bởi mã ứng dụng của bạn. Thay vào đó, mã khung làm việc trong Spring đợi tin nhắn đến đích được chỉ định, và khi chúng đến, phương thức receiveOrder() được tự động gọi với dữ liệu TacoOrder của tin nhắn như một tham số.

Trong nhiều trường hợp, chú thích @JmsListener tương tự như một trong các chú thích request mapping của Spring MVC, như @GetMapping hoặc @PostMapping. Trong Spring MVC, các phương thức được chú thích bằng một trong các phương thức request mapping phản ứng với các yêu cầu đến một url cụ thể. Tương tự, các phương thức được chú thích bằng @JmsListener phản ứng với các message đến trên một đích.

Message Listener thường được quảng cáo là lựa chọn tốt nhất vì chúng không chặn và có thể xử lý nhanh chóng nhiều tin nhắn. Tuy nhiên, trong ngữ cảnh của ứng dụng Taco Cloud, có lẽ chúng không phải là lựa chọn tốt nhất. Người chuẩn bị thức ăn là một chướng ngại lớn trong hệ thống và có thể không thể chuẩn bị tacos nhanh chóng như đơn đặt hàng đến. Một người chuẩn bị thức ăn có thể đã chuẩn bị một nửa đơn đặt hàng khi một đơn đặt hàng mới được hiển thị trên màn hình. Kitchen UI sẽ cần lưu đơn đặt hàng khi chúng đến để tránh quá tải nhân viên nhà bếp.

Điều này không phải là nói rằng bộ lắng nghe tin nhắn là không tốt. Ngược lại, chúng là sự kết hợp hoàn hảo khi các tin nhắn có thể được xử lý nhanh chóng. Nhưng khi các xử lý tin nhắn cần có khả năng yêu cầu thêm tin nhắn theo đúng định kỳ của họ, mô hình kéo được cung cấp bởi JmsTemplate có vẻ phù hợp hơn.

Do JMS được định nghĩa bởi một đặc tả Java tiêu chuẩn và được hỗ trợ bởi nhiều triển khai message broker, nó là sự lựa chọn phổ biến cho việc gửi tin nhắn trong Java. Tuy nhiên, JMS có một số hạn chế, không kém phần quan trọng là vì là một đặc tả Java, sự sử dụng của nó giới hạn trong các ứng dụng Java. Các tùy chọn gửi tin nhắn mới hơn như RabbitMQ và Kafka giải quyết những hạn chế này và có sẵn cho các ngôn ngữ và nền tảng khác ngoài JVM. Hãy để JMS sang một bên và xem làm thế nào bạn có thể triển khai việc gửi tin nhắn đơn đặt hàng taco của mình với RabbitMQ.

9.3 Messaging with Kafka

Apache Kafka là lựa chọn mới nhất về message chúng ta đang xem xét trong chương này. Một cái nhìn nhanh, Kafka là một message broker giống như ActiveMQ, Artemis hoặc RabbitMQ. Nhưng Kafka có một số mánh khóe độc đáo.

Kafka được thiết kế để chạy trong một cụm (cluster), mang lại khả năng mở rộng lớn. Và bằng cách phân vùng các chủ đề của mình trên tất cả các instance trong cluster, nó rất linh hoạt. Trong khi RabbitMQ chủ yếu xử lý với hàng đợi trong các sàn, Kafka chỉ sử dụng topics để cung cấp công bố/đăng ký (pub/sub) message.
Kafka topics được sao chép trên tất cả các brokers in the cluster. Mỗi node trong cluster đóng vai trò là một nhà lãnh đạo cho một hoặc nhiều topic, chịu trách nhiệm cho topic data đó và sao chép nó đến các nút khác trong cụm.
Điều tiến xa hơn, mỗi topic có thể được chia thành nhiều phân vùng. Trong trường hợp đó, mỗi nút trong cụm là nhà lãnh đạo cho một hoặc nhiều phân vùng của một chủ đề, nhưng không phải cho toàn bộ chủ đề. Trách nhiệm cho chủ đề được chia ra trên tất cả các nút. Hình 9.3 minh họa cách điều này hoạt động.

 
9.3.1 Setting up Spring for Kafka messaging

Để bắt đầu sử dụng Kafka cho tin nhắn, bạn sẽ cần thêm các phụ thuộc phù hợp vào dự án của mình. Tuy nhiên, khác với các tùy chọn JMS và RabbitMQ, không có một Spring Boot starter cụ thể cho Kafka. Tuy nhiên, đừng lo lắng; bạn chỉ cần một phụ thuộc, được hiển thị dưới đây:

<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

Một phụ thuộc này mang đến tất cả những gì bạn cần cho Kafka trong dự án. Hơn nữa, sự hiện diện của nó sẽ kích hoạt tự động cấu hình của Spring Boot cho Kafka, sẽ, giữa những thứ khác, sắp xếp một KafkaTemplate trong ngữ cảnh ứng dụng Spring.
Tất cả những gì bạn cần làm là tiêm KafkaTemplate và bắt đầu gửi và nhận các tin nhắn.
Trước khi bạn bắt đầu gửi và nhận các tin nhắn, tuy nhiên, bạn nên biết về một số thuộc tính sẽ hữu ích khi làm việc với Kafka. Cụ thể, Kafka-Template mặc định để làm việc với một broker Kafka trên localhost, lắng nghe trên cổng 9092.
Việc khởi động một broker Kafka cục bộ khi phát triển một ứng dụng là hoàn toàn hợp lý, nhưng khi đến lúc triển khai vào môi trường sản xuất, bạn sẽ cần cấu hình một máy chủ và cổng khác.

CÀI ĐẶT MỘT KAFKA CLUSTER
Bạn sẽ cần có một Kafka cluster khả dụng nếu bạn muốn chạy các ví dụ được trình bày trong chương này. Tài liệu Kafka tại https://kafka.apache.org/quickstart là một nơi tuyệt vời để bắt đầu học cách chạy Kafka cục bộ trên máy tính của bạn.
Thuộc tính `spring.kafka.bootstrap-servers` xác định vị trí của một hoặc nhiều máy chủ Kafka được sử dụng để thiết lập kết nối ban đầu đến cụm Kafka. Ví dụ, nếu một trong những máy chủ Kafka trong cụm đang chạy tại kafka.tacocloud.com và lắng nghe trên cổng 9092, bạn có thể cấu hình địa chỉ của nó trong YAML như sau:
spring:
  kafka:
    bootstrap-servers:
      - kafka.tacocloud.com:9092

Các cấu hình này áp dụng cho các máy chủ khởi động Kafka trên một máy chủ có tên là kafka.tacocloud.com. Nếu bạn đang chạy cụm Kafka của mình trên máy địa phương (điều này thường xảy ra trong quá trình phát triển), thì bạn sẽ muốn sử dụng localhost thay vì, như được hiển thị dưới đây:



spring:
  kafka:
    bootstrap-servers:
      - localhost:9092

Với Kafka được cài đặt trong dự án của bạn, bạn đã sẵn sàng gửi và nhận các tin nhắn. Bạn sẽ bắt đầu bằng cách gửi các đối tượng TacoOrder đến Kafka bằng cách sử dụng KafkaTemplate.
9.3.2 Sending messages with KafkaTemplate

Trong nhiều cách, KafkaTemplate giống với các đối tác của nó trong JMS và RabbitMQ. Tuy nhiên, đồng thời, nó cũng rất khác biệt. Điều này trở nên rõ ràng khi chúng ta xem xét các phương thức của nó để gửi message, như được thể hiện dưới đây:

ListenableFuture<SendResult<K, V>> send(String topic, V data);

ListenableFuture<SendResult<K, V>> send(String topic, K key, V data);

ListenableFuture<SendResult<K, V>> send(String topic,Integer partition, K key, V data);

ListenableFuture<SendResult<K, V>> send(String topic,
                                    Integer partition, Long timestamp, K key, V data);

ListenableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record);

ListenableFuture<SendResult<K, V>> send(Message<?> message);

ListenableFuture<SendResult<K, V>> sendDefault(V data);

ListenableFuture<SendResult<K, V>> sendDefault(K key, V data);

ListenableFuture<SendResult<K, V>> sendDefault(Integer partition, key, V data);

ListenableFuture<SendResult<K, V>> sendDefault(Integer partition,
                                    Long timestamp, K key, V data);

Điều đầu tiên bạn có thể đã chú ý là không có các phương thức `convertAndSend()`. Điều này bởi vì KafkaTemplate được kiểu hóa với generics và có khả năng xử lý trực tiếp các loại miền khi gửi tin nhắn. Theo một cách nào đó, tất cả các phương thức `send()` đều đang thực hiện công việc của `convertAndSend()`.

Bạn cũng có thể đã chú ý rằng có một số tham số trong `send()` và `sendDefault()` khá khác biệt so với những gì bạn đã sử dụng với JMS và RabbitMQ. Khi gửi tin nhắn trong Kafka, bạn có thể chỉ định các tham số sau để hướng dẫn cách tin nhắn được gửi như sau:
- Topic mà bạn muốn gửi message đến (bắt buộc cho `send()`)
- Một partition mà bạn muốn ghi vào topic (tùy chọn)
- Một key để gửi trên bản ghi - record (tùy chọn)
- Một timestamp - dấu thời gian (tùy chọn; mặc định là `System.currentTimeMillis()`)
- Dữ liệu payload gửi (bắt buộc)

Topic và payload là hai tham số quan trọng nhất. Partitions và keys có ít ảnh hưởng đến cách bạn sử dụng KafkaTemplate, ngoại trừ việc chúng là thông tin bổ sung được cung cấp dưới dạng tham số cho `send()` và `sendDefault()`. Đối với mục đích của chúng ta, chúng ta sẽ tập trung vào việc gửi dữ liệu tin nhắn đến một chủ đề cụ thể và không quan tâm đến phân vùng và khóa.

Đối với phương thức `send()`, bạn cũng có thể chọn gửi một `ProducerRecord`, đó chỉ là một loại dữ liệu ghi lại tất cả các tham số trước đó trong một đối tượng duy nhất. Bạn cũng có thể gửi một đối tượng `Message`, nhưng việc này sẽ đòi hỏi bạn chuyển đổi đối tượng miền của mình thành một `Message`. Nói chung, việc sử dụng một trong những phương thức khác thay vì tạo và gửi một đối tượng `ProducerRecord` hoặc `Message` là dễ dàng hơn.
Bằng cách sử dụng KafkaTemplate và phương thức `send()` của nó, bạn có thể viết một triển khai dựa trên Kafka của OrderMessagingService. Đoạn mã dưới đây mô tả một triển khai như vậy.
package messaging;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import tacos.TacoOrder;

@Service
public class KafkaOrderMessagingService implements OrderMessagingService{
    private KafkaTemplate<String, TacoOrder> kafkaTemplate;

    @Autowired
    public KafkaOrderMessagingService(
            KafkaTemplate<String, TacoOrder> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @Override
    public void sendOrder(TacoOrder order) {
        kafkaTemplate.send("tacocloud.orders.topic", order);
    }
}

Trong triển khai mới của OrderMessagingService này, phương thức `sendOrder()` sử dụng phương thức `send()` của KafkaTemplate được inject để gửi một TacoOrder đến topic có tên là `tacocloud.orders.topic`. Ngoại trừ từ "Kafka" xuất hiện khắp mã nguồn, điều này không khác nhiều so với mã bạn đã viết cho JMS và Rabbit. Và giống như các triển khai khác của OrderMessagingService, nó có thể được inject vào OrderApiController và được sử dụng để gửi đơn hàng qua Kafka khi đơn hàng được đặt thông qua end point `/api/orders`.

Cho đến khi chúng ta tạo một triển khai Kafka của máy nhận message, bạn sẽ cần một bảng điều khiển để xem những gì đã được gửi. Có nhiều bảng điều khiển quản lý khả dụng cho Kafka, bao gồm Offset Explorer ([https://www.kafkatool.com/](https://www.kafkatool.com/)) và Giao diện Apache Kafka của Confluent ([http://mng.bz/g1P8](http://mng.bz/g1P8)).

Nếu bạn đặt một chủ đề mặc định, bạn có thể đơn giản hóa phương thức `sendOrder()` một chút. Đầu tiên, đặt chủ đề mặc định của bạn thành `tacocloud.orders.topic` bằng cách đặt thuộc tính `spring.kafka.template.default-topic` như sau:

spring:
  kafka:
    bootstrap-servers:
      - localhost:9092
    template:
      default-topic: tacocloud.orders.topic

Sau đó, trong phương thức `sendOrder()`, bạn có thể gọi `sendDefault()` thay vì `send()` và không cần chỉ định tên chủ đề, như sau:

Bây giờ khi mã gửi tin nhắn của bạn đã được viết, hãy chuyển sự chú ý của chúng ta sang việc viết mã để nhận những tin nhắn đó từ Kafka.
@Override
public void sendOrder(TacoOrder order) {
    kafkaTemplate.sendDefault(order);
}

9.3.3 Writing Kafka listeners

Ngoại trừ các chữ ký phương thức độc đáo cho `send()` và `sendDefault()`, KafkaTemplate khác biệt với JmsTemplate và RabbitTemplate ở chỗ nó không cung cấp bất kỳ phương thức nào để nhận tin nhắn. Điều đó có nghĩa là cách duy nhất để tiêu thụ tin nhắn từ một chủ đề Kafka bằng Spring là viết một bộ lắng nghe tin nhắn.

Đối với Kafka, bộ lắng nghe tin nhắn được xác định như các phương thức được chú thích bằng `@KafkaListener`. Chú thích `@KafkaListener` tương đối tương đồng với `@JmsListener` và `@RabbitListener` và được sử dụng theo cách tương tự. Đoạn mã tiếp theo mô tả như thế nào nếu bạn viết một máy nhận đơn hàng dựa trên lắng nghe tin nhắn của Kafka:

package tacos.kitchen.messaging.kafka.listener;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import tacos.TacoOrder;
import tacos.kitchen.KitchenUI;

@Component
public class OrderListener {

    private KitchenUI ui;

    @Autowired
    public OrderListener(KitchenUI ui) {
        this.ui = ui;
    }

    @KafkaListener(topics = "tacocloud.orders.topic")
    public void handle(TacoOrder order) {
        ui.displayOrder(order);
    }
}

Phương thức `handle()` được chú thích bằng `@KafkaListener` để chỉ định rằng nó sẽ được gọi khi một tin nhắn đến trong chủ đề có tên là `tacocloud.orders.topic`. Như được viết trong đoạn mã của bảng 9.9, chỉ có một `TacoOrder` (payload) được chuyển đến `handle()`. Tuy nhiên, nếu bạn cần thêm thông tin định danh từ tin nhắn, nó cũng có thể chấp nhận một đối tượng `ConsumerRecord` hoặc `Message`.

Ví dụ, triển khai sau của `handle()` chấp nhận một `ConsumerRecord` để bạn có thể ghi nhật ký về phân vùng và dấu thời gian của tin nhắn:




package tacos.kitchen.messaging.kafka.listener;

import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import tacos.TacoOrder;
import tacos.kitchen.KitchenUI;

@Component
@Slf4j
public class OrderListener {

    private KitchenUI ui;

    @Autowired
    public OrderListener(KitchenUI ui) {
        this.ui = ui;
    }

    @KafkaListener(topics = "tacocloud.orders.topic")
    public void handle(TacoOrder order,
                       ConsumerRecord<String, TacoOrder> record) {
        log.info("Received from partition {} with timestamp {}"
                , record.partition(), record.timestamp());
        ui.displayOrder(order);
    }
}

Đáng lưu ý rằng payload của message cũng có sẵn thông qua `ConsumerRecord.value()` hoặc `Message.getPayload()`. Điều này có nghĩa là bạn có thể yêu cầu `TacoOrder` thông qua những đối tượng đó thay vì yêu cầu nó trực tiếp như một tham số cho `handle()`.



Chapter 10 -Integrating Spring

This chapter covers
 Processing data in real time
 Defining integration flows
 Using Spring Integration’s Java DSL definition
 Integrating with emails, filesystems, and other
external systems

Một trong những điều làm tôi cảm thấy phiền lòng nhất khi đi du lịch là phải trải qua chuyến bay dài mà có kết nối internet trên máy bay kém hoặc không có. Tôi thích sử dụng thời gian trên máy bay để làm việc, bao gồm việc viết nhiều trang trong cuốn sách này. Nếu không có kết nối mạng, tôi sẽ ở trong tình thế bất lợi nếu cần phải truy xuất một thư viện hoặc tra cứu Javadoc, và tôi sẽ không thể làm nhiều công việc. Tôi đã học cách đóng gói một cuốn sách để đọc trong những trường hợp như vậy.
Giống như chúng ta cần kết nối với internet để làm việc hiệu quả, nhiều ứng dụng cũng cần kết nối với các hệ thống bên ngoài để thực hiện công việc của chúng. Một ứng dụng có thể cần đọc hoặc gửi email, tương tác với một API bên ngoài, hoặc phản ứng với dữ liệu được ghi vào cơ sở dữ liệu. Và, khi dữ liệu được nhập từ hoặc ghi vào các hệ thống bên ngoài này, ứng dụng có thể cần xử lý dữ liệu theo một cách nào đó để dịch nó vào hoặc ra khỏi miền ứng dụng của chính nó.
Trong chương này, bạn sẽ thấy cách sử dụng các mô hình tích hợp phổ biến với Spring Integration. Spring Integration là một bản triển khai sẵn có của nhiều mô hình tích hợp được liệt kê trong cuốn sách "Enterprise Integration Patterns" của Gregor Hohpe và Bobby Woolf (Addison-Wesley, 2003). Mỗi mô hình được triển khai như một thành phần thông qua đó dữ liệu được truyền qua một đường ống. Bằng cách sử dụng cấu hình Spring, bạn có thể tạo ra những thành phần này thành một đường ống thông qua đó dữ liệu chảy qua. Hãy bắt đầu bằng cách định nghĩa một luồng tích hợp đơn giản giới thiệu nhiều tính năng và đặc điểm khi làm việc với Spring Integration.

10.1 Declaring a simple integration flow

Nói chung, Spring Integration cho phép tạo ra các luồng tích hợp - integration flow thông qua đó một ứng dụng có thể nhận hoặc gửi dữ liệu đến một tài nguyên bên ngoài ứng dụng. Một trong những tài nguyên mà một ứng dụng có thể tích hợp là hệ thống tệp. Do đó, giữa nhiều thành phần của Spring Integration có các bộ chuyển đổi kênh – adapters chanel cho việc đọc và ghi tệp.

Để làm quen với Spring Integration, bạn sẽ tạo ra một integration flow cho việc ghi dữ liệu vào hệ thống tệp. Để bắt đầu, bạn cần thêm Spring Integration vào dự án của mình. Đối với Maven, các phụ thuộc cần thiết như sau:

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-integration</artifactId>
</dependency>

<dependency>
   <groupId>org.springframework.integration</groupId>
   <artifactId>spring-integration-file</artifactId>
</dependency>

Dependency đầu tiên là bộ starter Spring Boot cho Spring Integration. Phụ thuộc này là quan trọng để phát triển một Spring integration flow, bất kể luồng đó tích hợp với cái gì. Giống như tất cả các phụ thuộc bộ khởi động Spring Boot khác, nó có sẵn như một ô chọn trong biểu mẫu Initializr.

Phụ thuộc thứ hai là cho mô-đun end point file của Spring Integration. Mô-đun này là một trong hơn hai chục mô-đun end point được sử dụng để tích hợp với các hệ thống bên ngoài. Chúng ta sẽ nói thêm về các mô-đun end point trong phần 10.2.9. Nhưng, tạm thời, hãy biết rằng mô-đun end point tệp cung cấp khả năng nhập các tệp từ hệ thống tệp vào một luồng tích hợp và/hoặc ghi dữ liệu từ một luồng vào hệ thống tệp.

Tiếp theo, bạn cần tạo một cách để ứng dụng gửi dữ liệu vào một luồng tích hợp để nó có thể được ghi vào một tệp. Để làm điều đó, bạn sẽ tạo một giao diện cổng, chẳng hạn như giao diện được hiển thị sau đây.

package sia;

import org.springframework.integration.annotation.MessagingGateway;
import org.springframework.integration.file.FileHeaders;
import org.springframework.messaging.handler.annotation.Header;

@MessagingGateway(defaultRequestChannel = "textInChannel")
public interface FileWriterGateway {

    void writeToFile(@Header(FileHeaders.FILENAME) String filename, String data);
}


Mặc dù nó là một giao diện Java đơn giản, nhưng có nhiều điều cần nói về FileWriterGateway. Điều đầu tiên bạn sẽ nhận thấy là nó được chú thích bằng @MessagingGateway. Chú thích này thông báo cho Spring Integration để tạo ra một triển khai của giao diện này vào thời gian chạy, tương tự như cách Spring Data tự động tạo ra các triển khai của giao diện kho lưu trữ. Các phần khác của mã sẽ sử dụng giao diện này khi cần ghi một tệp.

Thuộc tính defaultRequestChannel của @MessagingGateway chỉ ra rằng bất kỳ message nào xuất phát từ cuộc gọi đến các phương thức giao diện sẽ được gửi đến kênh message được chỉ định. Trong trường hợp này, bạn chỉ định rằng bất kỳ message nào xuất phát từ cuộc gọi đến writeToFile() sẽ được gửi đến kênh có tên là textInChannel.

Đối với phương thức writeToFile(), nó nhận một tên tệp dưới dạng String và một String khác sẽ chứa nội dung văn bản cần được ghi vào tệp. Điều đáng chú ý ở chỗ chữ ký phương thức này là tham số filename được chú thích bằng @Header. Trong trường hợp này, chú thích @Header chỉ ra rằng giá trị được truyền vào filename sẽ được đặt trong một message header (được chỉ định là FileHeaders.FILENAME, là một hằng số trong lớp FileHeaders có giá trị bằng "file_name") thay vì trong dữ liệu tin nhắn. Ngược lại, giá trị tham số data được chứa trong dữ liệu tin nhắn.

Bây giờ, sau khi bạn đã tạo một cổng message, bạn cần cấu hình luồng tích hợp. Mặc dù phụ thuộc starter Spring Integration mà bạn đã thêm vào dự án của mình kích hoạt tự động cấu hình cần thiết cho Spring Integration, nhưng vẫn là trách của bạn để viết các cấu hình bổ sung để định nghĩa luồng phù hợp với nhu cầu của ứng dụng.
Ba tùy chọn cấu hình để khai báo các luồng tích hợp là:
 Cấu hình XML
 Cấu hình Java
 Cấu hình Java với DSL (Domain-Specific Language)
Chúng ta sẽ xem xét ba kiểu cấu hình này cho Spring Integration, bắt đầu với cấu hình XML, một phong cách cổ điển.

10.1.1 Defining integration flows with XML

Mặc dù tôi đã tránh sử dụng cấu hình XML trong cuốn sách này, nhưng Spring Integration có một lịch sử dài về các luồng tích hợp được định nghĩa trong XML. Do đó, tôi nghĩ đó là đáng giá để ít nhất là hiển thị một ví dụ về một luồng tích hợp được định nghĩa trong XML. Đoạn mã sau cho thấy cách cấu hình luồng mẫu của bạn trong XML.










<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:int="http://www.springframework.org/schema/integration"
       xmlns:int-file="http://www.springframework.org/schema/integration/file"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/file
    http://www.springframework.org/schema/integration/file/spring-integration-file.xsd">

    <int:channel id="textInChannel"/>           <!--Declares textInChannel-->

    <int:transformer id="upperCase"
                     input-channel="textInChannel"
                     output-channel="fileWriterChannel"
                     expression="payload.toUpperCase()" />      <!--Transforms the text-->

    <int:channel id="fileWriterChannel"/>       <!--Declares fileWriterChannel-->

    <int-file:outbound-channel-adapter id="writer"
                                       channel="fileWriterChannel"
                                       directory="/tmp/files"
                                       mode="APPEND"
                                       append-new-line="true" />        <!--Writes the text to a file-->
</beans>


Phân tích XML trong danh sách 10.2, chúng ta có những điều sau đây:
- Bạn đã cấu hình một channel mang tên `textInChannel`. Bạn sẽ nhận ra đây là cùng một channel được đặt làm request channel cho `FileWriterGateway`. Khi phương thức `writeToFile()` được gọi trên `FileWriterGateway`, thông điệp kết quả được xuất bản đến kênh này.
- Bạn đã cấu hình một transformer nhận thông điệp từ `textInChannel`. Nó sử dụng một biểu thức ngôn ngữ Spring Expression Language (SpEL) để gọi `toUpperCase()` trên dữ liệu của thông điệp. Kết quả của phép chuyển đổi thành chữ in hoa sau đó được xuất bản đến `fileWriterChannel`.
- Bạn đã cấu hình kênh mang tên `fileWriterChannel`. Kênh này hoạt động như đường ống kết nối transformer với channel adapter đầu ra-outbound.
- Cuối cùng, bạn đã cấu hình một bộ chuyển đổi kênh đầu ra sử dụng namespace `int-file`. Namespace XML này được cung cấp bởi mô-đun file của Spring Integration để ghi tệp. Theo cấu hình của bạn, nó nhận thông điệp từ `fileWriterChannel` và ghi dữ liệu của thông điệp vào một tệp có tên được chỉ định trong tiêu đề "file_name" của message, trong thư mục được chỉ định trong thuộc tính `directory`. Nếu tệp đã tồn tại, nội dung sẽ được thêm vào với một dòng mới thay vì ghi đè.
Dòng này được minh họa trong hình 10.1 bằng các yếu tố đồ họa được thiết kế theo sau những yếu tố trong Enterprise Integration Patterns.

 

Luồng bao gồm năm thành phần: one gateway, two channel, one transformer và one outbound channel adapter. Đây chỉ là một số ít trong số các thành phần có thể được lắp ráp vào một luồng tích hợp. Chúng ta sẽ khám phá những thành phần này và những thành phần khác được hỗ trợ bởi Spring Integration trong phần 10.2.

Nếu bạn muốn sử dụng cấu hình XML trong một ứng dụng Spring Boot, bạn sẽ cần nhập XML như một tài nguyên vào ứng dụng Spring. Cách đơn giản nhất để làm điều này là sử dụng chú thích @ImportResource của Spring, được hiển thị trong đoạn mã tiếp theo, trên một trong các lớp cấu hình Java của ứng dụng của bạn:

```java
@Configuration
@ImportResource("classpath:/filewriter-config.xml")
public class FileWriterIntegrationConfig { ... }
```

Mặc dù cấu hình dựa trên XML đã phục vụ tốt cho Spring Integration, hầu hết các nhà phát triển đã trở nên thận trọng khi sử dụng XML. (Và, như tôi đã nói, tôi tránh sử dụng cấu hình XML trong cuốn sách này.) Hãy để bên lề những dấu nháy đơn nghiêng kia và hướng sự chú ý của chúng ta đến kiểu cấu hình Java của Spring Integration.

10.1.2 Configuring integration flows in Java

Hầu hết các ứng dụng Spring hiện đại đã từ chối cấu hình XML để ưa chuộng cấu hình Java. Trong thực tế, trong các ứng dụng Spring Boot, cấu hình Java là một kiểu tự nhiên để bổ sung tự động cấu hình. Do đó, nếu bạn đang thêm một luồng tích hợp vào một ứng dụng Spring Boot, việc định nghĩa luồng bằng Java là hoàn toàn hợp lý.

Là một ví dụ về cách viết một luồng tích hợp với cấu hình Java, hãy xem vào đoạn mã tiếp theo. Đây là cùng một luồng tích hợp ghi tệp như trước, nhưng lần này được viết bằng Java.

package sia;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.integration.annotation.Transformer;
import org.springframework.integration.file.FileWritingMessageHandler;
import org.springframework.integration.file.support.FileExistsMode;
import org.springframework.integration.transformer.GenericTransformer;

import java.io.File;

@Configuration
public class FileWriterIntegrationConfig {

    @Bean
    @Transformer(inputChannel = "textInChannel"
            , outputChannel = "fileWriterChannel")
    public GenericTransformer<String, String> upperCaseTransformer() {
        return text -> text.toUpperCase();
    }

    @Bean
    @ServiceActivator(inputChannel = "fileWriterChannel")
    public FileWritingMessageHandler fileWriter() {
        FileWritingMessageHandler handler =
                new FileWritingMessageHandler(new File("/tmp/files"));
        handler.setExpectReply(false);
        handler.setFileExistsMode(FileExistsMode.APPEND);
        handler.setAppendNewLine(true);
        return handler;
    }
}


Với cấu hình Java, bạn khai báo hai bean: a transformer and a file-writing message handler. Bộ biến đổi là một GenericTransformer. Vì GenericTransformer là một giao diện chức năng, bạn có thể cung cấp triển khai của nó dưới dạng lambda gọi đến toUpperCase() trên văn bản của thông điệp. Bean bộ biến đổi được chú thích bằng @Transformer, chỉ định nó là một bộ biến đổi trong luồng tích hợp nhận thông điệp trên một kênh mang tên textInChannel và ghi thông điệp vào kênh mang tên fileWriterChannel.

Đối với bean write file, nó được chú thích bằng @ServiceActivator để chỉ định rằng nó sẽ chấp nhận thông điệp từ fileWriterChannel và chuyển giao những thông điệp đó cho dịch vụ được định nghĩa bởi một thể hiện của FileWritingMessageHandler. FileWritingMessageHandler là một bộ xử lý message ghi dữ liệu của message vào một tệp trong một thư mục cụ thể bằng cách sử dụng một filename được chỉ định trong header "file_name" của message. Như trong ví dụ XML, FileWritingMessageHandler được cấu hình để thêm vào tệp với một dòng mới.

Một điều độc đáo về cấu hình của bean FileWritingMessageHandler là có một cuộc gọi setExpectReply(false) để chỉ định rằng bộ service activator không cần phải mong đợi một kênh trả lời (một kênh qua đó giá trị có thể được trả lại cho các thành phần ở trên trong luồng). Nếu bạn không gọi setExpectReply(false), bean ghi tệp sẽ mặc định là true, và mặc dù đường ống vẫn hoạt động như mong đợi, bạn sẽ thấy một số lỗi được ghi lại cho biết không có kênh trả lời nào được cấu hình.

Bạn cũng sẽ nhận thấy rằng bạn không cần phải tường minh khai báo các kênh. Các kênh textInChannel và fileWriterChannel sẽ được tạo tự động nếu không có bean nào với những tên đó tồn tại. Nhưng nếu bạn muốn kiểm soát nhiều hơn về cách các kênh được cấu hình, bạn có thể tường minh tạo chúng như là các bean như sau:

@Bean
public MessageChannel textInChannel() {
    return new DirectChannel();
}

@Bean
public MessageChannel fileWriterChannel() {
    return new DirectChannel();
}

Lựa chọn cấu hình Java có lẽ dễ đọc hơn - và ngắn gọn hơn một chút - và chắc chắn là nhất quán với kiểu cấu hình chỉ bằng Java mà tôi đang tập trung trong cuốn sách này. Nhưng nó có thể được làm mạnh mẽ hơn nữa với kiểu cấu hình Java DSL (domain-specific language - ngôn ngữ cụ thể cho miền) của Spring Integration.

10.1.3 Using Spring Integration’s DSL configuration

Hãy thử định nghĩa luồng tích hợp ghi tệp một lần nữa. Lần này, bạn vẫn sẽ định nghĩa nó bằng Java, nhưng bạn sẽ sử dụng Java DSL của Spring Integration. Thay vì khai báo một bean riêng lẻ cho mỗi thành phần trong luồng, bạn sẽ khai báo một bean duy nhất mà xác định toàn bộ luồng.

@Bean
public IntegrationFlow fileWriterFlow() {
    return IntegrationFlows
            .from(MessageChannels.direct("textInChannel"))
            .<String, String>transform(t -> t.toUpperCase())
            .handle(Files
                    .outboundAdapter(new File("/tmp/files"))
                    .fileExistsMode(FileExistsMode.APPEND)
                    .appendNewLine(true))
            .get();
}
Cấu hình mới này ngắn gọn nhất có thể, chứa đựng toàn bộ luồng trong một phương thức bean duy nhất. Lớp `IntegrationFlows` khởi tạo API builder, từ đó bạn có thể khai báo luồng.

Trong danh sách 10.4, bạn bắt đầu bằng cách nhận các message từ kênh mang tên `textInChannel`, sau đó chúng đi qua một transformer làm chữ hoa nội dung của message. Sau bộ biến đổi, các message được xử lý bởi một bộ chuyển đổi kênh đầu ra được tạo ra từ kiểu Files được cung cấp trong mô-đun tệp của Spring Integration. Cuối cùng, một cuộc gọi đến `get()` xây dựng `IntegrationFlow` để trả về. Nói một cách ngắn gọn, phương thức bean duy nhất này định nghĩa cùng một luồng tích hợp như các ví dụ cấu hình XML và Java.

Bạn sẽ chú ý rằng, tương tự như ví dụ cấu hình Java, bạn không cần phải tường minh khai báo các bean kênh. Mặc dù bạn tham chiếu đến `textInChannel`, nó tự động được tạo ra bởi Spring Integration vì không có bean kênh nào tồn tại với tên đó. Nhưng bạn vẫn có thể tường minh khai báo bean kênh nếu muốn.

Còn đối với kênh kết nối bộ biến đổi với bộ chuyển đổi kênh đầu ra, bạn thậm chí không cần tham chiếu nó bằng tên. Nếu có nhu cầu cấu hình tường minh cho kênh, bạn có thể tham chiếu nó theo tên trong định nghĩa luồng với cuộc gọi đến `channel()` như sau:

// Tường minh hơn với phương thức channel()
@Bean
public IntegrationFlow fileWriterFlow() {
    return IntegrationFlows
            .from(MessageChannels.direct("textInChannel"))
            .<String, String>transform(t -> t.toUpperCase())
            .channel(MessageChannels.direct("FileWriterChannel"))
            .handle(Files
                    .outboundAdapter(new File("/tmp/files"))
                    .fileExistsMode(FileExistsMode.APPEND)
                    .appendNewLine(true))
            .get();
}

Một điều cần lưu ý khi làm việc với Java DSL của Spring Integration (như bất kỳ API linh hoạt nào khác) là bạn phải sử dụng khoảng trắng một cách khôn ngoan để duy trì tính đọc dễ hiểu. Trong ví dụ ở đây, tôi đã cẩn thận thụt dòng để chỉ ra các khối mã liên quan. Đối với các luồng dài hơn, phức tạp hơn, bạn có thể thậm chí xem xét việc trích xuất các phần của luồng thành các phương thức hoặc các luồng con riêng biệt để làm cho mã dễ đọc hơn.

Bây giờ khi bạn đã thấy một luồng đơn giản được định nghĩa bằng ba kiểu cấu hình khác nhau, hãy rời khỏi chi tiết và xem xét tổng quan lớn của Spring Integration.

10.2 Surveying the Spring Integration landscape

Spring Integration bao gồm một loạt các tình huống tích hợp khác nhau. Cố gắng bao gồm tất cả chúng trong một chương sẽ giống như cố gắng chứa một con voi trong một phong bì. Thay vì một xử lý toàn diện về Spring Integration, tôi sẽ trình bày một bức ảnh về con voi Spring Integration để bạn có một số ý tưởng về cách nó hoạt động. Sau đó, bạn sẽ tạo thêm một luồng tích hợp để thêm chức năng vào ứng dụng Taco Cloud.

Một luồng tích hợp được tạo thành từ một hoặc nhiều trong các thành phần sau. Trước khi bạn viết thêm mã, chúng ta sẽ xem qua ngắn gọn về vai trò của mỗi thành phần này trong một luồng tích hợp:

- Channel: Chuyển message từ một thành phần sang một thành phần khác.
  
- Filter: Cho phép message đi qua luồng dựa trên một số điều kiện có điều kiện.

- Transformer: Thay đổi giá trị message và/hoặc chuyển đổi nội dung message từ một kiểu sang kiểu khác.

- Router: Chuyển hướng message đến một trong nhiều channel, thường dựa trên tiêu đề message.

- Splitter: Chia các message đến hai hoặc nhiều message, mỗi cái được gửi đến các kênh khác nhau.

- Aggregator: Ngược lại với Splitter; kết hợp nhiều message đến từ các kênh riêng biệt thành một message.

- Service activator: Chuyển message đến một phương thức Java nào đó để xử lý, sau đó xuất bản giá trị trả về trên một output channel.

- Channel adapter: Kết nối một channel với một hệ thống hoặc giao thông vận tải bên ngoại; có thể chấp nhận đầu vào hoặc ghi vào hệ thống bên ngoài.

- Gateway: Chuyển dữ liệu vào một integration flow qua một giao diện.

Bạn đã thấy một số trong số các thành phần này khi định nghĩa luồng tích hợp ghi tệp. Giao diện FileWriterGateway là cổng thông qua đó một ứng dụng gửi văn bản để ghi vào tệp. Bạn cũng đã định nghĩa một bộ biến đổi để chuyển đổi văn bản được cung cấp thành chữ in hoa; sau đó, bạn đã khai báo một cổng dịch vụ thực hiện công việc viết văn bản vào tệp. Và luồng có hai kênh, textInChannel và fileWriterChannel, kết nối các thành phần khác nhau với nhau. Bây giờ, một chuyến thăm nhanh các thành phần luồng tích hợp, như đã hứa.

10.2.1 Message channels

Message channel là cách message di chuyển qua integration pipeline – đường ống tích hợp, như được thể hiện trong hình 10.2. Chúng là những đường ống kết nối tất cả các phần khác của hệ thống ống nước Spring Integration lại với nhau.

 

Spring Integration cung cấp một số triển khai kênh, bao gồm:

- PublishSubscribeChannel Các message được xuất bản vào một PublishSubscribeChannel được chuyển tiếp đến một hoặc nhiều người tiêu thụ. Nếu có nhiều người tiêu thụ, tất cả đều nhận message.

- QueueChannel Các message được xuất bản vào một QueueChannel được lưu trữ trong một hàng đợi cho đến khi bị rút ra bởi một người tiêu thụ theo cơ chế first in, first out (FIFO). Nếu có nhiều người tiêu thụ, chỉ có một người nhận thông điệp.

- PriorityChannel Tương tự như QueueChannel, nhưng thay vì có hành vi FIFO, các message được rút ra bởi người tiêu thụ dựa trên tiêu đề ưu tiên của message.

- RendezvousChannel Giống như QueueChannel nhưng người gửi chặn kênh cho đến khi một người tiêu thụ nhận message, đồng bộ hóa người gửi với người tiêu thụ.

- DirectChannel Giống như PublishSubscribeChannel, nhưng gửi một message đến một người tiêu thụ duy nhất bằng cách gọi người tiêu thụ trong cùng một luồng như người gửi. Điều này cho phép giao dịch kéo dài qua kênh.

- ExecutorChannel Tương tự như DirectChannel, nhưng việc gửi thông điệp xảy ra thông qua một TaskExecutor, diễn ra trong một luồng khác biệt so với người gửi. Loại kênh này không hỗ trợ giao dịch kéo dài qua kênh.

- FluxMessageChannel Một kênh thông điệp Publisher dựa trên Reactive Streams, sử dụng Project Reactor's Flux. (Chúng ta sẽ nói thêm về Reactive Streams, Reactor và Flux trong chương 11.)

Cả trong kiểu cấu hình Java và kiểu cấu hình Java DSL, các kênh đầu vào được tạo tự động, với DirectChannel là mặc định. Nhưng nếu bạn muốn sử dụng một triển khai kênh khác, bạn sẽ cần khai báo kênh một cách rõ ràng như một bean và tham chiếu nó trong luồng tích hợp. Ví dụ, để khai báo một PublishSubscribeChannel, bạn sẽ khai báo phương thức @Bean như sau:

@Bean
public MessageChannel orderChannel() {
    return new PublishSubscribeChannel();
}

Sau đó, bạn sẽ tham chiếu đến kênh này theo tên trong định nghĩa luồng tích hợp. Ví dụ, nếu kênh đang được tiêu thụ bởi một bean service activator, bạn sẽ tham chiếu đến nó trong thuộc tính inputChannel của @ServiceActivator như sau:
@ServiceActivator(inputChannel="orderChannel")

Hoặc, nếu bạn đang sử dụng kiểu cấu hình Java DSL, bạn sẽ tham chiếu đến nó với một cuộc gọi đến `channel()` như sau:
@Bean
public IntegrationFlow orderFlow() {
   return IntegrationFlows
             ...
             .channel("orderChannel")
             ...
             .get();
}

Lưu ý quan trọng rằng nếu bạn đang sử dụng QueueChannel, các người tiêu thụ phải được cấu hình với một poller. Ví dụ, giả sử bạn đã khai báo một bean QueueChannel như sau:
@Bean
public MessageChannel orderChannel() {
    return new QueueChannel();
}

Bạn cần đảm bảo rằng người tiêu thụ được cấu hình để đánh giá kênh để lấy thông điệp. Trong trường hợp của một service activator, chú thích `@ServiceActivator` có thể trông như sau:

@ServiceActivator(inputChannel="orderChannel", poller=@Poller(fixedRate="1000"))

Trong ví dụ này, service activator đánh giá kênh có tên là orderChannel mỗi 1 giây (hoặc 1,000 ms).

10.2.2 Filters

Bạn có thể đặt các bộ lọc giữa một đường ống tích hợp để cho phép hoặc không cho phép message tiếp tục đến bước tiếp theo trong luồng, như được thể hiện trong hình 10.3.

 

Ví dụ, giả sử các message chứa các giá trị số nguyên được xuất bản thông qua một channel có tên là numberChannel, nhưng bạn chỉ muốn các số chẵn được chuyển tiếp đến kênh có tên là evenNumberChannel. Trong trường hợp đó, bạn có thể khai báo một bộ lọc với chú thích `@Filter` như sau:

@Filter(inputChannel="numberChannel",
        outputChannel="evenNumberChannel")
public boolean evenNumberFilter(Integer number) {
    return number % 2 == 0;
}

Hoặc, nếu bạn đang sử dụng kiểu cấu hình Java DSL để định nghĩa luồng tích hợp của mình, bạn có thể gọi đến filter() như sau:




@Bean
public IntegrationFlow evenNumberFlow(AtomicInteger integerSource) {
    return IntegrationFlows
        ...
        .<Integer>filter((p) -> p % 2 == 0)
        ...
        .get();
}

Trong trường hợp này, bạn sử dụng một lambda để thực hiện bộ lọc. Nhưng, để nói sự thật, phương thức filter() chấp nhận một GenericSelector làm đối số. Điều này có nghĩa là bạn có thể thay thế bằng cách triển khai giao diện GenericSelector, nếu nhu cầu lọc của bạn quá phức tạp cho một lambda đơn giản.

10.2.3 Transformers

Transformer thực hiện một số thao tác trên các message, thường dẫn đến một message khác và, có thể, với một kiểu dữ liệu khác nhau (xem hình 10.4). Quá trình biến đổi có thể làm điều gì đó đơn giản, chẳng hạn như thực hiện các phép toán toán học trên một số hoặc làm thay đổi một giá trị String. Hoặc quá trình biến đổi có thể phức tạp hơn, chẳng hạn như sử dụng một giá trị String đại diện cho một ISBN để tra cứu và trả lại thông tin về cuốn sách tương ứng.


 

Ví dụ, giả sử các giá trị số nguyên đang được xuất bản trên một kênh có tên là numberChannel, và bạn muốn chuyển đổi những số đó thành một chuỗi chứa số La Mã tương ứng. Trong trường hợp này, bạn có thể khai báo một bean thuộc loại GenericTransformer và gán chú thích @Transformer như sau:

@Bean
@Transformer(inputChannel="numberChannel",
              outputChannel="romanNumberChannel")
public GenericTransformer<Integer, String> romanNumTransformer() {
    return RomanNumbers::toRoman;
}

Chú thích @Transformer chỉ định rằng bean này là một bean biến đổi nhận giá trị Integer từ kênh có tên là numberChannel và sử dụng một phương thức tĩnh có tên là toRoman() để thực hiện chuyển đổi. (Phương thức toRoman() được định nghĩa tĩnh trong một lớp có tên là RomanNumbers và được tham chiếu ở đây thông qua tham chiếu phương thức.) Kết quả được xuất bản vào kênh có tên là romanNumberChannel.

Trong kiểu cấu hình Java DSL, nó còn dễ dàng hơn với cuộc gọi transform(), truyền tham chiếu phương thức đến phương thức toRoman() như sau:

@Bean
public IntegrationFlow transformerFlow() {
    return IntegrationFlows
        ...
        .transform(RomanNumbers::toRoman)
        ...
        .get();
}

Mặc dù bạn đã sử dụng một tham chiếu phương thức trong cả hai ví dụ mã nguồn biến đổi, nhưng hãy biết rằng biến đổi cũng có thể được chỉ định dưới dạng lambda. Hoặc, nếu biến đổi đủ phức tạp để xứng đáng với một lớp Java riêng biệt, bạn có thể inject nó như một bean vào cấu hình luồng và truyền tham chiếu đến phương thức transform() như sau:

@Bean
public RomanNumberTransformer romanNumberTransformer() {
    return new RomanNumberTransformer();
}

@Bean
public IntegrationFlow transformerFlow(RomanNumberTransformer romanNumberTransformer) {
    return IntegrationFlows
        ...
        .transform(romanNumberTransformer)
        ...
        .get();
}

Ở đây, bạn khai báo một bean thuộc loại RomanNumberTransformer, mà chính là một cài đặt của các giao diện Transformer hoặc GenericTransformer của Spring Integration. Bean được inject vào phương thức transformerFlow() và được truyền vào phương thức transform() khi định nghĩa luồng tích hợp.

10.2.4 Routers

Router, dựa trên một số tiêu chí định tuyến, cho phép nhánh trong một luồng tích hợp, chuyển hướng các message đến các channel khác nhau (xem hình 10.5).

 

Ví dụ, giả sử bạn có một kênh có tên là numberChannel thông qua đó giá trị số nguyên chảy. Và hãy nói rằng bạn muốn chuyển hướng tất cả các thông điệp với số chẵn đến một kênh có tên là evenChannel, trong khi các thông điệp với số lẻ được định tuyến đến một kênh có tên là oddChannel. Để tạo ra một định tuyến như vậy trong luồng tích hợp của bạn, bạn có thể khai báo một bean thuộc loại AbstractMessageRouter và gán chú thích cho bean bằng @Router, như được hiển thị dưới đây:

@Bean
@Router(inputChannel = "numberChannel")
public AbstractMessageRouter evenOddRouter() {
    return new AbstractMessageRouter() {
        @Override
        protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {
            Integer number = (Integer) message.getPayload();
            if(number % 2 == 0) {
                return Collections.singleton(evenChannel());
            }
            return Collections.singleton(oddChannel());
        }
    };
}

@Bean
public MessageChannel evenChannel() {
    return new DirectChannel();
}

@Bean
public MessageChannel oddChannel() {
    return new DirectChannel();
}

Bean AbstractMessageRouter được khai báo ở đây chấp nhận các message từ một input channel có tên là numberChannel. Bản triển khai, được xác định dưới dạng một lớp nội danh, kiểm tra dữ liệu payload của message và, nếu đó là số chẵn, trả về channel có tên là evenChannel (được khai báo là một bean sau bean router). Ngược lại, nếu số trong dữ liệu payload của channel là số lẻ, trong trường hợp này, channel có tên oddChannel được trả về (cũng được khai báo trong một phương thức khai báo bean).

Dưới dạng Java DSL, các router được khai báo bằng cách gọi route() trong quá trình định nghĩa một luồng, như được hiển thị dưới đây:





@Bean
public IntegrationFlow numberRoutingFlow(AtomicInteger source) {
    return IntegrationFlows
        ...
        .<Integer, String>route(n -> n%2==0 ? "EVEN":"ODD", mapping -> mapping
            .subFlowMapping("EVEN", sf -> sf
                .<Integer, Integer>transform(n -> n * 10)
                .handle((i,h) -> { ... })
            )
            .subFlowMapping("ODD", sf -> sf
                .transform(RomanNumbers::toRoman)
                .handle((i,h) -> { ... })
            )
        )
        .get();
}
```

Mặc dù vẫn có thể khai báo một AbstractMessageRouter và đưa nó vào route(), ví dụ này sử dụng một lambda để xác định liệu payload của một thông điệp có là số lẻ hay chẵn không. Nếu nó là số chẵn, sau đó trả về một giá trị String là EVEN. Nếu nó là số lẻ, sau đó trả về ODD. Những giá trị này sau đó được sử dụng để xác định submapping nào sẽ xử lý thông điệp.

10.2.5 Splitters

Đôi khi trong một luồng tích hợp, việc chia một message thành nhiều messages để xử lý độc lập có thể hữu ích. Splitters, như được minh họa trong hình 10.6, sẽ chia và xử lý những message đó cho bạn.

 
Splitters rất hữu ích trong nhiều tình huống, nhưng bạn có thể sử dụng một splitter cho hai trường hợp sử dụng quan trọng sau đây:

- Payload của một thông điệp chứa một bộ sưu tập các mục cùng loại mà bạn muốn xử lý như các payload thông điệp riêng lẻ. Ví dụ, một thông điệp mang theo một danh sách sản phẩm có thể được chia thành nhiều thông điệp với payload là một sản phẩm mỗi thông điệp.

- Payload của một thông điệp chứa thông tin, mặc dù liên quan nhau, nhưng có thể được chia thành hai hoặc nhiều thông điệp có loại khác nhau. Ví dụ, một đơn đặt hàng có thể mang theo thông tin về giao hàng, thanh toán và các mục dòng. Chi tiết vận chuyển có thể được xử lý bởi một subflow, thanh toán bởi một subflow khác và các mục dòng trong một subflow khác nữa. Trong trường hợp sử dụng này, splitter thường được theo sau bởi một router để định tuyến các thông điệp theo loại payload để đảm bảo rằng dữ liệu được xử lý bởi subflow đúng.

Khi chia payload của một thông điệp thành hai hoặc nhiều thông điệp có loại khác nhau, thường đủ để định nghĩa một POJO (Plain Old Java Object) để trích xuất các phần riêng lẻ của payload đầu vào và trả về chúng như các phần tử của một bộ sưu tập.

Ví dụ, giả sử bạn muốn chia một thông điệp chứa một đơn đặt hàng thành hai thông điệp: một chứa thông tin thanh toán và một khác chứa danh sách các lineitem. OrderSplitter dưới đây sẽ thực hiện công việc này:
Bạn có thể khai báo một bean OrderSplitter như một phần của luồng tích hợp bằng cách đánh dấu nó bằng @Splitter như sau:

@Bean
@Splitter(inputChannel="poChannel", outputChannel="splitOrderChannel")
public OrderSplitter orderSplitter() {
    return new OrderSplitter();
}

Ở đây, các đơn đặt hàng được gửi đến kênh có tên là `poChannel` và được chia nhỏ bởi OrderSplitter. Sau đó, mỗi mục trong bộ sưu tập được trả về sẽ được xuất bản dưới dạng một thông điệp riêng lẻ trong luồng tích hợp đến một kênh có tên là `splitOrderChannel`. Tại điểm này trong luồng, bạn có thể khai báo một PayloadTypeRouter để định tuyến thông tin thanh toán và các lineitem đến các subflow riêng biệt như sau:

@Bean
@Router(inputChannel="splitOrderChannel")
public MessageRouter splitOrderRouter() {
    PayloadTypeRouter router = new PayloadTypeRouter();
    router.setChannelMapping(BillingInfo.class.getName(), "billingInfoChannel");
    router.setChannelMapping(List.class.getName(), "lineItemsChannel");
    return router;
}

Như tên gọi, PayloadTypeRouter định tuyến các thông điệp đến các kênh khác nhau dựa trên loại payload của chúng. Được cấu hình ở đây, các thông điệp có payload thuộc loại BillingInfo được định tuyến đến một kênh có tên là `billingInfoChannel` để xử lý tiếp. Còn đối với các lineitem, chúng ở trong một bộ sưu tập java.util.List; do đó, bạn ánh xạ các payload thuộc loại List để được định tuyến đến một kênh có tên là `lineItemsChannel`.

Như vậy, tình huống hiện tại luồng chia thành hai subflow: một thông qua đó các đối tượng BillingInfo chảy và một thông qua đó List<LineItem> chảy. Nhưng nếu bạn muốn phân chia nó thêm nữa sao cho thay vì xử lý một List của các đối tượng LineItem, bạn xử lý từng LineItem riêng lẻ, bạn chỉ cần viết một phương thức (không phải là một bean) được chú thích với @Splitter và trả về một bộ sưu tập các đối tượng LineItem, có thể là như sau:

@Splitter(inputChannel="lineItemsChannel", outputChannel="lineItemChannel")
public List<LineItem> lineItemSplitter(List<LineItem> lineItems) {
    return lineItems;
}


Khi một thông điệp mang payload là List<LineItem> đến kênh có tên là `lineItemsChannel`, nó đi vào phương thức lineItemSplitter(). Theo quy tắc của một splitter, phương thức phải trả về một bộ sưu tập các mục để chia. Trong trường hợp này, bạn đã có một bộ sưu tập các đối tượng LineItem, vì vậy bạn chỉ cần trả về bộ sưu tập trực tiếp. Kết quả là, mỗi LineItem trong bộ sưu tập sẽ được xuất bản trong một thông điệp riêng lẻ đến kênh có tên là `lineItemChannel`.

Nếu bạn muốn sử dụng Java DSL để khai báo cùng cấu hình splitter/router, bạn có thể làm như sau:
return IntegrationFlows
    ...
    .split(orderSplitter())
    .<Object, String>route(
        p -> {
            if (p.getClass().isAssignableFrom(BillingInfo.class)) {
                return "BILLING_INFO";
            } else {
                return "LINE_ITEMS";
            }
        },
        mapping -> mapping
            .subFlowMapping("BILLING_INFO", sf -> sf
                .<BillingInfo> handle((billingInfo, h) -> {
                    ...
                })
            )
            .subFlowMapping("LINE_ITEMS", sf -> sf
                .split()
                .<LineItem> handle((lineItem, h) -> {
                    ...
                })
            )
    )
    .get();
```

Dạng DSL của định nghĩa luồng này chắc chắn là ngắn gọn, nếu không nói là khá khó theo dõi. Bạn có thể làm cho mã nguồn sạch sẽ hơn một chút bằng cách trích xuất các lambda thành các phương thức. Ví dụ, bạn có thể sử dụng ba phương thức sau để thay thế các lambda được sử dụng trong định nghĩa luồng:

private String route(Object p) {
    return p.getClass().isAssignableFrom(BillingInfo.class) ? "BILLING_INFO" : "LINE_ITEMS";
}

private BillingInfo handleBillingInfo(BillingInfo billingInfo, MessageHeaders h) {
    // ...
}

private LineItem handleLineItems(LineItem lineItem, MessageHeaders h) {
    // ...
}
```

Sau đó, bạn có thể viết lại luồng tích hợp với các tham chiếu phương thức như sau:

return IntegrationFlows
    ...
    .split()
    .route(
        this::route,
        mapping -> mapping
            .subFlowMapping("BILLING_INFO", sf -> sf
                .<BillingInfo> handle(this::handleBillingInfo))
            .subFlowMapping("LINE_ITEMS", sf -> sf
                .split()
                .<LineItem> handle(this::handleLineItems)));
```

Dù cách nào đi chăng nữa, đây đều sử dụng cùng một OrderSplitter để chia đơn đặt hàng như ví dụ cấu hình Java. Sau khi đơn hàng được chia nhỏ, nó được định tuyến theo loại để đi đến hai subflow khác nhau.

10.2.6 Service activators

Các service activator nhận các message từ một kênh đầu vào và gửi những message đó đến một đối tượng thực thi MessageHandler, như được hiển thị trong hình 10.7.

 

Spring Integration cung cấp một số triển khai của MessageHandler sẵn có (thậm chí PayloadTypeRouter cũng là một triển khai của MessageHandler), nhưng bạn thường cần cung cấp một triển khai tùy chỉnh để làm nhiệm vụ của một service activator. Ví dụ, đoạn mã sau mô tả cách khai báo một bean MessageHandler, được cấu hình để làm một service activator:

@Bean
@ServiceActivator(inputChannel="someChannel")
public MessageHandler sysoutHandler() {
    return message -> {
        System.out.println("Message payload: " + message.getPayload());
    };
}

Bean được đánh dấu bằng @ServiceActivator để chỉ định nó là một service activator xử lý các message từ kênh có tên là someChannel. Về MessageHandler chính nó, nó được thực hiện thông qua một lambda. Mặc dù đây là một MessageHandler đơn giản, khi nhận một Message, nó xuất payload của nó ra luồng đầu ra tiêu chuẩn.

Ngoài ra, bạn có thể khai báo một service activator xử lý dữ liệu trong thông điệp đầu vào trước khi trả lại một payload mới, như được hiển thị trong đoạn mã tiếp theo. Trong trường hợp này, bean nên là một GenericHandler thay vì là một MessageHandler.






@Bean
@ServiceActivator(inputChannel="orderChannel", outputChannel="completeChannel")
public GenericHandler<EmailOrder> orderHandler(OrderRepository orderRepo) {
    return (payload, headers) -> {
        return orderRepo.save(payload);
    };
}

Trong trường hợp này, service activator là một GenericHandler mà mong đợi các thông điệp với payload kiểu EmailOrder. Khi đơn hàng đến, nó được lưu thông qua một repository; EmailOrder được lưu sẽ được trả lại để gửi đến kênh đầu ra có tên là completeChannel.

Bạn có thể chú ý rằng GenericHandler không chỉ nhận payload mà còn nhận các headers của thông điệp (ngay cả khi ví dụ không sử dụng các headers đó theo bất kỳ cách nào). Nếu bạn muốn, bạn cũng có thể sử dụng service activator trong kiểu cấu hình Java DSL bằng cách truyền MessageHandler hoặc GenericHandler cho phương thức handle() trong định nghĩa luồng như sau:

public IntegrationFlow someFlow() {
    return IntegrationFlows
        ...
        .handle(msg -> {
            System.out.println("Message payload: " + msg.getPayload());
        })
        .get();
}

Trong trường hợp này, MessageHandler được đưa dưới dạng một lambda, nhưng bạn cũng có thể cung cấp nó dưới dạng tham chiếu phương thức hoặc thậm chí là một thể hiện của một lớp thực hiện giao diện MessageHandler. Nếu bạn cung cấp nó dưới dạng lambda hoặc tham chiếu phương thức, hãy nhớ rằng nó nhận một thông điệp làm tham số.

Tương tự, phương thức handle() cũng có thể được viết để chấp nhận một GenericHandler nếu service activator không được dự định là cuối của luồng. Áp dụng service activator lưu đơn hàng từ trước, bạn có thể cấu hình luồng với Java DSL như sau:

public IntegrationFlow orderFlow(OrderRepository orderRepo) {
    return IntegrationFlows
        ...
        .<EmailOrder>handle((payload, headers) -> {
            return orderRepo.save(payload);
        })
        ...
        .get();
}

Khi làm việc với GenericHandler, lambda hoặc tham chiếu phương thức nhận payload và headers của thông điệp làm tham số. Hơn nữa, nếu bạn chọn sử dụng GenericHandler ở cuối một luồng, bạn sẽ cần trả lại null, hoặc bạn sẽ nhận được lỗi chỉ định rằng không có kênh đầu ra được chỉ định.

10.2.7 Gateways

Gateway là cách mà một ứng dụng có thể gửi dữ liệu vào một luồng tích hợp và tùy chọn nhận phản hồi là kết quả của luồng. Được thực hiện bởi Spring Integration, các gateway được hiện thực như các giao diện mà ứng dụng có thể gọi để gửi các message vào luồng tích hợp (xem hình 10.8).

 

Bạn đã thấy một ví dụ về một message gateway với FileWriterGateway. FileWriterGateway là một cổng một chiều với một phương thức chấp nhận một chuỗi để ghi vào tệp, trả về void. Việc viết một cổng hai chiều cũng khá dễ dàng. Khi viết giao diện cổng, hãy chắc chắn rằng phương thức trả về một giá trị để xuất bản vào luồng tích hợp.

Ví dụ, hãy tưởng tượng một cổng làm trung ương cho một luồng tích hợp đơn giản nhận một chuỗi và chuyển đổi chuỗi đã cho thành chữ in hoa. Giao diện cổng có thể trông giống như sau:









package sia6;

import org.springframework.integration.annotation.MessagingGateway;
import org.springframework.stereotype.Component;

@Component
@MessagingGateway(defaultRequestChannel="inChannel", defaultReplyChannel="outChannel")
public interface UpperCaseGateway {
    String uppercase(String in);
}

Điều đặc biệt về giao diện này là không cần phải triển khai nó. Spring Integration tự động cung cấp một phiên bản chạy thời gian để gửi và nhận dữ liệu qua các kênh được chỉ định.

Khi phương thức `uppercase()` được gọi, chuỗi đã cho được xuất bản vào luồng tích hợp vào kênh có tên là `inChannel`. Bất kể cách luồng được định nghĩa hoặc làm gì, khi dữ liệu đến trên kênh có tên là `outChannel`, nó sẽ được trả lại từ phương thức `uppercase()`.

Còn về luồng tích hợp chữ in hoa, đó là một luồng tích hợp đơn giản chỉ có một bước để chuyển đổi chuỗi thành chữ in hoa. Dưới đây là cách nó được biểu diễn trong cấu hình Java DSL:

@Bean
public IntegrationFlow uppercaseFlow() {
    return IntegrationFlows
        .from("inChannel")
        .<String, String> transform(s -> s.toUpperCase())
        .channel("outChannel")
        .get();
}

Như được định nghĩa ở đây, luồng bắt đầu với dữ liệu đến trên kênh có tên là `inChannel`. Bạn sau đó chuyển đổi payload của tin nhắn bằng transformer, được định nghĩa ở đây dưới dạng biểu thức lambda, để thực hiện một phép chuyển đổi chữ in hoa. Message kết quả sau đó được xuất bản vào kênh có tên là `outChannel`, chính là kênh bạn đã khai báo là replyChannel cho giao diện UpperCaseGateway.

10.2.8 Channel adapters

Channel adapters đại diện cho các point vào và ra của một luồng tích hợp. Dữ liệu nhập vào một luồng tích hợp thông qua một inbound channel adapter và rời khỏi một luồng tích hợp thông qua một outbound channel adapter. Điều này được minh họa trong hình 10.9.
 

Inbound channel adapter có thể có nhiều dạng, phụ thuộc vào nguồn dữ liệu mà chúng giới thiệu vào luồng. Ví dụ, bạn có thể khai báo một inbound channel adapter để đọc dữ liệu từ một tệp hoặc một hệ thống message nhất định.

Ví dụ, bạn có thể khai báo một inbound channel adapter mà giới thiệu các số tăng từ một AtomicInteger2 vào luồng. Sử dụng cấu hình Java, nó có thể trông giống như sau:

@Bean
@InboundChannelAdapter(
  poller=@Poller(fixedRate="1000"), channel="numberChannel")
public MessageSource<Integer> numberSource(AtomicInteger source) {
  return () -> {
    return new GenericMessage<>(source.getAndIncrement());
  };
}

Phương thức `@Bean` này khai báo một bean @InboundChannelAdapter mà, theo chú thích @InboundChannelAdapter `, gửi một số từ `AtomicInteger` được inject vào kênh có tên là `numberChannel` mỗi 1 giây (hoặc 1.000 ms).

Trong khi @InboundChannelAdapter  chỉ định một inbound channel adapter khi sử dụng cấu hình Java, phương thức `from()` là cách thực hiện nó khi sử dụng Java DSL để định nghĩa luồng tích hợp. Đoạn mã sau đây của định nghĩa luồng hiển thị một bộ chuyển đổi kênh vào tương tự được định nghĩa trong Java DSL:

@Bean
public IntegrationFlow someFlow(AtomicInteger integerSource) {
  return IntegrationFlows
    .from(integerSource, "getAndIncrement",
        c -> c.poller(Pollers.fixedRate(1000)))
    ...
    .get();
}

Thường, các inbound channel adapter được cung cấp bởi một trong nhiều mô-đun end point của Spring Integration. Giả sử, ví dụ, bạn cần một inbound channel adapter giám sát một thư mục cụ thể và gửi bất kỳ tệp 

`AtomicInteger` là hữu ích để tăng giá trị của một bộ đếm trong một tình huống đa luồng, như tình huống ở đây, nơi nhiều thông điệp có thể đến trên kênh đồng thời.

nào được viết vào thư mục đó dưới dạng các message đến một kênh có tên là `file-channel`. Cấu hình Java sau sử dụng `FileReadingMessageSource` từ mô-đun end point file của Spring Integration để đạt được điều đó:
@Bean
@InboundChannelAdapter(channel="file-channel",
    poller=@Poller(fixedDelay="1000"))
public MessageSource<File> fileReadingMessageSource() {
  FileReadingMessageSource sourceReader = new FileReadingMessageSource();
  sourceReader.setDirectory(new File(INPUT_DIR));
  sourceReader.setFilter(new SimplePatternFileListFilter(FILE_PATTERN));
  return sourceReader;
}

Khi viết inbound channel adapter đọc tệp tương đương trong Java DSL, phương thức `inboundAdapter()` từ lớp `Files` đạt được điều tương tự. Như được hiển thị bên dưới, một outbound channel adapter là điểm cuối của luồng tích hợp, chuyển tiếp message cuối cùng cho ứng dụng hoặc hệ thống khác:

@Bean
public IntegrationFlow fileReaderFlow() {
  return IntegrationFlows
    .from(Files.inboundAdapter(new File(INPUT_DIR))
    .patternFilter(FILE_PATTERN))
    .get();
}

Service activators, được triển khai như các trình xử lý message, thường phục vụ mục đích của một outbound channel adapter, đặc biệt là khi dữ liệu cần được chuyển giao cho ứng dụng. Chúng ta đã thảo luận về service activators, vì vậy không cần lặp lại phần thảo luận đó.

Tuy nhiên, đáng chú ý rằng các mô-đun end point của Spring Integration cung cấp các trình xử lý message hữu ích cho một số trường hợp sử dụng thông thường. 
Bạn đã thấy một ví dụ về một outbound channel adapter  như vậy, FileWritingMessageHandler, trong đoạn mã 10.3. Nói về các mô-đun end point của Spring Integration, hãy nhìn nhanh vào những mô-đun tích hợp sẵn sàng sử dụng là gì.

Module	Dependency artifact ID (Group ID:
org.springframework.integration)
Email 
	spring-integration-mail
Filesystem	spring-integration-file

FTP/FTPS	spring-integration-ftp

GemFire	spring-integration-gemfire

HTTP	spring-integration-http

JDBC	spring-integration-jdbc

JMS	spring-integration-jms

JMX	spring-integration-jmx

JPA	spring-integration-jpa

Kafka	spring-integration-kafka

MongoDB	spring-integration-mongodb

MQTT	spring-integration-mqtt

R2DBC	spring-integration-r2dbc

Redis	spring-integration-redis

RMI	spring-integration-rmi

RSocket	spring-integration-rsocket

SFTP	spring-integration-sftp

STOMP	spring-integration-stomp

Stream	spring-integration-stream

Syslog	spring-integration-syslog

TCP/UDP	spring-integration-ip

WebFlux	spring-integration-webflux

Web Services	spring-integration-ws

WebSocket	spring-integration-websocket

XMPP	spring-integration-xmpp

ZeroMQ 	spring-integration-zeromq

ZooKeeper	spring-integration-zookeeper


10.3 Creating an email integration flow
Bạn đã quyết định rằng Taco Cloud nên cho phép khách hàng của mình đặt món taco bằng cách gửi thiết kế và đơn hàng qua email. Bạn đã phát tờ rơi và đặt quảng cáo mua mang về trong các tờ báo, mời mọi người gửi đơn hàng taco của họ qua email. Điều này là một thành công lớn! Thật không may, nó quá thành công. Có quá nhiều email đang đến, bạn phải thuê người tạm thời chỉ để đọc tất cả các email và đưa thông tin đặt hàng vào hệ thống đặt hàng.

Trong phần này, bạn sẽ triển khai một luồng tích hợp để kiểm tra hộp thư đến của Taco Cloud để lấy các email đặt hàng taco, phân tích email để có thông tin đơn hàng và gửi đơn hàng đến Taco Cloud để xử lý. Nói một cách ngắn gọn, luồng tích hợp bạn sẽ cần sử dụng một inbound channel adapter từ mô-đun end point email để đưa email từ hộp thư đến của Taco Cloud vào luồng tích hợp.

Bước tiếp theo trong luồng tích hợp sẽ phân tích các email thành các đối tượng Order được chuyển cho một xử lý viên khác để gửi đơn hàng đến REST API của Taco Cloud, nơi chúng sẽ được xử lý giống như bất kỳ đơn đặt hàng nào khác. Để bắt đầu, hãy định nghĩa một lớp cấu hình đơn giản để lưu thông tin cụ thể về cách xử lý các email của Taco Cloud, như dưới đây:
@Data
@ConfigurationProperties(prefix = "tacocloud.email")
@Component
public class EmailProperties {
    private String username;
    private String password;
    private String host;
    private String mailbox;
    private long pollRate = 30000;

    public String getImapUrl() {
        return String.format("imaps://localhost:%s@localhost/%s", this.username, this.mailbox);
    }

}

Như bạn có thể thấy, `EmailProperties` chứa các thuộc tính được sử dụng để tạo ra một URL IMAP. Luồng sử dụng URL này để kết nối đến máy chủ email của Taco Cloud và kiểm tra email. Trong số các thuộc tính được chứa có tên người dùng (username) và mật khẩu của người dùng email, cũng như tên máy chủ IMAP, hòm thư để kiểm tra, và tần suất mà hòm thư được kiểm tra (mặc định là mỗi 30 giây).

Lớp `EmailProperties` được đánh dấu ở mức lớp với `@ConfigurationProperties` và có thuộc tính `prefix` được thiết lập thành `tacocloud.email`. Điều này có nghĩa là bạn có thể cấu hình chi tiết về việc tiêu thụ email trong tệp `application.yml` như sau:

tacocloud:
  email:
    host: localhost
    mailbox: INBOX
    username: taco-in-flow
    password: 123456
    poll-rate: 10000

Tất nhiên, cấu hình máy chủ email ở đây là hư cấu. Bạn cần điều chỉnh chúng để phản ánh chi tiết cụ thể của máy chủ email mà bạn đang sử dụng.
Ngoài ra, bạn có thể nhận được cảnh báo "unknown property" trong IDE của bạn. Điều này xảy ra vì IDE đang tìm kiếm siêu dữ liệu mà nó cần để hiểu ý nghĩa của những thuộc tính đó. Cảnh báo này không làm hỏng mã nguồn thực tế, và bạn có thể bỏ qua nó nếu muốn. Hoặc bạn có thể làm cho cảnh báo biến mất bằng cách thêm dependency sau vào build của bạn (cũng có sẵn như một tùy chọn Spring Initializr gọi là "Spring Configuration Processor"):

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-configuration-processor</artifactId>
   <optional>true</optional>
</dependency>

Dựa vào yêu cầu này bao gồm hỗ trợ tự động tạo ra siêu dữ liệu cho các thuộc tính cấu hình tùy chỉnh như những cái chúng ta đang sử dụng để cấu hình chi tiết máy chủ email.

Bây giờ hãy sử dụng EmailProperties để cấu hình luồng tích hợp. Luồng bạn đang cố gắng tạo ra sẽ trông giống như hình 10.10 một chút.

Bạn có hai lựa chọn sau khi định nghĩa luồng này:
* Định nghĩa nó trong chính ứng dụng Taco Cloud. Ở cuối luồng, một service activator sẽ gọi vào các repository bạn đã định nghĩa để tạo đơn taco.
* Định nghĩa nó như một ứng dụng riêng lẻ. Ở cuối luồng, một service activator vụ sẽ gửi một yêu cầu POST đến API Taco Cloud để gửi đơn đặt taco.


 


Listing 10.5 Defining an integration flow to accept emails and submit them as orders \
package sia.email;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.Pollers;
import org.springframework.integration.mail.dsl.Mail;

@Configuration
public class TacoOrderEmailIntegrationConfig {

    @Bean
    public IntegrationFlow tacoOrderEmailFlow(
            EmailProperties emailProps
            , EmailToOrderTransformer transformer
            , OrderSubmitMessageHandler handler) {
        return IntegrationFlows
                .from(Mail.imapInboundAdapter(emailProps.getImapUrl()), 
                        e -> e.poller(Pollers.fixedDelay(emailProps.getPollRate())))
                .transform(transformer)
                .handle(handler)
                .get();
    }
}


Taco order email flow, như được định nghĩa trong phương thức tacoOrderEmailFlow(), bao gồm ba thành phần rõ ràng sau đây:
 An IMAP email inbound channel adapter  - channel adapter này được tạo với URL IMAP được tạo ra từ phương thức getImapUrl() của EmailProperties và thăm dò theo khoảng thời gian trễ được đặt trong thuộc tính pollRate của EmailProperties. Các email đến được chuyển giao cho một channel kết nối nó với bộ biến đổi.
 A transformer that transforms an email into an order object— - Bộ biến đổi được thực hiện trong EmailToOrderTransformer, được chèn vào trong phương thức tacoOrderEmailFlow(). Các đơn đặt hàng kết quả từ quá trình biến đổi được chuyển giao cho thành phần cuối cùng thông qua một kênh khác.
 A handler (hoạt động như outbound channel adapter) - Xử lý chấp nhận một đối tượng đặt hàng và gửi nó đến REST API của Taco Cloud.
Cuộc gọi đến Mail.imapInboundAdapter() là có thể nhờ có sự bao gồm của mô-đun Email endpoint như là một phụ thuộc trong dự án xây dựng của bạn. Phụ thuộc Maven trông như sau:

<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-mail</artifactId>
</dependency>

Lớp EmailToOrderTransformer là một triển khai của giao diện Transformer trong Spring Integration, thông qua việc mở rộng AbstractMailMessageTransformer (được hiển thị trong đoạn mã sau).

Listing 10.6 Converting incoming emails to taco orders using an integration transformer 
package sia.email;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.springframework.integration.mail.transformer.AbstractMailMessageTransformer;
import org.springframework.integration.support.AbstractIntegrationMessageBuilder;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.stereotype.Component;
import sia.email.domain.Ingredient;
import sia.email.domain.Taco;

import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Component
@Slf4j
public class EmailToOrderTransformer 
        extends AbstractMailMessageTransformer<EmailOrder> {

    private static final String SUBJECT_KEYWORDS = "TACO ORDER";

    @Override
    protected AbstractIntegrationMessageBuilder<EmailOrder>
                doTransform(Message mailMessage) throws Exception {
        EmailOrder tacoOrder = processPayload(mailMessage);
        return MessageBuilder.withPayload(tacoOrder);
    }

    private EmailOrder processPayload(Message mailMessage) {
        try {
            String subject = mailMessage.getSubject();
            log.info("subject: {}", subject);
            if(subject.toUpperCase().contains(SUBJECT_KEYWORDS)) {
                String email = ((InternetAddress) mailMessage.getFrom()[0]).getAddress();
                log.info("email: {}", email);
                String content = mailMessage.getContent().toString();
                log.info("content: {}", content);
                return parseEmailToOrder(email, content);
            }
        } catch (MessagingException e) {
            log.error("MessagingException: {}", e);
        } catch (IOException e) {
            log.error("IOException: {}", e);
        }
        return null;
    }

    private EmailOrder parseEmailToOrder(String email, String content) {
        EmailOrder order = new EmailOrder(email);
        String[] lines = content.split("\n");
        for (String line : lines) {
            if(line.trim().length() > 0 && line.contains(":")) {
                String[] lineSplit = line.split(":");
                String tacoName = lineSplit[0].trim();
                String ingredients = lineSplit[1].trim();
                String[] ingredientsSplit = ingredients.split(",");
                List<String> ingredientCodes = new ArrayList<>();
                for (String ingredientName : ingredientsSplit) {
                    String code = lookupIngredientCode(ingredientName.trim());
                    if(code != null) {
                        ingredientCodes.add(code);
                    }
                }
                Taco taco = new Taco(tacoName);
                taco.setIngredients(ingredientCodes);
                order.addTaco(taco);
            }
        }
        return order;
    }

    private String lookupIngredientCode(String ingredientName) {
        for (Ingredient ingredient : ALL_INGREDIENTS) {
            String ucIngredientName = ingredientName.toUpperCase();
            if(LevenshteinDistance.getDefaultInstance()
                    .apply(ucIngredientName, ingredient.getName()) < 3 ||
                    ucIngredientName.contains(ingredient.getName()) ||
                    ingredient.getName().contains(ucIngredientName)) {
                return ingredient.getId();
            }
        }
        return null;
    }

    private static Ingredient[] ALL_INGREDIENTS = new Ingredient[] {
            new Ingredient("FLTO", "FLOUR TORTILLA"),
            new Ingredient("COTO", "CORN TORTILLA"),
            new Ingredient("GRBF", "GROUND BEEF"),
            new Ingredient("CARN", "CARNITAS"),
            new Ingredient("TMTO", "TOMATOES"),
            new Ingredient("LETC", "LETTUCE"),
            new Ingredient("CHED", "CHEDDAR"),
            new Ingredient("JACK", "MONTERREY JACK"),
            new Ingredient("SLSA", "SALSA"),
            new Ingredient("SRCR", "SOUR CREAM")
    };

}
`AbstractMailMessageTransformer` là một lớp cơ sở tiện lợi để xử lý các tin nhắn có payload là một email. Nó chịu trách nhiệm trích xuất thông tin email từ message inbound vào một đối tượng Message được chuyển vào phương thức `doTransform()`.

Trong phương thức `doTransform()`, bạn chuyển đối tượng Message vào một phương thức riêng tư được đặt tên là `processPayload()` để phân tích email thành một đối tượng EmailOrder. Mặc dù tương tự, nhưng đối tượng EmailOrder ở đây không giống với đối tượng TacoOrder được sử dụng trong ứng dụng chính Taco Cloud; nó đơn giản hơn một chút, như được hiển thị sau đây:

@Data
public class EmailOrder {
    private final String email;
    private List<Taco> tacos = new ArrayList<>();

    public void addTaco(Taco taco) {
        this.tacos.add(taco);
    }
}


Thay vì mang theo toàn bộ thông tin về order và payment của khách hàng, lớp EmailOrder này chỉ chứa địa chỉ email của khách hàng, được lấy từ email đầu vào. Việc phân tích email thành đơn đặt taco là một công việc không đơn giản. Thực tế, thậm chí một cách triển khai ngây thơ cũng liên quan đến một vài chục dòng mã. Những dòng mã đó không làm gì khác ngoài việc mở rộng thảo luận về Spring Integration và cách triển khai một bộ biến đổi.
Do đó, để tiết kiệm không gian, tôi sẽ bỏ qua chi tiết của phương thức `processPayload()`.

Điều cuối cùng mà EmailToOrderTransformer làm là trả về một MessageBuilder với một payload chứa đối tượng EmailOrder. Tin nhắn được tạo ra bởi MessageBuilder được gửi đến thành phần cuối cùng trong luồng tích hợp: một bộ xử lý message đưa đơn đặt hàng đến API của Taco Cloud. OrderSubmitMessageHandler, như được hiển thị trong đoạn mã tiếp theo, triển khai GenericHandler của Spring Integration để xử lý message có payload là EmailOrder.

Listing 10.7 Posting orders to the Taco Cloud API via a message handler 

package sia.email;

import org.springframework.integration.handler.GenericHandler;
import org.springframework.messaging.MessageHeaders;
import org.springframework.web.client.RestTemplate;
import sia.email.domain.EmailOrder;

public class OrderSubmitMessageHandler implements GenericHandler<EmailOrder> {
    private RestTemplate rest;
    private ApiProperties apiProps;

    public OrderSubmitMessageHandler(ApiProperties apiProps,
                                     RestTemplate rest) {
        this.apiProps = apiProps;
        this.rest = rest;
    }

    @Override
    public Object handle(EmailOrder payload, MessageHeaders headers) {
        rest.postForObject(apiProps.getUrl(), payload, String.class);
        return null;
    }
}


Để đáp ứng yêu cầu của giao diện GenericHandler, OrderSubmitMessageHandler ghi đè phương thức handle(). Phương thức này nhận đối tượng EmailOrder đến và sử dụng RestTemplate được chèn để gửi EmailOrder thông qua một yêu cầu POST đến URL được ghi lại trong một đối tượng ApiProperties được chèn vào. Cuối cùng, phương thức handle() trả về null để chỉ định rằng xử lý này đánh dấu cuối của luồng.

ApiProperties được sử dụng để tránh việc cứng cố URL trong cuộc gọi đến postForObject(). Đây là một tệp cấu hình thuộc tính mẫu như sau:

package sia.email;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@ConfigurationProperties(prefix = "tacocloud.api")
@Component
public class ApiProperties {
    private String url;
}


Và trong tệp application.yml, URL cho API của Taco Cloud có thể được cấu hình như sau:
tacocloud:
  api:
    url: http://localhost:8080/orders/fromEmail

Để làm cho RestTemplate có sẵn trong dự án để có thể chèn vào OrderSubmitMessageHandler, bạn cần thêm Spring Boot web starter vào dự án build như sau:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

Mặc dù điều này khiến RestTemplate có sẵn trong classpath, nhưng cũng kích hoạt tự động cấu hình cho Spring MVC. Nhưng trong một luồng Spring Integration độc lập, ứng dụng không cần Spring MVC hoặc thậm chí Tomcat tích hợp mà tự động cấu hình cung cấp.

Do đó, bạn nên tắt tự động cấu hình Spring MVC với mục sau trong application.yml:

spring:
  main:
    web-application-type: none

Thuộc tính `spring.main.web-application-type` có thể được đặt thành servlet, reactive, hoặc none. Khi Spring MVC có trong classpath, tự động cấu hình đặt giá trị này thành servlet. Nhưng ở đây, bạn ghi đè nó thành none để Spring MVC và Tomcat sẽ không được tự động cấu hình. (Chúng ta sẽ nói thêm về ý nghĩa của việc một ứng dụng là một ứng dụng web reactive trong chương 12.)

Part 3 - Reactive Spring

Trong phần 3, chúng ta sẽ khám phá sự hỗ trợ cho lập trình reactive trong Spring.
Chương 11 thảo luận về những điều cơ bản của lập trình reactive với Project Reactor,
thư viện lập trình reactive làm nền tảng cho các tính năng reactive của Spring.
Sau đó, chúng ta sẽ xem xét một số hoạt động reactive hữu ích nhất của Reactor. 
Chương 12, chúng ta sẽ đưa ra REST API development, giới thiệu Spring WebFlux, một framework web
mang nhiều đặc điểm từ Spring MVC mà vẫn cung cấp một mô hình reactive mới cho phát triển web. 
Chương 13 nhìn vào việc viết dữ liệu reactive persistence với Spring Data để đọc và ghi dữ liệu vào các cơ sở dữ liệu Cassandra và Mongo.
Chương 14 kết thúc phần 3 bằng cách nhìn vào RSocket, một giao thức truyền thông
cho phép một giải pháp reactive thay thế cho HTTP.


Chapter 11- Introducing Reactor

This chapter covers
 Understanding reactive programming
 Project Reactor
 Operating on data reactively

Bạn có bao giờ đăng ký đọc báo hoặc tạp chí chưa? Internet chắc chắn đã ảnh hưởng đến số lượng độc giả của các tờ báo truyền thống, nhưng có một thời điểm mà việc đăng ký đọc báo hàng ngày là một trong những cách tốt nhất để cập nhật thông tin sự kiện hàng ngày. Bạn có thể tin tưởng vào việc nhận báo hàng ngày để đọc trong bữa sáng hoặc trên đường đi làm.

Giả sử, sau khi thanh toán đăng ký, một vài ngày trôi qua mà không có báo nào được gửi đến. Thêm vài ngày nữa, bạn gọi điện thoại đến văn phòng bán báo để hỏi tại sao bạn vẫn chưa nhận được báo hàng ngày. Hãy tưởng tượng sự ngạc nhiên của bạn nếu họ giải thích, "Bạn đã thanh toán cho một năm đầy đủ báo. Năm chưa kết thúc. Bạn sẽ chắc chắn nhận được tất cả khi năm đầy đủ báo sẵn sàng."

May mắn thay, đây không phải là cách mà hệ thống đăng ký hoạt động. Báo có tính chất thời gian cụ thể. Chúng được phát nhanh chóng sau khi xuất bản để đảm bảo nội dung mới nhất khi đọc. Hơn nữa, khi bạn đang đọc số mới nhất, các nhà báo đang viết câu chuyện mới cho các bản in tương lai, và các máy in đã được kích hoạt để sản xuất số tiếp theo - tất cả diễn ra đồng thời.

Khi chúng ta phát triển mã ứng dụng, có thể viết hai loại mã - Imperative và Reactive, mô tả như sau:
- Imperative (mệnh lệnh) giống như việc đăng ký đọc báo ảo không thực tế ấy. Nó là một chuỗi các công việc tuần tự, mỗi công việc chạy lần lượt, mỗi công việc sau công việc trước. Dữ liệu được xử lý theo lô và không thể chuyển giao cho công việc tiếp theo cho đến khi công việc trước đã hoàn thành công việc của mình trên lô dữ liệu.
- Reactive (phản ứng) giống như việc đăng ký đọc báo thực tế. Một tập hợp các công việc được định nghĩa để xử lý dữ liệu, nhưng các công việc này có thể chạy đồng thời. Mỗi công việc có thể xử lý một phần nhỏ của dữ liệu và chuyển giao nó cho công việc tiếp theo trong hàng đợi trong khi nó tiếp tục làm việc trên một phần khác của dữ liệu.

Trong chương này, chúng ta sẽ tạm thời rời xa ứng dụng Taco Cloud để tìm hiểu về Project Reactor (https://projectreactor.io/). Reactor là một thư viện cho lập trình phản ứng - reactive là một phần của dự án Spring. Và bởi vì nó là cơ sở của sự hỗ trợ của Spring cho lập trình reactive, việc hiểu biết về Reactor là quan trọng trước khi chúng ta tìm hiểu về việc xây dựng các controller và repository reactive với Spring. Trước khi chúng ta bắt đầu làm việc với Reactor, tuy nhiên, hãy nhanh chóng xem xét những điều cơ bản của lập trình reactive.

11.1 Understanding reactive programming


Lập trình reactive là một mô hình thay thế cho lập trình imperative. Sự thay thế này tồn tại vì lập trình reactive giải quyết một hạn chế trong lập trình imperative. Bằng cách hiểu rõ những hạn chế này, bạn có thể hiểu rõ hơn về những lợi ích của mô hình reactive.

LƯU Ý: Lập trình reactive không phải là một giải pháp toàn diện. Bạn không nên suy ra từ chương này hoặc bất kỳ cuộc thảo luận nào khác về lập trình reactive rằng lập trình imperative là xấu xa và lập trình reactive là cứu tinh. Như mọi điều bạn học làm một nhà phát triển, lập trình reactive hoàn toàn phù hợp trong một số trường hợp sử dụng và không phù hợp trong những trường hợp khác. Một chút thiện chí là cần thiết.

Nếu bạn giống như tôi và nhiều nhà phát triển khác, bạn đã bắt đầu với lập trình imperative. Có khả năng cao là hầu hết (hoặc tất cả) mã bạn viết ngày nay vẫn mang tính mệnh lệnh imperative. Lập trình imperative đủ dễ hiểu đến mức sinh viên trẻ có thể học nó một cách dễ dàng trong các chương trình STEM của trường học, và đủ mạnh mẽ để tạo thành phần lớn của mã nguồn điều khiển các doanh nghiệp lớn nhất.

Ý tưởng rất đơn giản: bạn viết mã như là một danh sách các hướng dẫn để thực hiện, mỗi lần một lần, theo thứ tự mà chúng được gặp phải. Một công việc được thực hiện và chương trình đợi nó hoàn thành trước khi chuyển sang công việc tiếp theo. Tại mỗi bước dọc theo đường đi, dữ liệu cần được xử lý phải được đầy đủ để có thể xử lý toàn bộ.

Mọi thứ diễn ra suôn sẻ... cho đến khi không còn. Trong khi một công việc đang được thực hiện đặc biệt là nếu đó là một công việc I/O, chẳng hạn như ghi dữ liệu vào cơ sở dữ liệu hoặc lấy dữ liệu từ một máy chủ từ xa luồng gọi công việc đó bị chặn, không thể thực hiện bất kỳ công việc nào khác cho đến khi công việc hoàn thành. Nói một cách thẳng thắn, các luồng bị chặn là lãng phí.

Hầu hết các ngôn ngữ lập trình, bao gồm cả Java, hỗ trợ lập trình đồng thời. Việc kích hoạt một luồng khác trong Java và gửi nó thực hiện một số công việc trong khi luồng gọi tiếp tục với một công việc khác là khá dễ dàng. Nhưng mặc dù việc tạo ra các luồng dễ dàng, những luồng đó có thể kết thúc bị chặn. Quản lý đồng thời hóa trong nhiều luồng là một thách thức. Càng có nhiều luồng, thì càng phức tạp. 

Ngược lại, lập trình reactive có tính chất hàm functional và khai báo declarative. Thay vì mô tả một bộ các bước cần được thực hiện theo thứ tự, lập trình reactive bao gồm việc mô tả một đường ống hoặc dòng dữ liệu mà thông tin chảy qua. Thay vì yêu cầu dữ liệu phải sẵn có và được xử lý như một toàn bộ, một luồng phản reactive lý dữ liệu ngay khi nó trở nên khả dụng. Trên thực tế, dữ liệu đầu vào có thể là vô tận (ví dụ: một dòng liên tục của dữ liệu nhiệt độ thời gian thực của một địa điểm).

LƯU Ý: Nếu bạn mới bắt đầu với lập trình hàm trong Java, bạn có thể muốn xem sách "Functional Programming in Java" của Pierre-Yves Saumont (Manning, 2017), hoặc "Grokking Functional Programming" của Michał Płachta (Manning, 2021).

Để áp dụng một so sánh thực tế, hãy coi lập trình imperative như một quả bóng nước và lập trình reactive như một dây nước vườn. Cả hai đều là cách thích hợp để bất ngờ và làm ướt một người bạn không ngờ vào một ngày hè nóng. Tuy nhiên, chúng khác biệt về phong cách thực hiện như sau:
- Một quả bóng nước mang theo toàn bộ nước của nó, làm ướt mục tiêu mong muốn ngay khi va chạm. Tuy nhiên, quả bóng nước có khả năng cung cấp hữu hạn, và nếu bạn muốn làm ướt nhiều người hơn (hoặc cùng một người nhiều hơn), lựa chọn của bạn chỉ là tăng cường bằng cách tăng số lượng quả bóng nước.
- Một dây nước mang theo nước như một dòng từ vòi sen đến ống phun. Dung tích của dây nước có thể giới hạn tại mọi thời điểm, nhưng nó không có giới hạn trong suốt một cuộc chiến nước. Miễn là nước đang nhập vào dây nước từ vòi sen, nó sẽ tiếp tục chảy qua ống và phun ra khỏi ống. Cùng một dây nước có thể dễ dàng mở rộng để làm ướt bất kỳ số người nào bạn muốn.

Không có gì sai với quả bóng nước (hoặc lập trình imperative), nhưng người giữ dây nước (hoặc thực hiện lập trình reactive) có một lợi thế về khả năng mở rộng và hiệu suất.

11.1.1 Defining Reactive Streams 
Reactive Streams là một sáng kiến được khởi đầu vào cuối năm 2013 bởi các kỹ sư từ Netflix, Lightbend và Pivotal (công ty đứng sau dự án Spring). Reactive Streams nhằm cung cấp một tiêu chuẩn cho xử lý luồng bất đồng bộ asynchronous stream với cơ chế đối với áp lực không chặn nonblocking. Chúng ta đã đề cập đến tính chất bất đồng bộ của lập trình reactive; đó là điều cho phép chúng ta thực hiện các công việc song song để đạt được khả năng mở rộng lớn hơn. backpressure (áp lực ngược) là một phương tiện mà người tiêu thụ dữ liệu có thể tránh bị áp đặt bởi một nguồn dữ liệu quá nhanh bằng cách thiết lập giới hạn về lượng dữ liệu mà họ sẵn lòng xử lý.
Java streams vs. Reactive Streams

Có rất nhiều điểm tương đồng giữa Java streams và Reactive Streams. Để bắt đầu, cả hai đều chứa từ "streams" trong tên của họ. Cả hai cũng cung cấp một functional API để làm việc với dữ liệu. Trên thực tế, như bạn sẽ thấy sau khi chúng ta xem xét Reactor, chúng thậm chí còn chia sẻ nhiều hoạt động giống nhau.
Tuy nhiên, Java streams thường đồng bộ và hoạt động với một tập dữ liệu hữu hạn. Chúng về cơ bản là một phương tiện để lặp qua một collections với các functional.

Reactive Streams hỗ trợ xử lý bất đồng bộ của các bộ dữ liệu có kích thước bất kỳ, bao gồm cả các bộ dữ liệu vô tận. Chúng xử lý dữ liệu theo thời gian thực, ngay khi nó trở nên khả dụng, với backpressure (áp lực ngược) để tránh làm cho người tiêu thụ của chúng bị quá tải.

Ngược lại, API Flow của JDK 9 tương ứng với Reactive Streams. Các loại Flow.Publisher, Flow.Subscriber, Flow.Subscription và Flow.Processor trong JDK 9 tương ứng trực tiếp với Publisher, Subscriber, Subscription và Processor trong Reactive Streams. Tuy nhiên, API Flow của JDK 9 không phải là một hiện thực thực sự của Reactive Streams.

Đặc tả Reactive Streams có thể được tóm tắt thông qua bốn định nghĩa giao diện: Publisher, Subscriber, Subscription và Processor. Một Publisher sản xuất dữ liệu và gửi nó đến một Subscriber thông qua một Subscription. Giao diện Publisher khai báo một phương thức duy nhất, là subscribe(), thông qua đó một Subscriber có thể đăng ký với Publisher, như sau:

public interface Publisher<T> {
    void subscribe(Subscriber<? super T> subscriber);
}

Khi một Subscriber đã đăng ký, nó có thể nhận sự kiện từ Publisher. Các sự kiện này được gửi qua các phương thức trên giao diện Subscriber như sau:

public interface Subscriber<T> {
    void onSubscribe(Subscription sub);
    void onNext(T item);
    void onError(Throwable ex);
    void onComplete();
}

Sự kiện đầu tiên mà Subscriber sẽ nhận được là thông qua việc gọi onSubscribe(). Khi Publisher gọi onSubscribe(), nó truyền một đối tượng Subscription cho Subscriber. Qua Subscription này, Subscriber có thể quản lý đăng ký của mình, như sau:

public interface Subscription {
    void request(long n);
    void cancel();
}

Subscriber có thể gọi request() để yêu cầu việc gửi dữ liệu, hoặc có thể gọi cancel() để chỉ định rằng nó không còn quan tâm đến việc nhận dữ liệu và đang hủy đăng ký. Khi gọi request(), Subscriber truyền vào một giá trị long để chỉ định số lượng mục dữ liệu mà nó sẵn lòng chấp nhận. Đây là nơi áp lực đối với phía sau đến, ngăn chặn Publisher gửi nhiều dữ liệu hơn mà Subscriber có thể xử lý. Sau khi Publisher đã gửi số mục được yêu cầu, Subscriber có thể gọi request() lại để yêu cầu thêm.

Khi Subscriber đã yêu cầu dữ liệu, dữ liệu bắt đầu chảy qua luồng. Đối với mỗi mục được xuất bản bởi Publisher, phương thức onNext() sẽ được gọi để gửi dữ liệu đến Subscriber. Nếu có bất kỳ lỗi nào, phương thức onError() sẽ được gọi. Nếu Publisher không có thêm dữ liệu để gửi và không có kế hoạch sản xuất thêm dữ liệu, nó sẽ gọi onComplete() để thông báo cho Subscriber biết rằng nó đã kết thúc hoạt động.

Đối với giao diện Processor, nó là sự kết hợp của Subscriber và Publisher, như sau:

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {}

Như một Subscriber, Processor sẽ nhận dữ liệu và xử lý nó theo một cách nào đó. Sau đó, nó sẽ chuyển đổi và đóng vai trò như một Publisher để xuất bản kết quả cho Subscribers của nó.

Như bạn có thể thấy, đặc tả Reactive Streams khá đơn giản. Bạn có thể dễ dàng thấy cách bạn có thể xây dựng một đường ống xử lý dữ liệu bắt đầu từ một Publisher, đẩy dữ liệu qua một hoặc nhiều Processor, và sau đó gửi kết quả cuối cùng cho một Subscriber.

Tuy nhiên, những giao diện Reactive Streams không thích hợp để xây dựng một luồng như vậy theo cách hàm. Project Reactor là một hiện thực của đặc tả Reactive Streams cung cấp một API chức năng để xây dựng Reactive Streams. Như bạn sẽ thấy trong các chương sau, Reactor là nền tảng cho mô hình lập trình reactive của Spring. Trong phần còn lại của chương này, chúng ta sẽ khám phá (và dám nói, có rất nhiều niềm vui với) Project Reactor.

11.2 Getting started with Reactor

Lập trình reactive yêu cầu chúng ta suy nghĩ theo một cách rất khác so với lập trình imperative. Thay vì mô tả một tập hợp các bước cần được thực hiện, lập trình phản reactive nghĩa với việc xây dựng một đường ống qua đó dữ liệu sẽ chảy. Khi dữ liệu đi qua đường ống, nó có thể được thay đổi hoặc sử dụng theo một cách nào đó.

Ví dụ, giả sử bạn muốn lấy tên của một người, chuyển đổi tất cả các chữ cái thành chữ in hoa, sử dụng nó để tạo một thông báo chào và cuối cùng là in nó ra. Trong mô hình lập trình imperative, đoạn mã có thể trông giống như sau:

String name = "Craig";
String capitalName = name.toUpperCase();
String greeting = "Hello, " + capitalName + "!";
System.out.println(greeting);
Trong mô hình mệnh lệnh, mỗi dòng mã thực hiện một bước, một sau một, và chắc chắn là trong cùng một luồng. Mỗi bước chặn luồng thực thi từ chuyển đến bước tiếp theo cho đến khi hoàn thành.

Ngược lại, với functional và reactive có thể đạt được điều tương tự như sau:
Mono.just("Craig")
    .map(n -> n.toUpperCase())
    .map(cn -> "Hello, " + cn + "!")
    .subscribe(System.out::println);
Đừng lo lắng quá về chi tiết của ví dụ này; chúng ta sẽ nói về tất cả về các hoạt động just(), map(), và subscribe() đủ sớm. Hiện tại, quan trọng là hiểu rằng mặc dù ví dụ reactive vẫn dường như tuân theo mô hình từng bước, nhưng thực tế đó là một đường ống mà dữ liệu chảy qua. Tại mỗi giai đoạn của đường ống, dữ liệu được điều chỉnh một cách nào đó, nhưng không thể đưa ra giả định nào về luồng nào thực hiện các hoạt động. Chúng có thể là cùng một luồng... hoặc cũng có thể không phải. 

Các lớp Mono và Flux trong ví dụ là hai loại cơ bản của Reactor. Flux là loại khác. Cả hai đều là các triển khai của Publisher trong Reactive Streams. Một Flux đại diện cho một đường ống của zero, one, hoặc nhiều (có thể là vô hạn) mục dữ liệu. Một Mono là một loại phản ứng chuyên biệt được tối ưu hóa cho trường hợp tập dữ liệu được biết đến không có nhiều hơn một mục dữ liệu.


Reactor vs. RxJava (ReactiveX)

Nếu bạn đã quen với RxJava hoặc ReactiveX, bạn có thể nghĩ rằng Mono và Flux nghe có vẻ giống như Observable và Single. Trên thực tế, chúng gần như tương đương về mặt ngữ nghĩa. Chúng thậm chí cung cấp nhiều hoạt động giống nhau.

Mặc dù chúng tôi tập trung vào Reactor trong cuốn sách này, bạn có thể vui mừng biết rằng có thể chuyển đổi giữa các loại Reactor và RxJava. Hơn nữa, như bạn sẽ thấy trong các chương tiếp theo, Spring cũng có thể làm việc với các loại RxJava.

Ví dụ trước thực sự bao gồm ba đối tượng Mono. Hoạt động just() tạo ra đối tượng đầu tiên. Khi Mono phát ra một giá trị, giá trị đó được chuyển đến hoạt động map() để được viết hoa và sử dụng để tạo ra một Mono khác. Khi Mono thứ hai xuất bản dữ liệu của mình, nó được chuyển đến hoạt động map() thứ hai để thực hiện việc nối chuỗi String, kết quả của đó được sử dụng để tạo ra Mono thứ ba. Cuối cùng, cuộc gọi đến subscribe() đăng ký vào Mono, nhận dữ liệu và in ra màn hình.

11.2.1 Diagramming reactive flows

Các Reactive flow thường được minh họa bằng biểu đồ viên sỏi marble diagrams. Biểu đồ viên sỏi, ở dạng đơn giản nhất của chúng, mô tả một đường thời gian timeline của dữ liệu khi nó chảy qua một Flux hoặc Mono ở phía trên, một hoạt động ở giữa và timeline của Flux hoặc Mono kết quả ở phía dưới. Hình 11.1 hiển thị một mẫu biểu đồ viên sỏi cho một Flux. Như bạn có thể thấy, khi dữ liệu chảy qua Flux gốc, nó được xử lý thông qua một số hoạt động, dẫn đến một Flux mới thông qua đó dữ liệu được xử lý chảy qua.

 

Hình 11.2 hiển thị một biểu đồ viên sỏi tương tự, nhưng cho một Mono. Như bạn có thể thấy, sự khác biệt chính là một Mono sẽ có hoặc không có một mục dữ liệu hoặc một lỗi.

 

Ở phần 11.3, chúng ta sẽ khám phá nhiều hoạt động được hỗ trợ bởi Flux và Mono, và chúng ta sẽ sử dụng biểu đồ viên sỏi để hình dung cách chúng hoạt động.

11.2.2 Adding Reactor dependencies

Để bắt đầu với Reactor, thêm dependency sau vào file cấu hình dự án:

<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
</dependency>

Reactor cũng cung cấp một số hỗ trợ testing tốt. Bạn sẽ viết nhiều bài kiểm tra cho mã Reactor của mình, vì vậy bạn nên thêm dependency sau vào file cấu hình test:

<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>

Tôi giả định rằng bạn đang thêm các dependency này vào một dự án Spring Boot, mà nó sẽ quản lý dependency cho bạn, nên không cần phải chỉ định phần `<version>` cho các dependency này. Nhưng nếu bạn muốn sử dụng Reactor trong một dự án không phải Spring Boot, bạn sẽ cần thiết lập BOM (bill of materials) của Reactor trong file cấu hình build. Entry quản lý dependency sau đây thêm phiên bản 2020.0.4 của Reactor vào dự án:

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-bom</artifactId>
            <version>2020.0.4</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

Các ví dụ chúng ta sẽ làm việc trong chương này là độc lập và không liên quan đến các dự án Taco Cloud mà chúng ta đã làm việc trước đó. Do đó, có lẽ tốt nhất là tạo một dự án Spring mới với các dependency Reactor trong file cấu hình build và làm việc từ đó. Bây giờ Reactor đã có trong dự án của bạn, bạn có thể bắt đầu tạo các đường ống reactive với Mono và Flux. Trong phần còn lại của chương này, chúng ta sẽ đi qua một số hoạt động được cung cấp bởi Mono và Flux.

11.3 Applying common reactive operations

Flux và Mono là hai khối xây dựng quan trọng nhất được cung cấp bởi Reactor, và các hoạt động mà hai loại reactive này cung cấp là chất keo liên kết chúng lại để tạo ra các đường ống qua đó dữ liệu có thể chảy. Flux và Mono cung cấp hơn 500 hoạt động, có thể được phân loại lỏng lẻo như sau:

- Creation – Sự tạo
- Combination – Sự kết hợp
- Transformation – Sự chuyển đổi
- Logic 

Mặc dù việc kiểm tra từng trong số 500 hoạt động đó để xem chúng hoạt động như thế nào sẽ rất thú vị, nhưng đơn giản không đủ chỗ trong chương này. Tôi đã chọn một số hoạt động hữu ích nhất để thử nghiệm trong phần này. Chúng ta sẽ bắt đầu với các hoạt động tạo.

Lưu ý: Tại sao không có ví dụ cho Mono? Mono và Flux chia sẻ nhiều hoạt động giống nhau, nên việc hiển thị cùng một hoạt động hai lần, một lần cho Mono và một lần cho Flux, thường là không cần thiết. Hơn nữa, mặc dù các hoạt động của Mono hữu ích, chúng thường ít thú vị hơn so với các hoạt động tương tự của Flux. Hầu hết các ví dụ chúng ta sẽ làm việc với Flux. Hãy biết rằng Mono thường có các hoạt động tương đương.

11.3.1 Creating reactive types

Thường khi làm việc với các loại reactive trong Spring, bạn sẽ được cung cấp một Flux hoặc Mono từ một repository hoặc một dịch vụ, vì vậy bạn không cần phải tạo một cái mới. Tuy nhiên, đôi khi bạn sẽ cần tạo một publisher reactive mới.

Reactor cung cấp một số hoạt động để tạo ra Flux hoặc Mono. Trong phần này, chúng ta sẽ xem một số hoạt động tạo hữu ích nhất.

CREATING FROM OBJECTS
Nếu bạn có một hoặc nhiều đối tượng từ đó bạn muốn tạo một Flux hoặc Mono, bạn có thể sử dụng phương thức static `just()` trên Flux hoặc Mono để tạo một loại reactive với dữ liệu được điều khiển bởi những đối tượng đó. Ví dụ, phương thức kiểm thử sau tạo một Flux từ năm đối tượng String:

@Test
public void createAFlux_just() {
    Flux<String> fruitFlux = Flux
            .just("Apple", "Orange", "Grape", "Banana", "Straberry");

}

Tại điểm này, Flux đã được tạo ra, nhưng nó chưa có người đăng ký (subscriber). Mà không có bất kỳ người đăng ký nào, dữ liệu sẽ không chảy. Nghĩ về ngụ ý của việc tưới cây, bạn đã gắn ống dẫn nước với ống xịt, và có nước từ công ty cung cấp ở phía bên kia - nhưng cho đến khi bạn mở ống xịt, nước sẽ không chảy. Việc đăng ký cho một loại reactive là cách bạn bật dòng dữ liệu.

Để thêm một người đăng ký, bạn có thể gọi phương thức `subscribe()` trên Flux như sau:
fruitFlux.subscribe(
        f -> System.out.println("Here's some fruit: " + f)
);

Lambda được đưa vào phương thức subscribe() ở đây thực chất là một java.util.Consumer được sử dụng để tạo một Reactive Streams Subscriber. Sau khi gọi subscribe(), dữ liệu bắt đầu chảy. Trong ví dụ này, không có các hoạt động trung gian, nên dữ liệu chảy trực tiếp từ Flux đến Subscriber.

In ra các mục từ một Flux hoặc Mono ra console là một cách tốt để thấy loại reactive đang hoạt động. Nhưng một cách tốt hơn để thực sự kiểm thử một Flux hoặc Mono là sử dụng StepVerifier của Reactor. Được cung cấp một Flux hoặc Mono, StepVerifier đăng ký vào loại reactive và sau đó áp dụng các khẳng định đối với dữ liệu khi nó chảy qua luồng, cuối cùng xác nhận rằng luồng hoàn thành như mong đợi.

Ví dụ, để xác minh rằng dữ liệu đã được chỉ định chảy qua fruitFlux, bạn có thể viết một bài kiểm tra như sau:

Flux<String> fruitFlux = Flux
        .just("Apple", "Orange", "Grape", "Banana", "Strawberry");
StepVerifier.create(fruitFlux)
        .expectNext("Apple")
        .expectNext("Orange")
        .expectNext("Grape")
        .expectNext("Banana")
        .expectNext("Strawberry")
        .verifyComplete();
Trong trường hợp này, StepVerifier đăng ký vào Flux và sau đó xác nhận rằng mỗi mục khớp với tên trái cây mong đợi. Cuối cùng, nó xác nhận rằng sau khi Strawberry được tạo ra bởi Flux, Flux đã hoàn thành.

Đối với phần còn lại của các ví dụ trong chương này, bạn sẽ sử dụng StepVerifier để viết các bài kiểm tra học tập - các bài kiểm tra xác nhận hành vi và giúp bạn hiểu cách một điều gì đó hoạt động - để hiểu rõ một số hoạt động hữu ích nhất của Reactor.

CREATING FROM COLLECTIONS

Một Flux cũng có thể được tạo ra từ một mảng, Iterable hoặc Java Stream. Hình 11.3 minh họa cách điều này hoạt động thông qua marble diagram.

 

Để tạo một Flux từ một mảng, gọi phương thức tĩnh fromArray(), truyền vào mảng nguồn như sau:

@Test
public void createAFlux_fromArray() {
    String[] fruits = new String[]{
            "Apple", "Orange", "Grape", "Banana", "Strawberry"
    };

    Flux<String> fruitFlux = Flux.fromArray(fruits);
    StepVerifier.create(fruitFlux)
            .expectNext("Apple")
            .expectNext("Orange")
            .expectNext("Grape")
            .expectNext("Banana")
            .expectNext("Strawberry")
            .verifyComplete();
}

Vì mảng nguồn chứa các tên trái cây giống như khi tạo một Flux từ danh sách đối tượng, dữ liệu phát ra từ Flux sẽ có các giá trị giống nhau. Do đó, bạn có thể sử dụng cùng một StepVerifier như trước để xác nhận Flux này.

Nếu bạn cần tạo một Flux từ java.util.List, java.util.Set hoặc bất kỳ triển khai nào của java.lang.Iterable, bạn có thể chuyển nó vào phương thức tĩnh fromIterable(), như được thể hiện dưới đây:
@Test
public void createAFlux_fromIterable() {
    List<String> fruitList = new ArrayList<>();
    fruitList.add("Apple");
    fruitList.add("Orange");
    fruitList.add("Grape");
    fruitList.add("Banana");
    fruitList.add("Strawberry");

    Flux<String> fruitFlux = Flux.fromIterable(fruitList);
    StepVerifier.create(fruitFlux)
            .expectNext("Apple")
            .expectNext("Orange")
            .expectNext("Grape")
            .expectNext("Banana")
            .expectNext("Strawberry")
            .verifyComplete();
}

Hoặc nếu bạn có một Java Stream và muốn sử dụng nó làm nguồn cho một Flux, bạn có thể sử dụng phương thức fromStream(), như được thể hiện dưới đây:
@Test
public void createAFlux_fromStream() {
    Stream<String> fruitStream =
            Stream.of("Apple", "Orange", "Grape", "Banana", "Strawberry");
    Flux<String> fruitFlux = Flux.fromStream(fruitStream);
    StepVerifier.create(fruitFlux)
            .expectNext("Apple")
            .expectNext("Orange")
            .expectNext("Grape")
            .expectNext("Banana")
            .expectNext("Strawberry")
            .verifyComplete();
}

GENERATING FLUX DATA

Đôi khi bạn không có dữ liệu nào để làm việc và chỉ cần Flux hoạt động như một bộ đếm, phát ra một số tăng lên với mỗi giá trị mới. Để tạo một counter Flux, bạn có thể sử dụng phương thức tĩnh range(). Sơ đồ trong hình 11.4 minh họa cách range() hoạt động.

 
Phương thức kiểm thử sau minh họa cách tạo một Flux dãy số:

@Test
public void createAFlux_range() {
    Flux<Integer> intervalFlux = Flux.range(1, 5);
    StepVerifier.create(intervalFlux)
            .expectNext(1)
            .expectNext(2)
            .expectNext(3)
            .expectNext(4)
            .expectNext(5)
            .verifyComplete();
}

Trong ví dụ này, Range Flux được tạo ra với giá trị bắt đầu là 1 và giá trị kết thúc là 5. StepVerifier chứng minh rằng nó sẽ xuất bản năm mục, là các số nguyên từ 1 đến 5.
Một phương pháp tạo Flux khác tương tự như range() là interval(). Giống như phương thức range(), interval() tạo ra một Flux xuất bản một giá trị tăng dần. Nhưng điều làm cho interval() đặc biệt là thay vì bạn cung cấp cho nó một giá trị bắt đầu và kết thúc, bạn chỉ định một khoảng thời gian hoặc tần suất mà một giá trị nên được phát ra. Hình 11.5 mô tả marble diagram cho phương thức tạo interval().

 

Ví dụ, để tạo một Interval Flux phát ra một giá trị mỗi giây, bạn có thể sử dụng phương thức interval() tĩnh như sau:

@Test
public void createAFlux_interval() {
    Flux<Long> intervalFlux =
            Flux.interval(Duration.ofSeconds(1))
                    .take(5);

    StepVerifier.create(intervalFlux)
            .expectNext(0L)
            .expectNext(1L)
            .expectNext(2L)
            .expectNext(3L)
            .expectNext(4L)
            .verifyComplete();
}

Lưu ý rằng giá trị được phát ra bởi một Interval Flux bắt đầu từ 0 và tăng lên trên mỗi mục liên tiếp. Hơn nữa, vì interval() không có giá trị tối đa được chỉ định, nó có thể chạy vô hạn. Do đó, bạn cũng sử dụng phép thực hiện take() để giới hạn kết quả chỉ đến năm mục đầu tiên. Chúng ta sẽ thảo luận thêm về phép thực hiện take() trong phần tiếp theo.

11.3.2 Combining reactive types
Bạn có thể thấy mình cần phải kết hợp cùng nhau hai loại phản ứng một cách nào đó. Hoặc trong các trường hợp khác, bạn có thể cần phải chia một Flux thành nhiều hơn một loại phản ứng. Trong phần này, chúng ta sẽ xem xét các phép thực hiện kết hợp và chia nhỏ Flux và Mono của Reactor.

MERGING REACTIVE TYPES

Giả sử bạn có hai luồng Flux và cần tạo ra một Flux kết quả duy nhất sẽ tạo dữ liệu khi nó trở nên có sẵn từ bất kỳ luồng Flux nào từ các luồng nguồn trước. Để hợp nhất một Flux với một Flux khác, bạn có thể sử dụng phép thực hiện mergeWith(), như minh họa trong marble diagram trong hình 11.6.
 
Ví dụ, giả sử bạn có một Flux có giá trị là tên của các nhân vật trong TV và phim, và bạn có một Flux thứ hai có giá trị là tên của các loại thức ăn mà những nhân vật đó thích ăn. Phương thức kiểm thử sau đây cho thấy cách bạn có thể hợp nhất hai đối tượng Flux với phương thức mergeWith():
@Test
public void mergeFluxes() {
    Flux<String> characterFlux = Flux
            .just("Garfield", "Kojak", "Barbossa")
            .delayElements(Duration.ofMillis(500));
    Flux<String> foodFlux = Flux
            .just("Lasagna", "Lollipops", "Apples")
            .delaySubscription(Duration.ofMillis(250))
            .delayElements(Duration.ofMillis(500));

    Flux<String> mergedFlux = characterFlux.mergeWith(foodFlux);
    StepVerifier.create(mergedFlux)
            .expectNext("Garfield")
            .expectNext("Lasagna")
            .expectNext("Kojak")
            .expectNext("Lollipops")
            .expectNext("Barbossa")
            .expectNext("Apples")
            .verifyComplete();
}

Bởi vì mergeWith() không thể đảm bảo một sự chuyển động hoàn hảo giữa các nguồn của nó, bạn có thể muốn xem xét phép thực hiện zip() thay thế. Khi hai đối tượng Flux được zip lại với nhau, nó tạo ra một Flux mới phát ra một bộ giá trị, trong đó bộ giá trị chứa một giá trị từ mỗi nguồn Flux. Hình 11.7 mô tả cách hai đối tượng Flux có thể được zip lại với nhau. 

 

Để thấy phép thực hiện zip() hoạt động, hãy xem xét phương thức kiểm thử sau đây, nó zip lại Flux nhân vật và Flux thức ăn với nhau:

@Test
public void zipFluxes() {
    Flux<String> characterFlux = Flux
            .just("Garfield", "Kojak", "Barbossa");
    Flux<String> foodFlux = Flux
            .just("Lasagna", "Lollipops", "Apples");

    Flux<Tuple2<String, String>> zippedFlux =
            Flux.zip(characterFlux, foodFlux);
    StepVerifier.create(zippedFlux)
            .expectNextMatches(p ->
                    p.getT1().equals("Garfield") && p.getT2().equals("Lasagna"))
            .expectNextMatches(p ->
                    p.getT1().equals("Kojak") && p.getT2().equals("Lollipops"))
            .expectNextMatches(p -> p.getT1().equals("Barbossa") && p.getT2().equals("Apples"))
            .verifyComplete();
}

Lưu ý rằng khác với mergeWith(), phép thực hiện zip() là một phép thực hiện tạo tĩnh. Flux được tạo ra có sự sắp xếp hoàn hảo giữa các nhân vật và thức ăn yêu thích của họ. Mỗi mục được phát ra từ Flux đã zip là một Tuple2 (một đối tượng chứa hai đối tượng khác) chứa các mục từ mỗi nguồn Flux, theo thứ tự mà chúng được xuất bản.

Nếu bạn không muốn làm việc với một Tuple2 và muốn làm việc với một loại khác, bạn có thể cung cấp một Function cho zip() để tạo ra bất kỳ đối tượng nào bạn muốn, dựa trên hai mục (như được hiển thị trong biểu đồ bi trái trong hình 11.8).

 

Ví dụ, phương thức kiểm thử sau đây cho thấy cách zip Flux nhân vật với Flux thức ăn để kết quả là một Flux các đối tượng String:
@Test
public void zipFluxesToObject() {
    Flux<String> characterFlux = Flux
            .just("Garfield", "Kojak", "Barbossa");
    Flux<String> foodFlux = Flux
            .just("Lasagna", "Lollipops", "Apples");
    Flux<String> zippedFlux =
            Flux.zip(characterFlux, foodFlux, (c, f) -> c + " eats " + f);
    StepVerifier.create(zippedFlux)
            .expectNext("Garfield eats Lasagna")
            .expectNext("Kojak eats Lollipops")
            .expectNext("Barbossa eats Apples")
            .verifyComplete();
}

Hàm được cung cấp cho zip() (được đưa ra dưới dạng một lambda ở đây) đơn giản là nối hai mục vào một câu được phát ra bởi Flux đã được zip. 

SELECTING THE FIRST REACTIVE TYPE TO PUBLISH

Giả sử bạn có hai đối tượng Flux, và thay vì hợp nhất chúng lại với nhau, bạn chỉ muốn tạo ra một Flux mới phát ra các giá trị từ Flux đầu tiên sản xuất giá trị. Như được thể hiện trong hình 11.9, phép thực hiện firstWithSignal() chọn lựa Flux đầu tiên từ hai đối tượng Flux và phản ánh các giá trị mà nó phát ra.
 

Phương thức kiểm thử sau đây tạo ra một Flux nhanh và một Flux chậm (nghĩa là nó sẽ không phát bất kỳ mục nào cho đến sau 100 ms kể từ lúc đăng ký). Sử dụng firstWithSignal(), nó tạo ra một Flux mới chỉ phát ra giá trị từ Flux nguồn đầu tiên phát ra giá trị.
@Test
public void firstWithSignalFlux() {
    Flux<String> slowFlux = Flux.just("tortoise", "snail", "sloth")
            .delaySubscription(Duration.ofMillis(100));
    Flux<String> fastFlux = Flux.just("hare", "cheetah", "squirrel");
    Flux<String> firstFlux = Flux.firstWithSignal(slowFlux, fastFlux);
    StepVerifier.create(firstFlux)
            .expectNext("hare")
            .expectNext("cheetah")
            .expectNext("squirrel")
            .verifyComplete();
}

11.3.3 Transforming and filtering reactive streams
Khi dữ liệu chảy qua một luồng, bạn có thể cần lọc ra một số giá trị và sửa đổi các giá trị khác. Trong phần này, chúng ta sẽ xem xét các phép thực hiện biến đổi và lọc dữ liệu chảy qua một luồng phản ứng.

FILTERING DATA FROM REACTIVE TYPES 
Một trong những cách cơ bản nhất để lọc dữ liệu khi nó chảy từ một Flux là đơn giản là bỏ qua một số mục đầu tiên. Phép thực hiện skip(), minh họa trong hình 11.10, chính là thực hiện đó.
 
Cho một Flux với một số mục, phép thực hiện skip() sẽ tạo ra một Flux mới bỏ qua một số mục cụ thể trước khi phát ra các mục còn lại từ Flux nguồn. Phương thức kiểm thử sau đây cho thấy cách sử dụng skip():

@Test
public void skipAFew() {
    Flux<String> countFlux = Flux
            .just("one", "two", "skip a few", "ninety nine", "one hundred")
            .skip(3);
    StepVerifier.create(countFlux)
            .expectNext("ninety nine", "one hundred")
            .verifyComplete();
}

Trong trường hợp này, bạn có một Flux với năm mục String. Gọi skip(3) trên Flux đó tạo ra một Flux mới bỏ qua ba mục đầu tiên và chỉ publishes hai mục cuối cùng.

Nhưng có thể bạn không muốn bỏ qua một số mục cụ thể mà thay vào đó cần phải bỏ qua một số mục đầu tiên cho đến khi một khoảng thời gian đã trôi qua. Một biến thể khác của phép thực hiện skip(), được minh họa trong hình 11.11, tạo ra một Flux đợi cho đến khi một khoảng thời gian cụ thể đã trôi qua trước khi publishes các mục từ Flux nguồn.
 
Phương thức kiểm thử sau đây sử dụng skip() để tạo ra một Flux đợi 4 giây trước khi phát ra bất kỳ giá trị nào. Vì Flux đó được tạo ra từ một Flux có độ trễ 1 giây giữa các mục (sử dụng delayElements()), nên chỉ có hai mục cuối cùng sẽ được emitted (phát ra).

Bạn đã thấy một ví dụ về phép thực hiện take(), nhưng khi xem xét phép thực hiện skip(), take() có thể được coi là nghịch đảo của skip(). Trong khi skip() bỏ qua một số mục đầu tiên, take() chỉ emits số mục đầu tiên (như được minh họa trong marble diagram trong hình 11.12):

@Test
public void take() {
   Flux<String> nationalParkFlux = Flux
         .just("Yellowstone", "Yosemite", "Grand Canyon", "Zion", "Acadia")
         .take(3);
   StepVerifier.create(nationalParkFlux)
         .expectNext("Yellowstone", "Yosemite", "Grand Canyon")
         .verifyComplete();
}
 


Tương tự như skip(), take() cũng có một biến thể dựa trên thời gian thay vì số lượng mục. Nó sẽ lấy và emits nhiều mục như thông qua Flux nguồn cho đến khi một khoảng thời gian đã trôi qua, sau đó Flux hoàn thành. Điều này được minh họa trong hình 11.13.

 

Phương thức kiểm thử sau sử dụng biến thể thay thế của take() để emits nhiều mục nhất có thể trong 3,5 giây đầu tiên sau đó subscription:

@Test
public void takeForAwhile() {
    Flux<String> nationalParkFlux = Flux
            .just("Yellowstone", "Yosemite", "Grand Canyon", "Zion", "Grand Teton")
            .delayElements(Duration.ofSeconds(1))
            .take(Duration.ofMillis(3500));
    StepVerifier.create(nationalParkFlux)
            .expectNext("Yellowstone", "Yosemite", "Grand Canyon")
            .verifyComplete();
}

Các phép thực hiện skip() và take() có thể được coi là các phép lọc, trong đó tiêu chí lọc dựa trên một số lượng hoặc một khoảng thời gian. Đối với việc lọc giá trị Flux một cách tổng quát hơn, bạn sẽ thấy rằng phép thực hiện filter() rất hữu ích.

Khi được cung cấp một Predicate quyết định xem một mục sẽ đi qua Flux hay không, phép thực hiện filter() cho phép bạn emits một cách có chọn lọc dựa trên bất kỳ tiêu chí nào bạn muốn. Biểu đồ marble diagram trong hình 11.14 mô tả cách filter() hoạt động.

 

@Test
public void filter() {
    Flux<String> nationalParkFlux = Flux
            .just("Yellowstone", "Yosemite", "Grand Canyon", "Zion", "Grand Teton")
            .filter(np -> !np.contains(" "));
    StepVerifier.create(nationalParkFlux)
            .expectNext("Yellowstone", "Yosemite", "Zion")
            .verifyComplete();
}

Ở đây, filter() được đưa một Predicate dưới dạng lambda chỉ chấp nhận các giá trị String không có khoảng trắng. Do đó, "Grand Canyon" và "Grand Teton" được lọc ra khỏi Flux kết quả.

Có thể bạn cần lọc bỏ bất kỳ mục nào bạn đã nhận được trước đó. Phép thực hiện distinct(), như được minh họa trong hình 11.15, dẫn đến một Flux chỉ emits các mục từ Flux nguồn chưa được emits trước đó.

 

@Test
public void distinct() {
    Flux<String> animalFlux = Flux
            .just("dog", "cat", "bird", "dog", "bird", "anteater")
            .distinct();
    StepVerifier.create(animalFlux)
            .expectNext("dog", "cat", "bird", "anteater")
            .verifyComplete();
}

Mặc dù "dog" và "bird" được xuất bản hai lần từ Flux nguồn, nhưng Flux distinct chỉ phát ra chúng một lần.

MAPPING REACTIVE DATA

Một trong những phép thực hiện phổ biến nhất bạn sẽ sử dụng trên cả Flux và Mono là biến đổi các mục đã xuất ra thành một hình thức hoặc kiểu khác. Các loại của Reactor cung cấp các phép thực hiện map() và flatMap() cho mục đích đó.
Phép thực hiện map() tạo ra một Flux đơn giản thực hiện một biến đổi như được chỉ định bởi một Function cụ thể trên mỗi đối tượng nó nhận trước khi phát lại nó. Hình 11.16 mô tả cách phép thực hiện map() hoạt động.
 

Trong phương thức kiểm thử sau đây, một Flux các giá trị String đại diện cho các cầu thủ bóng rổ được ánh xạ thành một Flux mới của các đối tượng Player:
@Test
public void map() {
    Flux<Player> playerFlux = Flux
            .just("Michael Jordan", "Scottie Pippen", "Steve Kerr")
            .map(n -> {
                String[] split = n.split("\\s");
                        return new Player(split[0], split[1]);
            });
    StepVerifier.create(playerFlux)
            .expectNext(new Player("Michael", "Jordan"))
            .expectNext(new Player("Scottie", "Pippen"))
            .expectNext(new Player("Steve", "Kerr"))
            .verifyComplete();
}

@Data
private static class Player {
    private final String firstName;
    private final String lastName;
}

Hàm được cung cấp cho map() (dưới dạng lambda) chia chuỗi đầu vào tại khoảng trắng và sử dụng mảng chuỗi kết quả để tạo ra một đối tượng Player. Mặc dù Flux được tạo ra bằng cách sử dụng just() chứa các đối tượng String, nhưng Flux kết quả từ map() mang theo các đối tượng Player.

Điều quan trọng cần hiểu về map() là việc ánh xạ được thực hiện đồng bộ, khi mỗi mục được xuất ra bởi Flux nguồn. Nếu bạn muốn thực hiện ánh xạ bất đồng bộ, bạn nên xem xét phép thực hiện flatMap().

Phép thực hiện flatMap() đòi hỏi một số suy nghĩ và thực hành để đạt được sự thành thạo đầy đủ. Như được hiển thị trong hình 11.17, thay vì chỉ ánh xạ một đối tượng thành một đối tượng khác, như trong trường hợp của map(), flatMap() ánh xạ mỗi đối tượng thành một Mono hoặc Flux mới. Kết quả của Mono hoặc Flux được làm phẳng thành một Flux mới kết quả. Khi sử dụng cùng với subscribeOn(), flatMap() có thể phát huy sức mạnh bất đồng bộ của các loại Reactor.
 

@Test
public void flatMap() {
    Flux<Player> playerFlux = Flux
            .just("Michael Jordan", "Scottie Pippen", "Steve Kerr")
            .flatMap(n -> Mono.just(n)
                    .map(p -> {
                        String[] split = p.split("\\s");
                        return new Player(split[0], split[1]);
                    }))
            .subscribeOn(Schedulers.parallel());
    List<Player> playerList = Arrays.asList(
            new Player("Michael", "Jordan"),
            new Player("Scottie", "Pippen"),
            new Player("Steve", "Kerr")
    );
    StepVerifier.create(playerFlux)
            .expectNextMatches(p -> playerList.contains(p))
            .expectNextMatches(p -> playerList.contains(p))
            .expectNextMatches(p -> playerList.contains(p))
            .verifyComplete();
}

Chú ý rằng flatMap() được truyền một hàm lambda Function biến đổi chuỗi đầu vào thành một Mono kiểu String. Sau đó, phép thực hiện map() được áp dụng cho Mono để biến đổi chuỗi thành một đối tượng Player. Sau khi chuỗi được ánh xạ thành Player trên mỗi Flux nội bộ, chúng được xuất bản vào một Flux duy nhất được trả về bởi flatMap(), hoàn tất quá trình làm phẳng kết quả.

Nếu bạn dừng lại ở đây, Flux kết quả sẽ mang theo các đối tượng Player, được tạo ra đồng bộ theo cùng thứ tự như ví dụ với map(). Nhưng điều cuối cùng bạn làm với Mono là gọi subscribeOn() để chỉ định rằng mỗi đăng ký sẽ diễn ra trong một luồng song song. Do đó, các phép thực hiện ánh xạ cho nhiều đối tượng String đầu vào có thể được thực hiện một cách bất đồng bộ và song song.

Mặc dù subscribeOn() được đặt tên giống với subscribe(), nhưng chúng khá khác nhau. Trong khi subscribe() là một động từ, đăng ký vào một luồng phản ứng và hiệu quả bắt đầu nó, subscribeOn() mô tả chi tiết hơn, chỉ định cách đăng ký nên được xử lý một cách đồng thời. Reactor không bắt buộc bất kỳ mô hình đồng thời cụ thể nào; thông qua subscribeOn(), bạn có thể chỉ định mô hình đồng thời, sử dụng một trong những phương thức tĩnh từ Schedulers mà bạn muốn sử dụng. Trong ví dụ này, bạn đã sử dụng parallel(), sử dụng các luồng làm việc từ một bể cố định (kích thước bằng số lõi CPU). Nhưng Schedulers hỗ trợ nhiều mô hình đồng thời, như mô tả trong bảng 11.1.

1. immediate() : Thực hiện đăng ký trong luồng hiện tại.

2. single(): Thực hiện đăng ký trong một luồng duy nhất và có thể tái sử dụng. Sử dụng cùng một luồng cho tất cả các cuộc gọi.

3. newSingle(): Thực hiện đăng ký trong một luồng duy nhất được tạo mới cho mỗi cuộc gọi.

4. elastic(): Thực hiện đăng ký trong một worker được rút ra từ một bể không giới hạn, linh hoạt. Luồng làm việc mới được tạo ra khi cần, và luồng làm việc không hoạt động sẽ bị loại bỏ (mặc định, sau 60 giây).

5. parallel(): Thực hiện đăng ký trong một worker được rút ra từ một bể có kích thước cố định, bằng kích thước của số lõi CPU.

Lợi ích của việc sử dụng flatMap() và subscribeOn() là bạn có thể tăng khả năng xử lý của luồng bằng cách chia công việc ra nhiều luồng song song. Nhưng vì công việc được thực hiện song song, không có bất kỳ đảm bảo nào về việc công việc nào sẽ hoàn thành trước, nên không có cách nào để biết thứ tự của các mục được emits trong Flux kết quả. Do đó, Step-Verifier chỉ có thể xác minh rằng mỗi mục được emits tồn tại trong danh sách dự kiến của đối tượng Player và sẽ có ba mục như vậy trước khi Flux hoàn thành.

BUFFERING DATA ON A REACTIVE STREAM

Trong quá trình xử lý dữ liệu đang chảy qua một Flux, bạn có thể thấy hữu ích khi cần chia nhỏ dòng dữ liệu thành các đoạn nhỏ. Phép thực hiện buffer(), được hiển thị trong hình 11.18, có thể hỗ trợ cho việc đó.
 

Được cung cấp một Flux của các giá trị String, mỗi giá trị chứa tên của một loại trái cây, bạn có thể tạo ra một Flux mới của các List, trong đó mỗi List có không quá một số lượng cụ thể các phần tử như sau:
@Test
public void buffer() {
    Flux<String> fruitFlux = Flux
            .just("apple", "orange", "banana", "kiwi", "strawberry");

    Flux<List<String>> bufferedFlux = fruitFlux.buffer(3);
    StepVerifier.create(bufferedFlux)
            .expectNext(Arrays.asList("apple", "orange", "banana"))
            .expectNext(Arrays.asList("kiwi", "strawberry"))
            .verifyComplete();
}

Trong trường hợp này, các phần tử Flux của String được đặt vào một Flux mới của các collection List, mỗi bộ sưu tập không chứa quá ba phần tử. Do đó, Flux gốc emit năm giá trị String sẽ được chuyển đổi thành một Flux emit hai bộ sưu tập List, một chứa ba loại trái cây và một loại khác với hai loại trái cây.
Vậy điều gì? Việc đặt giá trị từ một reactive Flux vào các bộ sưu tập List không hỗ trợ reactive có vẻ không hiệu quả. Nhưng khi bạn kết hợp buffer() với flatMap(), nó cho phép mỗi bộ sưu tập List được xử lý song song, như được thể hiện dưới đây:

@Test
public void bufferAndFlatMap() throws Exception {
    Flux.just(
            "apple", "orange", "banana", "kiwi", "strawberry")
            .buffer(3)
            .flatMap(x -> 
                    Flux.fromIterable(x)
                            .map(y -> y.toUpperCase())
                            .subscribeOn(Schedulers.parallel())
                            .log()
            ).subscribe();
}

Trong ví dụ mới này, bạn vẫn buffer một Flux của năm giá trị String thành một Flux mới của các bộ sưu tập List. Nhưng sau đó, bạn áp dụng flatMap() cho Flux của các bộ sưu tập List đó. Điều này lấy mỗi bộ sưu tập List và tạo ra một Flux mới từ các phần tử của nó, sau đó áp dụng một phép thực hiện map() lên nó. Do đó, mỗi List được buffer được xử lý tiếp theo một cách song song trong các luồng riêng biệt.

Để chứng minh rằng nó hoạt động, tôi cũng đã bao gồm một phép thực hiện log() được áp dụng cho mỗi con Flux. Phép thực hiện log() đơn giản là logs tất cả các sự kiện của Reactive Streams, để bạn có thể xem điều gì đang diễn ra thực sự. Kết quả là, các mục sau được ghi vào log:

16:47:28.029 [main] INFO reactor.Flux.SubscribeOn.1 -- onSubscribe(FluxSubscribeOn.SubscribeOnSubscriber)
16:47:28.033 [main] INFO reactor.Flux.SubscribeOn.1 -- request(32)
16:47:28.035 [main] INFO reactor.Flux.SubscribeOn.2 -- onSubscribe(FluxSubscribeOn.SubscribeOnSubscriber)
16:47:28.035 [main] INFO reactor.Flux.SubscribeOn.2 -- request(32)
16:47:28. [parallel-2] INFO reactor.Flux.SubscribeOn.2 -- onNext(KIWI)
16:47:28. 037037 [parallel-2] INFO reactor.Flux.SubscribeOn.2 -- onNext(STRAWBERRY)
16:47:28.037 [parallel-1] INFO reactor.Flux.SubscribeOn.1 -- onNext(APPLE)
16:47:28.037 [parallel-1] INFO reactor.Flux.SubscribeOn.1 -- onNext(ORANGE)
16:47:28.037 [parallel-1] INFO reactor.Flux.SubscribeOn.1 -- onNext(BANANA)
16:47:28. [parallel-1] INFO reactor.Flux.SubscribeOn.1 -- onComplete()
16:47:28037.037 [parallel-2] INFO reactor.Flux.SubscribeOn.2 -- onComplete()

Như các mục log rõ ràng cho thấy, các loại trái cây trong buffer đầu tiên (táo, cam, và chuối) được xử lý trong luồng parallel-1. Trong khi đó, các loại trái cây trong buffer thứ hai (kiwi và dâu) được xử lý trong luồng parallel-2. Như có thể thấy bằng việc mục log từ mỗi buffer được xen kẽ, hai buffer này được xử lý song song.

Nếu, vì một lý do nào đó, bạn cần thu thập tất cả những gì một Flux phát ra vào một List, bạn có thể gọi buffer() mà không có đối số như sau:
Flux<List<String>> bufferedFlux = fruitFlux.buffer();
Điều này dẫn đến một Flux emits ra một List chứa tất cả các mục được xuất bản bởi Flux nguồn. Bạn cũng có thể đạt được điều tương tự với phép thực hiện collectList(), được minh họa trong marble diagram trong hình 11.19.
 
Thay vì tạo ra một Flux emits một List, collectList() tạo ra một Mono emits một List. Phương thức kiểm thử sau mô tả cách nó có thể được sử dụng:
@Test
public void collectList() {
    Flux<String> fruitFlux = Flux
            .just("apple", "orange", "banana", "kiwi", "strawberry");
    Mono<List<String>> fruitListMono = fruitFlux.collectList();
    StepVerifier.create(fruitListMono)
            .expectNext(Arrays.asList(
                    "apple", "orange", "banana", "kiwi", "strawberry"
            ))
            .verifyComplete();
}
	


Một cách thu hút hơn để thu thập các mục được emits bởi một Flux là thu thập chúng vào một Map. Như được thể hiện trong hình 11.20, phép thực hiện collectMap() dẫn đến một Mono emits một Map được điền với các mục có key được tính toán bởi một Function được chỉ định.
 

Để xem collectMap() hoạt động, hãy xem phương thức kiểm thử sau:

@Test
public void collectMap() {
    Flux<String> animalFlux = Flux.just(
            "aardvark", "elephant", "koala", "eagle", "kangaroo");
    Mono<Map<Character, String>> animalMapMono =
            animalFlux.collectMap(a -> a.charAt(0));
    StepVerifier.create(animalMapMono)
            .expectNextMatches(map -> {
                return
                        map.size() == 3 &&
                                map.get('a').equals("aardvark") &&
                                map.get('e').equals("eagle") &&
                                map.get('k').equals("kangaroo");
            })
            .verifyComplete();
}


Flux nguồn phát ra tên của một số loại động vật. Từ Flux đó, bạn sử dụng collectMap() để tạo ra một Mono mới phát ra một Map, trong đó giá trị của key được xác định bởi chữ cái đầu tiên của tên động vật và giá trị là chính tên của động vật đó.

Trong trường hợp hai tên động vật bắt đầu bằng chữ cái giống nhau (như với elephant và eagle hoặc koala và kangaroo), mục nhập cuối cùng chảy qua luồng sẽ ghi đè lên bất kỳ mục nhập nào trước đó.

11.3.4 Performing logic operations on reactive types

Đôi khi bạn chỉ cần biết liệu các mục được phát ra bởi một Mono hoặc Flux có khớp với một số tiêu chí hay không. Các phép thực hiện all() và any() thực hiện logic như vậy. Các hình 11.21 và 11.22 minh họa cách all() và any() hoạt động.

  

Giả sử bạn muốn biết rằng mọi chuỗi được phát ra bởi một Flux đều chứa chữ cái a hoặc chữ cái k. Bài kiểm thử sau đây mô tả cách sử dụng all() để kiểm tra điều kiện đó:

@Test
public void all() {
    Flux<String> animalFlux = Flux.just(
            "aardvark", "elephant", "koala", "eagle", "kangaroo");
    Mono<Boolean> hasAMono = animalFlux.all(a -> a.contains("a"));
    StepVerifier.create(hasAMono)
            .expectNext(true)
            .verifyComplete();

    Mono<Boolean> hasKMono = animalFlux.all(a -> a.contains("k"));
    StepVerifier.create(hasKMono)
            .expectNext(false)
            .verifyComplete();
}

Trong StepVerifier đầu tiên, bạn kiểm tra chữ cái a. Phép thực hiện all() được áp dụng vào Flux nguồn, tạo ra một Mono có kiểu dữ liệu là Boolean. Trong trường hợp này, tất cả tên động vật đều chứa chữ cái a, nên true được phát ra từ Mono kết quả. Nhưng trong StepVerifier thứ hai, Mono kết quả sẽ phát ra false vì không phải tất cả các tên động vật đều chứa chữ cái k.

Thay vì thực hiện một kiểm tra toàn bộ hoặc không gì cả, có thể bạn sẽ hài lòng nếu ít nhất một mục khớp. Trong trường hợp đó, phép thực hiện any() là điều bạn muốn. Trong trường kiểm thử mới này, any() được sử dụng để kiểm tra chữ cái t và z:

@Test
public void any() {
    Flux<String> animalFlux = Flux
            .just("aardvark", "elephant", "koala", "eagle", "kangaroo");
    Mono<Boolean> hasTMono = animalFlux.any(a -> a.contains("t"));

    StepVerifier.create(hasTMono)
            .expectNext(true)
            .verifyComplete();
}

Trong StepVerifier đầu tiên, bạn thấy rằng Mono kết quả phát ra true, vì ít nhất một tên động vật có chứa chữ cái t (cụ thể là elephant). Trong trường hợp thứ hai, Mono kết quả phát ra false, vì không có tên động vật nào chứa chữ cái z.

Chapter 12 - Developing reactive APIs
This chapter covers
 Using Spring WebFlux
 Writing and testing reactive controllers and
clients
 Consuming REST APIs
 Securing reactive web applications

Bây giờ khi bạn đã có một sự giới thiệu tốt về lập trình reactive và Project Reactor, bạn đã sẵn sàng bắt đầu áp dụng những kỹ thuật đó trong ứng dụng Spring của bạn. Trong chương này, chúng ta sẽ xem xét lại một số controllers bạn đã viết trong chương 7 để tận dụng mô hình lập trình reactive của Spring.

Cụ thể hơn, chúng ta sẽ nghiên cứu Spring WebFlux - framework reactive web của Spring. Như bạn sẽ nhanh chóng khám phá, Spring WebFlux tương đối giống với Spring MVC, làm cho việc áp dụng nó dễ dàng, cùng với những điều bạn đã biết về xây dựng REST APIs trong Spring.
12.1 Working with Spring WebFlux 

Các framework web servlet thông thường, như Spring MVC, có tính chất đồng bộ và đa luồng, sử dụng một luồng duy nhất cho mỗi kết nối. Khi xử lý yêu cầu, một worker thread được rút từ một thread pool để xử lý yêu cầu. Trong khi đó, request thread bị chặn cho đến khi nó được thông báo bởi worker thread rằng nó đã hoàn thành.

Do đó, các framework web đồng bộ sẽ không mở rộng hiệu quả dưới tải lượng yêu cầu lớn. Độ trễ trong các worker thread chậm làm cho mọi thứ trở nên tồi tệ hơn vì sẽ mất thời gian lâu hơn để worker thread được trả lại vào pool, sẵn sàng xử lý yêu cầu khác. Trong một số trường hợp sử dụng, sắp xếp này hoàn toàn chấp nhận được. Trên thực tế, đây chủ yếu là cách mà hầu hết các ứng dụng web đã được phát triển trong hơn một thập kỷ. Nhưng thời đại đang thay đổi.

Các ứng dụng web ngày nay đã phát triển từ việc mọi người chỉ đôi khi xem các trang web thành việc thường xuyên tiêu thụ nội dung và sử dụng các ứng dụng tương tác với các API HTTP. Và ngày nay, mô hình gọi là Internet of Things (nơi con người thậm chí không tham gia) mang lại các phương tiện như ô tô, động cơ máy bay và các khách hàng phi truyền thống khác liên tục trao đổi dữ liệu với các API web. Với số lượng người dùng web ngày càng tăng, khả năng mở rộng trở nên quan trọng hơn bao giờ hết.

Ngược lại, các framework web không đồng bộ đạt được khả năng mở rộng cao hơn với ít luồng hơn - thông thường là một luồng cho mỗi lõi CPU. Bằng cách áp dụng một kỹ thuật được biết đến là event looping vòng sự kiện (như minh họa trong hình 12.1), các framework này có thể xử lý nhiều yêu cầu trên mỗi luồng, làm cho chi phí mỗi kết nối trở nên kinh tế hơn.

 

Trong một event looping, mọi thứ đều được xử lý như một sự kiện, bao gồm cả các request và các callback từ các hoạt động cường độ cao như các hoạt động cơ sở dữ liệu và mạng. Khi cần thực hiện một hoạt động tốn kém, event looping đăng ký một callback để thực hiện hoạt động đó song song, trong khi nó tiếp tục xử lý các sự kiện khác.

Khi hoạt động hoàn tất, nó được xem xét như một sự kiện bởi vòng sự kiện, giống như các yêu cầu. Kết quả là, các framework web không đồng bộ có khả năng mở rộng tốt hơn dưới tải lượng yêu cầu lớn với ít luồng hơn, dẫn đến giảm đầu tư cho quản lý luồng.

Spring cung cấp một framework web nonblocking không chặn, asynchronous không đồng bộ dựa chủ yếu vào Project Reactor để đáp ứng nhu cầu về khả năng mở rộng lớn hơn trong ứng dụng web và API. Hãy xem xét Spring WebFlux - một framework web reactive cho Spring.

12.1.1 Introducing Spring WebFlux

Khi nhóm Spring đang xem xét cách thêm mô hình reactive programming vào tầng web, nhanh chóng trở nên rõ ràng rằng sẽ khó khăn nếu làm điều này mà không cần phải thực hiện nhiều công việc trong Spring MVC. Điều này sẽ liên quan đến việc chia nhánh mã để quyết định liệu có xử lý các yêu cầu theo cách reactive hay không. Theo cách này, kết quả sẽ là hai framework web được đóng gói thành một, với các câu lệnh if để phân tách reactive và không reactive. Thay vì cố gắng ép mô hình lập trình reactive vào Spring MVC, nhóm Spring quyết định tạo ra một framework web reactive riêng biệt, mượn nhiều từ Spring MVC nhất có thể. Kết quả là Spring WebFlux. Hình 12.2 minh họa toàn bộ ngăn xếp phát triển web có sẵn trong Spring.

 

Ở phía trái của hình 12.2, bạn thấy Spring MVC stack được giới thiệu trong phiên bản 2.5 của Spring Framework. Spring MVC (được đề cập trong các chương 2 và 7) đặt ở trên Java Servlet API, yêu cầu một servlet container (như Tomcat) để thực thi.

Ngược lại, Spring WebFlux (ở phía phải) không liên kết với Servlet API, nên nó xây dựng trên một Reactive HTTP API, đó là một ước lượng phản ứng của cùng một chức năng được cung cấp bởi Servlet API. Và vì Spring WebFlux không kết nối với Servlet API, nó không đòi hỏi một bộ servlet container để chạy. Thay vào đó, nó có thể chạy trên bất kỳ nonblocking web container nào bao gồm Netty, Undertow, Tomcat, Jetty hoặc bất kỳ bộ chứa Servlet 3.1 trở lên nào.

Điều đáng chú ý nhất ở hình 12.2 là ô ở góc trên cùng bên trái, đại diện cho các thành phần chung giữa Spring MVC và Spring WebFlux, chủ yếu là các chú thích được sử dụng để định nghĩa các controller. Bởi vì Spring MVC và Spring WebFlux chia sẻ các chú thích giống nhau, Spring WebFlux, theo nhiều cách, không thể phân biệt được với Spring MVC.

Ô ở góc trên cùng bên phải đại diện cho một mô hình lập trình thay thế định nghĩa các controller với một mô hình lập trình hàm thay vì sử dụng các chú thích. Chúng ta sẽ nói thêm về mô hình lập trình web functional của Spring trong phần 12.2.

Sự khác biệt quan trọng nhất giữa Spring MVC và Spring WebFlux chủ yếu là ở chỗ bạn thêm vào dự án phụ thuộc nào. Khi làm việc với Spring WebFlux, bạn sẽ cần thêm dependency starter Spring Boot WebFlux thay vì starter web tiêu chuẩn (ví dụ, spring-boot-starter-web). Trong tệp pom.xml của dự án, nó sẽ trông như sau:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

GHI CHÚ: Như với hầu hết các dependency starter của Spring Boot, starter này cũng có thể được thêm vào dự án bằng cách chọn hộp kiểm Reactive Web trong Initializr.
Một hiệu ứng phụ thú vị khi sử dụng WebFlux thay vì Spring MVC là máy chủ nhúng mặc định cho WebFlux là Netty thay vì Tomcat. Netty là một trong số ít máy chủ bất đồng bộ, các máy chủ hướng sự kiện là sự kết hợp tự nhiên cho một framework web reactive như Spring WebFlux.
Ngoài việc sử dụng một dependency starter khác nhau, các phương thức controller của Spring WebFlux thường chấp nhận và trả về các reactive type, như Mono và Flux, thay vì các loại domain và collection. Spring WebFlux controllers cũng có thể xử lý các loại RxJava như Observable, Single, và Completable.

REACTIVE SPRING MVC?
Mặc dù các phương thức điều khiển của Spring WebFlux thường trả về Mono và Flux, điều này không có nghĩa là Spring MVC không thể sử dụng một số loại phản ứng. Các phương thức điều khiển của Spring MVC cũng có thể trả về Mono hoặc Flux nếu bạn muốn.
Sự khác biệt nằm ở cách những loại này được sử dụng. Trong khi Spring WebFlux là một framework web phản ứng thực sự, cho phép xử lý yêu cầu trong một controller looping, Spring MVC dựa trên servlet, sử dụng đa luồng để xử lý nhiều yêu cầu.
Hãy đặt Spring WebFlux vào hoạt động bằng cách viết lại một số API controller của Taco Cloud để tận dụng các tính năng của Spring WebFlux.

12.1.2 Writing reactive controllers
Bạn có thể nhớ rằng trong chương 7, bạn đã tạo một số controllers cho REST API của Taco Cloud. Những controllers đó có các phương thức xử lý yêu cầu thao tác với đầu vào và đầu ra dưới dạng các loại domain (như TacoOrder và Taco) hoặc collection của những loại domain đó. Như một lời nhắc, hãy xem đoạn mã sau từ TacoController mà bạn đã viết trong chương 7:

@RestController
@RequestMapping(path="/api/tacos",produces="application/json")
@CrossOrigin(origins="*")
public class TacoController {

...

@GetMapping(params="recent")
public Iterable<Taco> recentTacos() {
   PageRequest page = PageRequest.of(
       0, 12, Sort.by("createdAt").descending());
   return tacoRepo.findAll(page).getContent();
}
...
}

Như được viết, controller recentTacos() xử lý các yêu cầu HTTP GET cho /api/tacos?recent để trả về một danh sách các taco được tạo gần đây. Cụ thể hơn, nó trả về một Iterable của kiểu Taco. Điều này chủ yếu là do đó là điều được trả về từ phương thức findAll() của repository, hoặc, chính xác hơn, từ phương thức getContent() trên đối tượng Page được trả về từ findAll().

Điều này hoạt động tốt, nhưng Iterable không phải là một reactive type. Bạn sẽ không thể áp dụng bất kỳ thao tác reactive nào lên nó, cũng như không thể để framework tận dụng nó như một loại reactive để phân chia công việc qua nhiều luồng. Điều bạn muốn là để recentTacos() trả về một Flux<Taco>.

Một lựa chọn đơn giản nhưng hơi hạn chế ở đây là viết lại recentTacos() để chuyển đổi Iterable thành Flux. Và, trong khi bạn đang làm điều đó, bạn có thể loại bỏ mã phân trang và thay thế nó bằng một cuộc gọi đến take() trên Flux như sau:
@GetMapping(params="recent")
public Flux<Taco> recentTacos() {
    return Flux.fromIterable(tacoRepo.findAll()).take(12);
}

Bằng cách sử dụng Flux.fromIterable(), bạn chuyển đổi Iterable<Taco> thành Flux<Taco>. Và bây giờ khi bạn đang làm việc với một Flux, bạn có thể sử dụng thao tác take() để giới hạn Flux được trả về tối đa là 12 đối tượng Taco. Không chỉ mã nguồn đơn giản hơn, nó cũng xử lý với một Flux reactive thay vì chỉ là một Iterable thông thường.

Việc viết mã reactive đã là một bước đi thành công cho đến nay. Nhưng nếu repository cung cấp cho bạn một Flux từ đầu để bạn không cần phải thực hiện việc chuyển đổi, thì đó sẽ là tốt hơn. Nếu đó là trường hợp, thì recentTacos() có thể được viết như sau:
@GetMapping(params="recent")
public Flux<Taco> recentTacos() {
    return tacoRepo.findAll().take(12);
}
Điều đó còn tốt hơn! Lý tưởng nhất, một controller reactive sẽ là đỉnh của một ngăn xếp reactive hoàn toàn, bao gồm cả các controllers, repositories, cơ sở dữ liệu và bất kỳ dịch vụ nào có thể tồn tại giữa chúng. Một ngăn xếp reactive từ đầu đến cuối được minh họa trong hình 12.3.

 
Một ngăn xếp từ đầu đến cuối như vậy đòi hỏi repository phải được viết để trả về một Flux thay vì một Iterable. Chúng ta sẽ xem xét cách viết các repositories phản ứng trong chương tiếp theo, nhưng đây là một cái nhìn sơ bộ về cách một TacoRepository phản ứng có thể trông như:
package tacos.data;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import tacos.Taco;
public interface TacoRepository extends ReactiveCrudRepository<Taco, Long> {
}
Tuy nhiên, điều quan trọng nhất để lưu ý tại điểm này là, ngoại trừ việc làm việc với một Flux thay vì một Iterable, cũng như cách bạn lấy được Flux đó, mô hình lập trình để định nghĩa một controller WebFlux phản ứng không khác gì so với một controller Spring MVC không phản ứng. Cả hai đều được chú thích bằng @RestController và một @RequestMapping ở cấp độ lớp. Và cả hai đều có các hàm xử lý yêu cầu được chú thích với @GetMapping ở cấp độ phương thức. Điều quan trọng thực sự là tùy thuộc vào loại dữ liệu mà các phương thức xử lý trả về.

Một quan sát quan trọng khác là mặc dù bạn nhận được một Flux<Taco> từ repository, bạn có thể trả nó mà không cần gọi subscribe(). Thực sự, framework sẽ gọi subscribe() thay bạn. Điều này có nghĩa là khi một yêu cầu cho /api/tacos?recent được xử lý, phương thức recentTacos() sẽ được gọi và trả về trước cả khi dữ liệu thậm chí được lấy từ cơ sở dữ liệu!

RETURNING SINGLE VALUES 

Là một ví dụ khác, hãy xem xét phương thức tacoById() sau đây từ TacoController như nó đã được viết trong chương 7:
@GetMapping("/{id}")
public Taco tacoById(@PathVariable("id") Long id) {
    Optional<Taco> optTaco = tacoRepo.findById(id);
    if (optTaco.isPresent()) {
        return optTaco.get();
    }
    return null;
}

Ở đây, phương thức này xử lý yêu cầu GET cho /tacos/{id} và trả về một đối tượng Taco duy nhất. Vì findById() của repository trả về một Optional, bạn cũng phải viết một số mã nguồn khó nhằn để xử lý điều đó. Nhưng hãy giả sử một lúc rằng findById() trả về một Mono<Taco> thay vì một Optional<Taco>. Trong trường hợp đó, bạn có thể viết lại phương thức tacoById() của controller như sau:
@GetMapping("/{id}")
public Mono<Taco> tacoById(@PathVariable("id") Long id) {
    return tacoRepo.findById(id);
}

Wow! Đó là đơn giản nhiều. Quan trọng hơn, tuy nhiên, là khi trả về một Mono<Taco> thay vì một Taco, bạn đang cho phép Spring WebFlux xử lý phản ứng trong việc trả lời. Do đó, API của bạn sẽ mở rộng tốt hơn khi có tải nặng.

HANDLING INPUT REACTIVELY

Cho đến nay, chúng ta chỉ quan tâm đến những loại phản ứng mà các phương thức điều khiển trả về. Nhưng với Spring WebFlux, bạn cũng có thể chấp nhận một Mono hoặc Flux như là đầu vào cho một phương thức xử lý. Để minh họa, hãy xem xét triển khai ban đầu của postTaco() từ TacoController, được hiển thị ở đây:
@PostMapping(consumes="application/json")
@ResponseStatus(HttpStatus.CREATED)
public Taco postTaco(@RequestBody Taco taco) {
    return tacoRepo.save(taco);
}

Như được viết ban đầu, postTaco không chỉ trả về một đối tượng Taco đơn giản mà còn chấp nhận một đối tượng Taco được ràng buộc với @RequestBody. Điều này có nghĩa là postTaco() không thể được gọi cho đến khi dữ liệu yêu cầu đã được giải quyết hoàn toàn và được sử dụng để khởi tạo một đối tượng Taco. Điều này cũng có nghĩa là postTaco() không thể trả về cho đến khi cuộc gọi chặn đến phương thức save() của repository kết thúc. Nói một cách ngắn gọn, yêu cầu bị chặn hai lần: khi nó nhập vào postTaco() và một lần nữa bên trong postTaco(). Nhưng bằng cách áp dụng một chút mã reactive cho postTaco(), được hiển thị tiếp theo, bạn có thể biến nó thành một phương thức xử lý request hoàn toàn không chặn:
@PostMapping(consumes="application/json")
@ResponseStatus(HttpStatus.CREATED)
public Mono<Taco> postTaco(@RequestBody Mono<Taco> tacoMono) {
    return tacoRepo.saveAll(tacoMono).next();
}

Ở đây, postTaco() chấp nhận một Mono<Taco> và gọi phương thức saveAll() của repository, phương thức này chấp nhận bất kỳ triển khai nào của Reactive Streams Publisher, bao gồm cả Mono hoặc Flux. Phương thức saveAll() trả về một Flux<Taco>, nhưng vì bạn bắt đầu với một Mono, bạn biết rằng có tối đa một Taco sẽ được xuất bản bởi Flux. Do đó, bạn có thể gọi next() để lấy một Mono<Taco> sẽ được trả về từ postTaco().

Bằng cách chấp nhận một Mono<Taco> làm đầu vào, phương thức được gọi ngay lập tức mà không cần đợi Taco được giải quyết từ request body. Và vì repository cũng là reactive, nó sẽ chấp nhận một Mono và ngay lập tức trả về một Flux<Taco>, từ đó bạn gọi next() và trả về Mono<Taco> kết quả... tất cả trước khi yêu cầu được xử lý!

Hoặc có thể bạn cũng có thể triển khai postTaco() như sau:

@PostMapping(consumes="application/json")
@ResponseStatus(HttpStatus.CREATED)
public Mono<Taco> postTaco(@RequestBody Mono<Taco> tacoMono) {
    return tacoMono.flatMap(tacoRepo::save);
}

Cách tiếp cận này đảo ngược mọi thứ để monoTaco là người điều khiển hành động. Taco chứa trong tacoMono được chuyển đến phương thức save() của repository thông qua flatMap(), kết quả là một Mono<Taco> mới được trả về.

Cả hai cách đều hoạt động tốt, và có lẽ còn nhiều cách khác mà bạn có thể viết postTaco(). Chọn cách nào hoạt động tốt nhất và có ý nghĩa nhất với bạn. Spring WebFlux là một lựa chọn tuyệt vời thay thế cho Spring MVC, cung cấp khả năng viết ứng dụng web reactive bằng cùng mô hình phát triển như Spring MVC.

Nhưng Spring còn một mẹo mới khác. Hãy xem cách tạo APIs reactive bằng phong cách lập trình hàm của Spring.

12.2 Defining functional request handlers


Mô hình lập trình annotation-based của Spring MVC đã xuất hiện từ phiên bản Spring 2.5 và rất phổ biến. Tuy nhiên, nó đi kèm với một số nhược điểm.

Đầu tiên, mọi mô hình lập trình annotation-based đều liên quan đến việc chia nhỏ định nghĩa split in the definition về điều chú thích nên làm và cách nó nên thực hiện nó. Bản thân chú thích xác định cái gì (what); cách thực hiện nó được xác định ở nơi khác trong mã nguồn framework. Sự chia rẽ này làm phức tạp mô hình lập trình khi đến bất kỳ loại tùy chỉnh hoặc mở rộng nào vì những thay đổi đó đòi hỏi làm việc trong mã nguồn nằm ngoài chú thích. Hơn nữa, việc gỡ lỗi mã nguồn này là khó khăn vì bạn không thể đặt một break point ở chú thích.

Ngoài ra, khi Spring ngày càng trở nên phổ biến, những nhà phát triển mới đến từ các ngôn ngữ và framework khác có thể thấy rằng Spring MVC (và WebFlux) annotation-based khá khác với những gì họ đã biết. Như một phương thức thay thế cho WebFlux, Spring cung cấp một functional programming model để định nghĩa các API reactive.

Mô hình lập trình mới này được sử dụng giống như một thư viện hơn là một framework, cho phép bạn map requests vào mã xử lý mà không cần annotations. Viết một API bằng functional programming model của Spring bao gồm bốn loại chính sau:

 RequestPredicate—Khai báo loại (hoặc các loại) yêu cầu sẽ được xử lý
 RouterFunction—Khai báo cách một yêu cầu khớp nên được định tuyến đến mã xử lý
 ServerRequest—Đại diện cho một yêu cầu HTTP, bao gồm quyền truy cập thông tin header và body của yêu cầu
 ServerResponse—Đại diện cho một phản hồi HTTP, bao gồm thông tin header và body của phản hồi

Như một ví dụ đơn giản kết hợp tất cả các loại này, hãy xem xét ví dụ Hello World sau đây:


 







package tacos.web.api;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

@Configuration
public class RouterFunctionConfig {

    @Bean
    public RouterFunction<?> helloRouterFunction() {
        return RouterFunctions.route(
                RequestPredicates.GET("/hello"),
                request -> ServerResponse.ok()
                        .body(Mono.just("Hello World!"), String.class)
        );
    }
}


Điều đầu tiên cần lưu ý là bạn đã chọn sử dụng static import cho một số helper classes mà bạn có thể sử dụng để tạo các loại functional đã nói ở trên. Bạn cũng đã sử dụng static import cho Mono để làm cho phần còn lại của mã nguồn dễ đọc và hiểu hơn.
Trong lớp @Configuration này, bạn có một phương thức @Bean duy nhất có kiểu là RouterFunction<?>. Như đã đề cập, một RouterFunction khai báo các ánh xạ giữa một hoặc nhiều đối tượng RequestPredicate và các hàm sẽ xử lý các yêu cầu khớp. Phương thức route() từ RouterFunctions chấp nhận hai tham số: một RequestPredicate và một hàm để xử lý các yêu cầu khớp. Trong trường hợp này, phương thức GET() từ RequestPredicates khai báo một RequestPredicate khớp với các yêu cầu HTTP GET cho đường dẫn /hello.
Đối với functional handler, nó được viết dưới dạng lambda, mặc dù nó cũng có thể là một tham chiếu phương thức. Mặc dù nó không được khai báo một cách rõ ràng, lambda xử lý chấp nhận một ServerRequest làm tham số. Nó trả về một ServerResponse sử dụng ok() từ ServerResponse và body() từ BodyBuilder, được trả về từ ok(). Điều này được thực hiện để tạo ra một reactive với mã trạng thái HTTP 200 (OK) và một payload thân chứa thông điệp "Hello World!".
Được viết như vậy, phương thức helloRouterFunction() khai báo một RouterFunction chỉ xử lý một loại yêu cầu duy nhất. Nhưng nếu bạn cần xử lý một loại yêu cầu khác, bạn không cần phải viết một phương thức @Bean khác, tuy bạn vẫn có thể làm như vậy. Bạn chỉ cần gọi andRoute() để khai báo một ánh xạ khác giữa RequestPredicate và hàm. Ví dụ, dưới đây là cách bạn có thể thêm một xử lý cho các yêu cầu GET đối với /bye:
@Bean
public RouterFunction<?> helloRouterFunction() {
    return route(GET("/hello"),
                    request -> ok().body(just("Hello World!"), String.class))
            .andRoute(GET("/bye"),
                    request -> ok().body(just("See ya!"), String.class))
            ;
}

Mẫu "Hello World" là tốt để bắt đầu khám phá những điều mới. Nhưng hãy nâng cao một chút và xem cách sử dụng Spring’s functional web programming model để xử lý các yêu cầu giống như các kịch bản thực tế.
Để minh họa cách functional web programming model có thể được sử dụng trong một ứng dụng thực tế, hãy tái tạo chức năng của TacoController theo kiểu functional. Lớp cấu hình sau đây là một functional cho TacoController:

package tacos.web.api;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;
import tacos.Taco;
import tacos.data.TacoRepository;

import java.net.URI;

import static org.springframework.web.reactive.function.server
        .RequestPredicates.GET;
import static org.springframework.web.reactive.function.server
        .RequestPredicates.POST;
import static org.springframework.web.reactive.function.server
        .RequestPredicates.queryParam;
import static org.springframework.web.reactive.function.server
        .RouterFunctions.route;

@Configuration
public class RouterFunctionConfig {

    @Autowired
    private TacoRepository tacoRepo;

    @Bean
    public RouterFunction<?> routerFunction() {
        return route(GET("/api/tacos").and(queryParam("recent", t -> t != null)),
                this::recents)
                .andRoute(POST("api/tacos"), this::postTaco);
    }

    public Mono<ServerResponse> recents(ServerRequest request) {
        return ServerResponse.ok()
                .body(tacoRepo.findAll().take(12), Taco.class);
    }

    public Mono<ServerResponse> postTaco(ServerRequest request) {
        return request.bodyToMono(Taco.class)
                .flatMap(taco -> tacoRepo.save(taco))
                .flatMap(savedTaco -> {
                    return ServerResponse
                            .created(URI.create(
                                    "http://localhost:8080/api/tacos/" + savedTaco.getId())
                            )
                            .body(savedTaco, Taco.class);
                });
    }
}

Như bạn có thể thấy, phương thức routerFunction() khai báo một bean RouterFunction<?>, giống như ví dụ "Hello World". Nhưng nó khác biệt ở điều loại yêu cầu nào được xử lý và cách chúng được xử lý. Trong trường hợp này, RouterFunction được tạo ra để xử lý các yêu cầu GET cho /api/tacos?recent và các yêu cầu POST cho /api/tacos.

Điều đặc biệt hơn là các tuyến đường được xử lý thông qua tham chiếu phương thức. Lambda là tuyệt vời khi hành vi đằng sau một RouterFunction là đơn giản và ngắn gọn. Tuy nhiên, trong nhiều trường hợp, nó tốt hơn là trích xuất chức năng đó thành một phương thức riêng (hoặc thậm chí là một phương thức riêng trong một lớp riêng) để duy trì tính đọc mã nguồn.

Đối với nhu cầu của bạn, yêu cầu GET cho /api/tacos?recent sẽ được xử lý bởi phương thức recents(). Nó sử dụng TacoRepository được chèn để lấy một Flux<Taco>, từ đó nó lấy 12 mục. Sau đó, nó bọc Flux<Taco> trong một Mono<ServerResponse> để chúng ta có thể đảm bảo rằng phản ứng có trạng thái HTTP 200 (OK) bằng cách gọi ok() trên ServerResponse. Quan trọng để hiểu rằng mặc dù có thể có tới 12 taco được trả về, nhưng chỉ có một server response đó là lý do tại sao nó được trả về trong một Mono chứ không phải là Flux. Bên trong, Spring vẫn sẽ truyền Flux<Taco> đến máy khách như là một Flux.

Trong khi đó, các yêu cầu POST cho /api/tacos sẽ được xử lý bởi phương thức postTaco(), trích xuất Mono<Taco> từ body của ServerRequest đầu vào. Phương thức postTaco() sau đó sử dụng một loạt các hoạt động flatMap() để lưu taco đó vào TacoRepository và tạo một ServerResponse với mã trạng thái HTTP 201 (CREATED) và đối tượng Taco đã được lưu trong response body.

Các hoạt động flatMap() được sử dụng để đảm bảo rằng tại mỗi bước trong quá trình, kết quả của ánh xạ được bao bọc trong một Mono, bắt đầu với Mono<Taco> sau flatMap() đầu tiên và cuối cùng kết thúc với Mono<ServerResponse> được trả về từ postTaco().

@Configuration
public class RouterFunctionConfig {

    @Autowired
    private TacoRepository tacoRepo;

    @Bean
    public RouterFunction<?> routerFunction() {
        return route(GET("/api/tacos").and(queryParam("recent", t -> t != null)),
                this::recents)
                .andRoute(POST("api/tacos"), this::postTaco);
    }

    public Mono<ServerResponse> recents(ServerRequest request) {
        return ServerResponse.ok()
                .body(tacoRepo.findAll().take(12), Taco.class);
    }

    public Mono<ServerResponse> postTaco(ServerRequest request) {
        return request.bodyToMono(Taco.class)
                .flatMap(taco -> tacoRepo.save(taco)) // Ở đây là Mono<Taco> gọi flatMap trả về Mono<S>
                .flatMap(savedTaco -> {    // Ở đây là Mono<Taco> gọi flatMap trả về Mono<ServerResponse>
                    return ServerResponse
                            .created(URI.create(
                                    "http://localhost:8080/api/tacos/" + savedTaco.getId())
                            )
                            .body(savedTaco, Taco.class);
                });
    }
}

12.3 Testing reactive controllers

Khi đến việc kiểm thử các bộ điều khiển phản ứng, Spring đã không bỏ lại chúng ta trong tình cảnh khó khăn. Thực sự, Spring đã giới thiệu WebTestClient, một tiện ích kiểm thử mới giúp dễ dàng viết các bài kiểm thử cho các bộ điều khiển phản ứng được viết với Spring WebFlux. Để xem cách viết kiểm thử với WebTestClient, hãy bắt đầu bằng cách sử dụng nó để kiểm thử phương thức recentTacos() từ TacoController mà bạn đã viết trong phần 12.1.2.

12.3.1 Testing GET requests

Một điều chúng ta muốn đảm bảo về phương thức recentTacos() là nếu một yêu cầu HTTP GET được gửi đến đường dẫn /api/tacos?recent, thì phản ứng sẽ chứa một dữ liệu JSON với không quá 12 chiếc taco. Lớp kiểm thử trong đoạn mã kế tiếp là một bắt đầu tốt.

Listing 12.1 Using WebTestClient to test TacoController 

Phương thức `shouldReturnRecentTacos()` trước hết thiết lập dữ liệu kiểm thử dưới dạng một Flux<Taco>. Flux này sau đó được cung cấp làm giá trị trả về từ phương thức findAll() của một mock TacoRepository.
@Test
public void shouldReturnRecentTacos() {
    Taco[] tacos = {
            testTaco(1l), testTaco(2l),
            testTaco(3l), testTaco(4l),
            testTaco(5l), testTaco(6l),
            testTaco(7l), testTaco(8l),
            testTaco(9l), testTaco(10l),
            testTaco(11l), testTaco(12l),
            testTaco(13l), testTaco(14l),
            testTaco(15l), testTaco(16l),
    };
    Flux<Taco> tacoFlux = Flux.just(tacos);
    TacoRepository tacoRepo = Mockito.mock(TacoRepository.class);
    when(tacoRepo.findAll()).thenReturn(tacoFlux);  // Mocks the TacoRepository

    WebTestClient testClient = WebTestClient.bindToController(
            new TacoController(tacoRepo)
    ).build();
    
    testClient.get().uri("/api/tacos?recent")
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$").isArray()
            .jsonPath("$").isNotEmpty()
            // Taco 1
            .jsonPath("$[0].id").isEqualTo(tacos[0].getId().toString())
            .jsonPath("$[0].name").isEqualTo("Taco 1")
            // Taco 2
            .jsonPath("$[1].id").isEqualTo(tacos[1].getId().toString())
            .jsonPath("$[1].name").isEqualTo("Taco 2")
            // Taco 11
            .jsonPath("$[11].id").isEqualTo(tacos[11].getId().toString())
            .jsonPath("$[11].name").isEqualTo("Taco 12")
            
            .jsonPath("$[12]").doesNotExist();
}

Đối với các đối tượng Taco sẽ được publish bởi Flux, chúng được tạo ra bằng một phương thức tiện ích có tên là testTaco(), khi được cung cấp một số, sẽ tạo ra một đối tượng Taco có ID và tên dựa trên số đó. Phương thức testTaco() được triển khai như sau:

private Taco testTaco(Long number) {
    Taco taco = new Taco();
    taco.setId(number);
    taco.setName("Taco " + number);
    List<Ingredient> ingredients = new ArrayList<>();
    ingredients.add(
            new Ingredient("INGA", "Ingredient A", Ingredient.Type.WRAP));
    taco.setIngredients(ingredients);
    return taco;
}

Vì sự đơn giản, tất cả các tacos kiểm thử sẽ có cùng hai ingredients. Tuy nhiên, ID và tên của chúng sẽ được xác định bởi số được cung cấp.

Trong phương thức shouldReturnRecentTacos(), bạn đã khởi tạo một TacoController, tiêm mock TacoRepository vào constructor. Controller được chuyển vào WebTestClient.bindToController() để tạo một phiên bản của WebTestClient.

Với tất cả các thiết lập hoàn tất, bạn đã sẵn sàng sử dụng WebTestClient để gửi một yêu cầu GET đến /api/tacos?recent và xác nhận rằng response đáp ứng đúng như mong đợi của bạn. Bằng cách gọi get().uri("/api/tacos?recent"), bạn mô tả yêu cầu bạn muốn gửi. Sau đó, cuộc gọi exchange() gửi yêu cầu, sẽ được xử lý bởi controller mà WebTestClient đang được liên kết với - TacoController.

Cuối cùng, bạn có thể xác nhận rằng response đáp ứng đúng như mong đợi expected.. Bằng cách gọi expectStatus(), bạn khẳng định rằng response có mã trạng thái HTTP 200 (OK). Sau đó, bạn thấy một số cuộc gọi đến jsonPath() khẳng định rằng JSON trong phần response body có các giá trị như mong đợi. Khẳng định cuối cùng kiểm tra rằng phần tử thứ 12 (trong mảng bắt đầu từ 0) không tồn tại, vì kết quả không bao giờ có nhiều hơn 12 phần tử.

Nếu JSON trả về phức tạp, với nhiều dữ liệu hoặc dữ liệu lồng ghép nhiều, việc sử dụng jsonPath() có thể làm phiền phức. Trong thực tế, tôi đã bỏ qua nhiều cuộc gọi đến jsonPath() trong đoạn mã 12.1 để tiết kiệm không gian. Đối với những trường hợp mà việc sử dụng jsonPath() có thể lộn xộn, WebTestClient cung cấp json(), chấp nhận một tham số String chứa JSON để so sánh response. 

Ví dụ, giả sử bạn đã tạo JSON phản hồi hoàn chỉnh trong một tệp có tên là recent-tacos.json và đặt nó trong đường dẫn /tacos của classpath. Sau đó, bạn có thể viết lại các expected WebTestClient như sau:
ClassPathResource classResource = new ClassPathResource("/tacos/recent-tacos.json");
String jsonResource =
        StreamUtils.copyToString(
                classResource.getInputStream(),
                Charset.defaultCharset());
log.info(jsonResource);
WebTestClient webTestClient =
        WebTestClient.bindToController(
                new TacoController(tacoRepo)
        ).build();
webTestClient.get()
        .uri("/api/tacos?recent")
        .exchange() // == execute
        .expectStatus().isOk()
        .expectBody()
        .json(jsonResource);

Vì phương thức `json()` chấp nhận một chuỗi, bạn cần trước tiên tải nguồn tài nguyên từ đường dẫn lưu trữ vào một chuỗi. May mắn thay, `StreamUtils` của Spring giúp làm điều này dễ dàng với phương thức `copyToString()`. Chuỗi được trả về từ `copyToString()` sẽ chứa toàn bộ JSON mà bạn mong đợi trong phản ứng của yêu cầu của bạn. Truyền nó vào phương thức `json()` đảm bảo rằng controller đang sản xuất đầu ra đúng.

Một lựa chọn khác mà WebTestClient cung cấp là cho phép bạn so sánh nội dung response với một danh sách các giá trị. Phương thức `expectBodyList()` chấp nhận một Class hoặc một ParameterizedTypeReference chỉ định loại phần tử trong danh sách và trả về một đối tượng ListBodySpec để thực hiện các expect. Bằng cách sử dụng `expectBodyList()`, bạn có thể viết lại bài kiểm thử để sử dụng một phần của cùng dữ liệu kiểm thử bạn đã sử dụng để tạo ra `mock TacoRepository`, như được thể hiện ở đây:
@Test
public void testExpectBodyList() throws IOException {
    // Tạo 1 mảng đối tượng cần test để chuyển đổi sang reactive [Flux]
    Taco[] tacos = {
            testTaco(1l), testTaco(2l),
            testTaco(3l), testTaco(4l),
            testTaco(5l), testTaco(6l),
            testTaco(7l), testTaco(8l),
            testTaco(9l), testTaco(10l),
            testTaco(11l), testTaco(12l),
            testTaco(13l), testTaco(14l),
            testTaco(15l), testTaco(16l),
    };

    Flux<Taco> tacosFlux = Flux.just(tacos);

    // Tạo 1 mock repository - repository mô phỏng (không cần csdl)
    TacoRepository tacoRepo = Mockito.mock(TacoRepository.class);
    when(tacoRepo.findAll()).thenReturn(tacosFlux);

    WebTestClient webTestClient =
            WebTestClient.bindToController(
                    new TacoController(tacoRepo)
            ).build();
    webTestClient.get()
            .uri("/api/tacos?recent")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBodyList(Taco.class)
                .contains(Arrays.copyOf(tacos, 12));
}

12.3.2 Testing POST requests

WebTestClient có thể làm nhiều hơn chỉ kiểm thử các yêu cầu GET đối với các controller. Nó cũng có thể được sử dụng để kiểm thử bất kỳ loại phương thức HTTP nào. Bảng 12.1 ánh xạ các phương thức HTTP với các phương thức của WebTestClient.

 

Như một ví dụ về việc kiểm thử yêu cầu phương thức HTTP khác trên một controller của Spring WebFlux, hãy xem xét một bài kiểm thử khác đối với `TacoController`. Lần này, bạn sẽ viết một bài kiểm thử cho end point tạo taco của API của bạn bằng cách gửi một yêu cầu POST đến `/api/tacos` như sau:

Tương tự như phương thức kiểm thử trước đó, `shouldSaveATaco()` bắt đầu bằng cách giả mạo `TacoRepository`, xây dựng một `WebTestClient` được kết nối với controller và thiết lập một số dữ liệu kiểm thử. Sau đó, nó sử dụng `WebTestClient` để gửi một yêu cầu POST đến `/api/tacos`, với một thân yêu cầu kiểu `application/json` và một dữ liệu gửi là một biểu diễn JSON của đối tượng `Taco` trong `Mono` chưa được lưu. Sau khi thực hiện `exchange()`, kiểm thử khẳng định rằng phản hồi có một trạng thái HTTP 201 (CREATED) và một thân phản hồi trong phần thân bằng với đối tượng `Taco` đã được lưu.

@SuppressWarnings("unchecked")
@Test
public void shouldSaveATaco() {
    TacoRepository tacoRepo = Mockito.mock(TacoRepository.class);
    WebTestClient testClient =
            WebTestClient.bindToController(
                    new TacoController(tacoRepo)
            ).build();

    Mono<Taco> unsavedTacoMono = Mono.just(testTaco(1L));
    Taco savedTaco = testTaco(1L);
    Flux<Taco> savedTacoMono = Flux.just(savedTaco);
    when(tacoRepo.saveAll(any(Mono.class))).thenReturn(savedTacoMono);
    testClient
            .post()
            .uri("/api/tacos")
            .contentType(MediaType.APPLICATION_JSON)
            .body(unsavedTacoMono, Taco.class)
            .exchange()
            .expectStatus().isCreated()
            .expectBody(Taco.class)
            .isEqualTo(savedTaco);
}

12.3.3 Testing with a live server

Các bài kiểm tra bạn đã viết cho đến nay đã dựa vào một triển khai giả mạo (mock) của framework Spring WebFlux để không cần thiết phải sử dụng một máy chủ thực sự. Nhưng có thể bạn cần kiểm thử một controller WebFlux trong ngữ cảnh của một máy chủ như Netty hoặc Tomcat và có thể với một repository hoặc các phụ thuộc khác. Nói cách khác, bạn có thể muốn viết một kiểm thử tích hợp.

Để viết một kiểm thử tích hợp bằng WebTestClient, bạn bắt đầu bằng cách chú thích lớp kiểm thử với @RunWith và @SpringBootTest giống như bất kỳ kiểm thử tích hợp Spring Boot nào khác, như được hiển thị ở đây:

package tacos.web.api;

import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.reactive.server.WebTestClient;

@ExtendWith(SpringExtension.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class TacoControllerWebTest {
    @Autowired
    private WebTestClient testClient;
    
    
}

Bằng cách đặt thuộc tính webEnvironment thành WebEnvironment.RANDOM_PORT, bạn đang yêu cầu Spring khởi động một máy chủ đang chạy lắng nghe trên một cổng được chọn ngẫu nhiên. Bạn cũng sẽ nhận thấy rằng bạn đã autowire một đối tượng WebTestClient vào lớp kiểm thử. Điều này không chỉ có nghĩa là bạn sẽ không cần phải tạo một trong các phương thức kiểm thử của mình mà còn là bạn sẽ không cần phải chỉ định một URL đầy đủ khi thực hiện các yêu cầu. Điều này là do WebTestClient sẽ được cấu hình để biết cổng nào máy chủ kiểm thử đang chạy. Bây giờ bạn có thể viết lại `shouldReturnRecentTacos()` như một kiểm thử tích hợp sử dụng WebTestClient được `autowired` như sau:

Chắc chắn bạn đã nhận thấy rằng phiên bản mới của `shouldReturnRecentTacos()` có rất ít mã. Bạn không còn cần phải tạo một `WebTestClient` vì bạn sẽ sử dụng phiên bản được `autowired`. Bạn cũng không cần phải mô phỏng `TacoRepository` vì Spring sẽ tạo một phiên bản của `TacoController` và tiêm vào đó một `TacoRepository` thực tế. Trong phiên bản mới của phương thức kiểm thử này, bạn sử dụng các biểu thức JSONPath để xác nhận các giá trị được cung cấp từ cơ sở dữ liệu.

`WebTestClient` hữu ích khi, trong quá trình kiểm thử, bạn cần sử dụng API mà một controller WebFlux đã cung cấp. Nhưng khi ứng dụng của bạn chính nó tiêu thụ một số API khác, thì làm thế nào? Hãy chuyển sự chú ý của chúng ta sang phía khách hàng của câu chuyện web phản ứng của Spring và xem làm thế nào `WebClient` cung cấp một REST client làm việc với các loại phản ứng như `Mono` và `Flux`.

12.4 Consuming REST APIs reactively

Trong chương 8, bạn đã sử dụng `RestTemplate` để thực hiện các yêu cầu từ phía khách hàng đến API Taco Cloud. `RestTemplate` là một công cụ đã tồn tại từ lâu, được giới thiệu từ phiên bản Spring 3.0. Theo thời gian, nó đã được sử dụng để thực hiện vô số yêu cầu cho các ứng dụng sử dụng nó. Nhưng tất cả các phương thức được cung cấp bởi `RestTemplate` đều xử lý domain và collection non-reactive. Điều này có nghĩa là nếu bạn muốn làm việc với dữ liệu reactive của một phản hồi, bạn sẽ cần bọc nó trong một `Flux` hoặc `Mono`. Và nếu bạn đã có một `Flux` hoặc `Mono` và bạn muốn gửi nó trong một yêu cầu POST hoặc PUT, sau đó bạn sẽ cần trích xuất dữ liệu thành một loại non-reactive trước khi thực hiện yêu cầu.
Sẽ tốt nếu có cách nào đó để sử dụng `RestTemplate` một cách tự nhiên với các loại reactive. Đừng lo lắng. Spring cung cấp `WebClient` như một lựa chọn phản ứng thay thế cho `RestTemplate`. `WebClient` cho phép bạn cả gửi và nhận các loại reactive khi thực hiện các yêu cầu đến các API bên ngoài.

Việc sử dụng `WebClient` khác khá nhiều so với việc sử dụng `RestTemplate`. Thay vì có nhiều phương thức để xử lý các loại yêu cầu khác nhau, `WebClient` có một giao diện xây dựng mạnh mẽ giúp bạn mô tả và gửi yêu cầu. Mô hình sử dụng chung để làm việc với `WebClient` như sau:

 Tạo một thể hiện của `WebClient` (hoặc tiêm một `WebClient` bean)
 Chỉ định phương thức HTTP của yêu cầu để gửi
 Chỉ định URI và bất kỳ tiêu đề nào cần có trong yêu cầu
 Gửi yêu cầu
 Tiêu thụ phản hồi

Hãy xem một số ví dụ về `WebClient` trong hành động, bắt đầu bằng cách làm thế nào để sử dụng `WebClient` để gửi các yêu cầu HTTP GET.

12.4.1 GETting resources

Như một ví dụ về cách sử dụng `WebClient`, giả sử bạn cần lấy một đối tượng `Ingredient` thông qua ID từ API Taco Cloud. Sử dụng `RestTemplate`, bạn có thể sử dụng phương thức `getForObject()`. Nhưng với `WebClient`, bạn build một request, nhận phản hồi, và sau đó trích xuất một `Mono` publish đối tượng `Ingredient`, như sau:

Mono<Ingredient> ingredient = WebClient.create()
.get()
.uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
.retrieve()
.bodyToMono(Ingredient.class);
ingredient.subscribe(i -> { ... });

Ở đây, bạn tạo một thể hiện mới của `WebClient` với `create()`. Sau đó, bạn sử dụng `get()` và `uri()` để xác định một yêu cầu GET đến http://localhost:8080/ingredients/{id}, trong đó `{id}` sẽ được thay thế bằng giá trị trong `ingredientId`. Phương thức `retrieve()` thực hiện yêu cầu. Cuối cùng, cuộc gọi đến `bodyToMono()` trích xuất nội dung body của phản hồi vào một `Mono<Ingredient>` mà bạn có thể tiếp tục áp dụng các thao tác `Mono` bổ sung khác.

Để áp dụng các thao tác bổ sung khác trên `Mono` được trả về từ `bodyToMono()`, quan trọng là phải subscribe nó trước khi yêu cầu thậm chí được gửi đi. Việc thực hiện các yêu cầu có thể trả về một bộ sưu tập giá trị là dễ dàng. Ví dụ, đoạn mã sau đây lấy tất cả các thành phần:

```java
Flux<Ingredient> ingredients = WebClient.create()
    .get()
    .uri("http://localhost:8080/ingredients")
    .retrieve()
    .bodyToFlux(Ingredient.class);

ingredients.subscribe(i -> { ... });
```

Phần lớn thời gian, việc lấy nhiều mục giống như việc thực hiện một yêu cầu cho một mục duy nhất. Sự khác biệt lớn là thay vì sử dụng `bodyToMono()` để trích xuất nội dung body của phản hồi vào một `Mono`, bạn sử dụng `bodyToFlux()` để trích xuất nó thành một `Flux`.

Như `bodyToMono()`, `Flux` được trả về từ `bodyToFlux()` vẫn chưa được subscribe. Điều này cho phép các thao tác bổ sung khác (filter, map, v.v.) được áp dụng vào `Flux` trước khi dữ liệu bắt đầu chảy qua nó. Do đó, quan trọng là phải subscribe theo dõi vào `Flux` kết quả, nếu không yêu cầu sẽ không bao giờ được gửi đi.

MAKING REQUESTS WITH A BASE URI
Có thể bạn sẽ sử dụng một URI cơ bản chung cho nhiều yêu cầu khác nhau. Trong trường hợp đó, việc tạo một `WebClient` bean với một URI cơ bản và tiêm nó vào bất cứ nơi nào cần thiết có thể rất hữu ích. Một bean như vậy có thể được khai báo như sau (trong bất kỳ lớp được chú thích bằng @Configuration nào):

@Bean
public WebClient webClient() {
    return WebClient.create("http://localhost:8080");
}

Sau đó, ở bất kỳ nơi nào bạn cần thực hiện các yêu cầu sử dụng base URI đó, bạn có thể tiêm `WebClient` bean và sử dụng nó như sau:

@Autowired
WebClient webClient;

public Mono<Ingredient> getIngredientById(String ingredientId) {
    Mono<Ingredient> ingredient = webClient
            .get()
            .uri("/ingredients/{id}", ingredientId)
            .retrieve()
            .bodyToMono(Ingredient.class);

    ingredient.subscribe(i -> { ... });
}


Bởi vì `WebClient` đã được tạo trước đó, bạn có thể bắt đầu ngay bằng cách gọi `get()`. Đối với URI, bạn chỉ cần chỉ định đường dẫn liên quan đến URI cơ bản khi gọi `uri()`.

TIMING OUT ON LONG-RUNNING REQUESTS

Một điều mà bạn có thể chắc chắn là mạng không luôn đáng tin cậy hoặc nhanh chóng như bạn mong đợi. Hoặc có thể một máy chủ từ xa đang chậm trong việc xử lý một yêu cầu. Lý tưởng, một yêu cầu đến một dịch vụ từ xa sẽ trả về trong khoảng thời gian hợp lý. Nhưng nếu không, tốt nhất là nếu người gọi không bị kẹt đợi phản hồi quá lâu.

Để tránh tình trạng yêu cầu từ người gọi bị kẹt đợi bởi một mạng hoặc dịch vụ chậm, bạn có thể sử dụng phương thức `timeout()` từ `Flux` hoặc `Mono` để đặt giới hạn thời gian bạn sẽ đợi cho dữ liệu được xuất bản. Ví dụ, xem cách bạn có thể sử dụng `timeout()` khi lấy dữ liệu nguyên liệu, như trong đoạn mã dưới đây:

Flux<Ingredient> ingredients = webClient
        .get()
        .uri("/ingredients")
        .retrieve()
        .bodyToFlux(Ingredient.class);

ingredients
        .timeout(Duration.ofSeconds(1))
        .subscribe(
                i -> { ... },
                e -> {
                    // xử lý lỗi thời gian chờ
                }
        );

Như bạn có thể thấy, trước khi subscribe vào `Flux`, bạn đã gọi `timeout()`, chỉ định một khoảng thời gian là 1 giây. Nếu yêu cầu có thể được thực hiện trong thời gian ngắn hơn 1 giây, thì không có vấn đề. Nhưng nếu yêu cầu mất thời gian hơn 1 giây, nó sẽ hết thời gian và xử lý lỗi được chuyển vào như là tham số thứ hai của `subscribe()`.

12.4.2 Sending resources

Gửi dữ liệu với WebClient không khác nhiều so với nhận dữ liệu. Ví dụ, giả sử bạn có một `Mono<Ingredient>` và muốn gửi một yêu cầu POST với `Ingredient` được xuất bản bởi `Mono` đó đến URI với đường dẫn tương đối là /ingredients. Bạn chỉ cần sử dụng phương thức `post()` thay vì `get()` và chỉ định rằng `Mono` sẽ được sử dụng để điền vào Request body bằng cách gọi `body()` như sau:

Mono<Ingredient> ingredientMono = Mono.just(
    new Ingredient("INGC", "Ingredient C", Ingredient.Type.VEGGIES));
Mono<Ingredient> result = webClient
    .post()
    .uri("/ingredients")
    .body(ingredientMono, Ingredient.class)
    .retrieve()
    .bodyToMono(Ingredient.class);
result.subscribe(i -> { ... });

Nếu bạn không có `Mono` hoặc `Flux` để gửi, mà thay vào đó có đối tượng miền nguyên bản, bạn có thể sử dụng `bodyValue()`. Ví dụ, giả sử thay vì một `Mono<Ingredient>`, bạn có một `Ingredient` mà bạn muốn gửi trong phần thân yêu cầu, như sau:

Ingredient ingredient = ...;
Mono<Ingredient> result = webClient
    .post()
    .uri("/ingredients")
    .bodyValue(ingredient)
    .retrieve()
    .bodyToMono(Ingredient.class);
result.subscribe(i -> { ... });

Thay vì một yêu cầu POST, nếu bạn muốn cập nhật một `Ingredient` bằng một yêu cầu PUT, bạn gọi `put()` thay vì `post()` và điều chỉnh đường dẫn URI tương ứng, như sau:

Mono<Void> result = webClient
    .put()
    .uri("/ingredients/{id}", ingredient.getId())
    .bodyValue(ingredient)
    .retrieve()
    .bodyToMono(Void.class);
result.subscribe();

Yêu cầu PUT thường có phần thể hiện phản hồi trống, nên bạn phải yêu cầu `bodyToMono()` trả về một `Mono` kiểu `Void`. Khi đăng ký vào `Mono` đó, yêu cầu sẽ được gửi đi.

12.4.3 Deleting resources

`WebClient` cũng cho phép xóa các nguồn thông qua phương thức `delete()`. Ví dụ, đoạn mã sau xóa một nguyên liệu cho một ID cụ thể:

```java
Mono<Void> result = webClient
    .delete()
    .uri("/ingredients/{id}", ingredientId)
    .retrieve()
    .bodyToMono(Void.class);
result.subscribe();
```

Tương tự như yêu cầu PUT, yêu cầu DELETE thường không có phần thể hiện. Một lần nữa, bạn trả về và đăng ký vào `Mono<Void>` để gửi yêu cầu.

12.4.4 Handling errors

Tất cả các ví dụ về WebClient cho đến nay đều giả định một kết thúc vui vẻ; không có phản hồi với mã trạng thái 400 hoặc 500. Nếu một trong hai loại mã trạng thái lỗi này được trả về, WebClient sẽ đăng nhập sự cố và tiếp tục mà không có sự cố.

Nếu bạn cần xử lý các lỗi như vậy, bạn có thể sử dụng phương thức onStatus() để chỉ định cách xử lý các mã trạng thái HTTP khác nhau. onStatus() chấp nhận hai function: một hàm predicate, được sử dụng để so khớp mã trạng thái HTTP, và một hàm mà, dựa trên đối tượng ClientResponse, trả về một Mono<Throwable>.

Để minh họa cách onStatus() có thể được sử dụng để tạo một trình xử lý lỗi tùy chỉnh, hãy xem xét việc sử dụng WebClient để lấy một đối tượng Ingredient dựa trên ID của nó:

Mono<Ingredient> ingredientMono = webClient
    .get()
    .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
    .retrieve()
    .bodyToMono(Ingredient.class);

Miễn là giá trị trong ingredientId phù hợp với một nguồn nguyên liệu đã biết, thì Mono kết quả sẽ xuất bản đối tượng Ingredient khi được đăng ký. Nhưng điều gì sẽ xảy ra nếu không có nguyên liệu phù hợp?

Khi đăng ký vào một Mono hoặc Flux có thể kết thúc với một lỗi, quan trọng là phải đăng ký một người tiêu thụ lỗi cũng như một người tiêu thụ dữ liệu trong cuộc gọi tới subscribe(), như sau:

ingredientMono.subscribe(
    ingredient -> {
        // xử lý dữ liệu nguyên liệu
        // ...
    },
    error -> {
        // xử lý lỗi
        // ...
    });

Nếu nguồn nguyên liệu được tìm thấy, sau đó hàm lambda đầu tiên (người tiêu thụ dữ liệu) được chuyển đến subscribe() sẽ được gọi với đối tượng Ingredient phù hợp. Nhưng nếu không tìm thấy, sau đó yêu cầu sẽ phản hồi với mã trạng thái HTTP 404 (NOT FOUND), dẫn đến việc hàm lambda thứ hai (người tiêu thụ lỗi) được cung cấp mặc định là WebClientResponseException.

Vấn đề lớn nhất với WebClientResponseException là nó khá không cụ thể về điều gì có thể đã điều gì sai để làm cho Mono thất bại. Tên của nó gợi ý rằng có một lỗi trong phản hồi từ một yêu cầu được thực hiện bởi WebClient, nhưng bạn sẽ cần đào sâu vào WebClientResponseException để biết điều gì đã sai. Và trong bất kỳ sự kiện nào, sẽ tốt nếu ngoại lệ được chuyển đến người tiêu thụ lỗi là cụ thể cho miền hơn là dành cho WebClient.

Bằng cách thêm một trình xử lý lỗi tùy chỉnh, bạn có thể cung cấp mã chuyển đổi mã trạng thái thành Throwable theo lựa chọn của riêng bạn. Hãy nói rằng bạn muốn một yêu cầu không thành công cho một nguồn nguyên liệu để khiến Mono hoàn thành với lỗi là UnknownIngredientException. Bạn có thể thêm cuộc gọi onStatus() sau cuộc gọi retrieve() để đạt được điều đó:

Mono<Ingredient> ingredientMono = webClient
    .get()
    .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError,
              response -> Mono.just(new UnknownIngredientException()))
    .bodyToMono(Ingredient.class);

Đối số đầu tiên trong cuộc gọi onStatus() là một predicate được cung cấp một HttpStatus và trả về true nếu mã trạng thái là một bạn muốn xử lý. Và nếu mã trạng thái phù hợp, sau đó phản hồi sẽ được chuyển đến hàm trong đối số thứ hai để xử lý như nó thấy phù hợp, cuối cùng trả về một Mono của kiểu Throwable.

Trong ví dụ, nếu mã trạng thái là một mã trạng thái lỗi cấp 400 (ví dụ: lỗi của khách hàng), sau đó một Mono sẽ được trả về với một UnknownIngredientException. Điều này làm cho ingredientMono thất bại với ngoại lệ đó.
Lưu ý rằng HttpStatus::is4xxClientError là một tham chiếu phương thức đến phương thức is4xx- ClientError của HttpStatus. Đó là phương thức này sẽ được gọi trên đối tượng HttpStatus đã cho. Nếu bạn muốn, bạn có thể sử dụng một phương thức khác trên HttpStatus như một tham chiếu phương thức; hoặc bạn có thể cung cấp chức năng của riêng mình dưới dạng lambda hoặc tham chiếu phương thức trả về một boolean.
Ví dụ, bạn có thể trở nên chính xác hơn trong việc xử lý lỗi của mình, kiểm tra cụ thể cho một mã trạng thái HTTP 404 (NOT FOUND) bằng cách thay đổi cuộc gọi onStatus() nhìn như sau:
javaCopy code
Mono<Ingredient> ingredientMono = webClient .get() .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId) .retrieve() .onStatus(status -> status == HttpStatus.NOT_FOUND, response -> Mono.just(new UnknownIngredientException())) .bodyToMono(Ingredient.class); 
Cũng đáng lưu ý rằng bạn có thể có nhiều cuộc gọi onStatus() như bạn cần để xử lý bất kỳ loại mã trạng thái HTTP nào có thể trả về trong phản hồi.

12.4.5 Exchanging requests

Cho đến giờ, bạn đã sử dụng phương thức retrieve() để biểu thị việc gửi một yêu cầu khi làm việc với WebClient. Trong những trường hợp đó, phương thức retrieve() trả về một đối tượng của kiểu ResponseSpec, qua đó bạn có thể xử lý phản hồi bằng cách gọi các phương thức như onStatus(), bodyToFlux(), và bodyToMono(). Việc làm việc với ResponseSpec là phù hợp cho các trường hợp đơn giản, nhưng nó có một số hạn chế. Nếu bạn cần truy cập vào tiêu đề hoặc giá trị cookie của phản hồi, ví dụ, thì ResponseSpec không phải là sự lựa chọn phù hợp cho bạn.

Khi ResponseSpec không đáp ứng đủ, bạn có thể thử gọi exchangeToMono() hoặc exchangeToFlux() thay vì retrieve(). Phương thức exchangeToMono() trả về một Mono kiểu ClientResponse, trên đó bạn có thể áp dụng các thao tác reactive để kiểm tra và sử dụng dữ liệu từ toàn bộ phản hồi, bao gồm cả payload, headers và giá trị cookie. Phương thức exchangeToFlux() hoạt động theo cách tương tự nhưng trả về một Flux kiểu ClientResponse để làm việc với nhiều mục dữ liệu trong phản hồi.

Trước khi chúng ta xem xét điều làm cho exchangeToMono() và exchangeToFlux() khác biệt so với retrieve(), hãy bắt đầu bằng cách nhìn vào sự tương đồng giữa chúng. Đoạn mã dưới đây sử dụng một WebClient và exchangeToMono() để lấy một nguyên liệu duy nhất thông qua ID của nguyên liệu:

Mono<Ingredient> ingredientMono = webClient
    .get()
    .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
    .exchangeToMono(cr -> cr.bodyToMono(Ingredient.class));

Điều này khá tương đương với ví dụ tiếp theo sử dụng retrieve():

Mono<Ingredient> ingredientMono = webClient
    .get()
    .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
    .retrieve()
    .bodyToMono(Ingredient.class);

Trong ví dụ exchangeToMono(), thay vì sử dụng bodyToMono() của đối tượng ResponseSpec để có được một Mono<Ingredient>, bạn có được một Mono<ClientResponse> trên đó bạn có thể áp dụng một hàm flat-mapping để ánh xạ ClientResponse thành một Mono<Ingredient>, sau đó được làm phẳng vào Mono kết quả.

Hãy xem xét điều gì khiến exchangeToMono() khác biệt so với retrieve(). Giả sử phản hồi từ yêu cầu có thể bao gồm một tiêu đề có tên là X_UNAVAILABLE với giá trị là true để chỉ ra rằng (vì một lý do nào đó) nguyên liệu cần tìm không khả dụng. Và vì lợi ích thảo luận, giả sử nếu tiêu đề đó tồn tại, bạn muốn Mono kết quả trở thành rỗng không trả về bất cứ điều gì. Bạn có thể đạt được kịch bản này bằng cách thêm một cuộc gọi khác cho flatMap(), nhưng giờ đây nó đơn giản hơn với một cuộc gọi WebClient như sau:

Mono<Ingredient> ingredientMono = webClient
    .get()
    .uri("http:/ /localhost:8080/ingredients/{id}", ingredientId)
    .exchangeToMono(cr -> {
        if (cr.headers().header("X_UNAVAILABLE").contains("true")) {
            return Mono.empty();
        }
        return Mono.just(cr);
    })
    .flatMap(cr -> cr.bodyToMono(Ingredient.class));

Cuộc gọi flatMap() mới kiểm tra tiêu đề X_UNAVAILABLE có trong đối tượng ClientRequest đã cho, tìm kiếm một tiêu đề có tên X_UNAVAILABLE với giá trị true. Nếu tìm thấy, nó trả về một Mono rỗng. Ngược lại, nó trả về một Mono mới chứa ClientResponse. Trong cả hai trường hợp, Mono trả về sẽ được làm phẳng vào Mono mà cuộc gọi flatMap() tiếp theo sẽ hoạt động trên đó.
12.5 Securing reactive web APIs

Cho đến khi có Spring Security (và thậm chí trước đó, khi nó được biết đến với tên gọi là Acegi Security), mô hình bảo mật web của nó đã được xây dựng xung quanh các servlet filter. Sau tất cả, điều này có lý. Nếu bạn cần chặn một request đối với một framework web dựa trên servlet để đảm bảo người gửi yêu cầu có quyền hợp lý, thì một bộ lọc servlet là một lựa chọn hiển nhiên. Nhưng Spring WebFlux đặt ra một thách thức đối với cách tiếp cận đó.

Khi viết một ứng dụng web với Spring WebFlux, không có đảm bảo rằng servlets sẽ được sử dụng. Trên thực tế, có thể nói rằng một ứng dụng web có tính reactive có khả năng được xây dựng trên Netty hoặc một số máy chủ không sử dụng servlet khác. Điều này có nghĩa là không thể sử dụng bộ lọc servlet của Spring Security để bảo mật các ứng dụng Spring WebFlux?

Đúng là sử dụng bộ lọc servlet không phải là một lựa chọn khi bảo mật một ứng dụng Spring WebFlux. Nhưng Spring Security vẫn có thể thực hiện nhiệm vụ đó. Bắt đầu từ phiên bản 5.0.0, bạn có thể sử dụng Spring Security để bảo mật cả ứng dụng Spring MVC dựa trên servlet và ứng dụng Spring WebFlux reactive. Điều này được thực hiện bằng cách sử dụng WebFilter của Spring, một biến thể của bộ lọc servlet trong Spring không đòi hỏi phụ thuộc vào API servlet.

Điều đáng chú ý hơn là mô hình cấu hình cho Spring Security reactive không khác nhiều so với những gì bạn thấy trong chương 4. Trên thực tế, khác với Spring WebFlux, có một phụ thuộc riêng biệt cho Spring Security từ Spring MVC, Spring Security đến với cùng một bộ dependency starter Spring Boot, không phụ thuộc vào việc bạn có ý định sử dụng nó để bảo mật ứng dụng web Spring MVC hay một ứng dụng được viết với Spring WebFlux. Nhắc lại, đây là gói starter security:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

Tuy nhiên, có một số sự khác biệt nhỏ giữa mô hình cấu hình reactive và non-reactive của Spring Security. Đáng chú ý là xem xét cách mô hình cấu hình của hai loại so sánh.

12.5.1 Configuring reactive web security

Như một lời nhắc, cấu hình Spring Security để bảo mật một ứng dụng web Spring MVC thường liên quan đến việc tạo một lớp cấu hình mới mà mở rộng từ WebSecurityConfigurerAdapter và được chú thích bằng @EnableWebSecurity. Một lớp cấu hình như vậy sẽ ghi đè lên phương thức configure() để chỉ định các chi tiết an ninh web như quyền truy cập yêu cầu cho các đường dẫn yêu cầu cụ thể. Cấu hình an ninh Spring MVC không có tính phản ứng thường được thiết lập như sau:

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/api/tacos", "/orders").hasAuthority("USER")
                .antMatchers("/**").permitAll();
    }
}

Bây giờ hãy xem cấu hình này sẽ trông như thế nào cho một ứng dụng Spring WebFlux có tính phản ứng. Đoạn mã sau đây hiển thị một lớp cấu hình an ninh có tính phản ứng, độ tương đồng với cấu hình an ninh đơn giản từ trước đó.

Listing 12.2 Configuring Spring Security for a Spring WebFlux application 
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
            ServerHttpSecurity http) {
        return http.authorizeExchange()
                .pathMatchers("/api/tacos", "/orders").hasAuthority("USER")
                .anyExchange().permitAll()
                .and()
                .build();
    }
}

Như bạn có thể thấy, có nhiều điều quen thuộc, tuy nhiên, đồng thời, có nhiều điều khác biệt. Thay vì @EnableWebSecurity, lớp cấu hình mới này được chú thích bằng @EnableWebFluxSecurity. Hơn nữa, lớp cấu hình không mở rộng từ WebSecurityConfigurerAdapter hoặc bất kỳ lớp cơ sở nào khác. Do đó, nó cũng không ghi đè lên bất kỳ phương thức configure() nào.

Thay vào đó, bạn khai báo một bean có kiểu SecurityWebFilterChain với phương thức securityWebFilterChain(). Nội dung của securityWebFilterChain() không khác nhiều so với phương thức configure() của cấu hình trước đó, nhưng có một số thay đổi tinh tế.

Chủ yếu, cấu hình được khai báo bằng một đối tượng ServerHttpSecurity cụ thể thay vì đối tượng HttpSecurity. Bằng cách sử dụng ServerHttpSecurity được chỉ định, bạn có thể gọi authorizeExchange(), tương đương với authorizeRequests(), để khai báo an ninh ở cấp độ yêu cầu.

// Lưu ý: ServerHttpSecurity là mới trong Spring Security 5 và là biến thế có tính phản ứng của HttpSecurity.

// Khi khớp các đường dẫn, bạn vẫn có thể sử dụng các đường dẫn đại diện cho kiểu Ant-style wildcard, nhưng làm điều này với phương thức pathMatchers() thay vì antMatchers(). Và như một tiện ích, bạn không còn cần chỉ định một đường dẫn kiểu Ant-style chụp tất cả /** vì anyExchange() trả về chụp tất cả bạn cần.

// Cuối cùng, vì bạn đang khai báo SecurityWebFilterChain như một bean thay vì ghi đè lên một phương thức của framework, bạn phải gọi phương thức build() để lắp ráp tất cả các quy tắc an ninh thành SecurityWebFilterChain để trả về.

Ngoài những khác biệt nhỏ đó, cấu hình an ninh web không khác biệt nhiều giữa Spring WebFlux và Spring MVC. Nhưng với user details thì sao?
12.5.2 Configuring a reactive user details service

Khi mở rộng WebSecurityConfigurerAdapter, bạn ghi đè lên một phương thức configure() để khai báo các quy tắc an ninh web và một phương thức configure() khác để cấu hình logic xác thực, thường bằng cách định nghĩa một đối tượng UserDetails. Như một lời nhắc về điều này, xem xét phương thức configure() được ghi đè sau đây sử dụng một đối tượng UserRepository được inject thông qua một triển khai vô danh của UserDetailsService để tìm kiếm người dùng theo tên người dùng:

@Autowired
UserRepository userRepo;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(new UserDetailsService() {
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            User user = userRepo.findByUsername(username);
            if (user == null) {
                throw new UsernameNotFoundException(username + " not found");
            }
            return user.toUserDetails();
        }
    });
}

Trong cấu hình không phản ứng này, bạn ghi đè lên phương thức duy nhất được yêu cầu bởi UserDetailsService: loadUserByUsername(). Bên trong phương thức đó, bạn sử dụng UserRepository được cung cấp để tìm kiếm người dùng theo tên người dùng đã cho. Nếu tên không được tìm thấy, bạn ném một UsernameNotFoundException. Nhưng nếu tìm thấy, bạn gọi một phương thức trợ giúp, toUserDetails(), để trả về đối tượng UserDetails kết quả.

Trong cấu hình an ninh phản ứng, bạn không ghi đè lên một phương thức configure(). Thay vào đó, bạn khai báo một bean ReactiveUserDetailsService. ReactiveUserDetailsService là phiên bản phản ứng của UserDetailsService. Giống như UserDetailsService, ReactiveUserDetailsService chỉ yêu cầu triển khai một phương thức duy nhất. Cụ thể, phương thức findByUsername() trả về một Mono<UserDetails> thay vì một đối tượng UserDetails thuần túy.

Trong ví dụ sau, bean ReactiveUserDetailsService được khai báo để sử dụng một UserRepository được chỉ định, được giả sử là một kho Spring Data phản ứng (chúng ta sẽ nói thêm về điều này trong chương tiếp theo):

@Bean
public ReactiveUserDetailsService userDetailsService(
        UserRepository userRepo) {
    return new ReactiveUserDetailsService() {
        @Override
        public Mono<UserDetails> findByUsername(String username) {
            return userRepo.findByUsername(username)
                    .map(user -> {
                        return user.toUserDetails();
                    });
        }
    };
}

Ở đây, một Mono<UserDetails> được trả về như yêu cầu, nhưng phương thức UserRepository.findByUsername() trả về một Mono<User>. Bởi vì đó là một Mono, bạn có thể liên kết các hoạt động trên nó, chẳng hạn như một hoạt động map() để ánh xạ Mono<User> thành Mono<UserDetails>. Trong trường hợp này, hoạt động map() được áp dụng với một lambda gọi phương thức trợ giúp toUserDetails() trên đối tượng User được xuất bản bởi Mono. Điều này chuyển đổi User thành UserDetails. Do đó, hoạt động .map() trả về một Mono<UserDetails>, chính xác là điều mà ReactiveUserDetailsService.findByUsername() yêu cầu. Nếu findByUsername() không thể tìm thấy một người dùng phù hợp, thì Mono trả về sẽ rỗng, chỉ ra không có phù hợp và dẫn đến việc xác thực không thành công.

Tóm tắt
- Spring WebFlux cung cấp một framework web reactive có mô hình lập trình giống với Spring MVC và thậm chí chia sẻ nhiều chú thích giống nhau.
- Spring cũng cung cấp một mô hình functional programing như một lựa chọn cho mô hình lập trình based-annotation của Spring WebFlux.
- Controller reactive có thể được kiểm thử bằng WebTestClient.
- Phía client, Spring cung cấp WebClient, một biến thể reactive của RestTemplate của Spring.
- Mặc dù WebFlux có một số ảnh hưởng đáng kể đối với các cơ chế cơ bản để protect ứng dụng web, Spring Security 5 hỗ trợ reactive securiy với một mô hình lập trình không quá khác biệt so với ứng dụng Spring MVC không phản ứng.


Chapter 13- Persisting data reactively

This chapter covers
 Reactive relational persistence with R2DBC
 Defining reactive repositories for MongoDB and
Cassandra
 Testing reactive repositories

Nếu chúng ta đã học được một điều gì từ khoa học viễn tưởng, đó là nếu bạn muốn cải thiện trải nghiệm quá khứ, bạn chỉ cần một chút du hành thời gian. Điều này đã thành công trong Back to the Future, một số tập của các chương trình Star Trek khác nhau, Avengers: Endgame và 11/22/63 của Stephen King. (Ổn, có lẽ cái cuối cùng không kết thúc tốt hơn. Nhưng bạn hiểu ý tưởng rồi đấy.)
Trong chương này, chúng ta sẽ quay lại các chương 3 và 4, xem xét lại các repository chúng ta đã tạo cho cơ sở dữ liệu quan hệ, MongoDB và Cassandra. Lần này, chúng ta sẽ cải thiện chúng bằng cách tận dụng một số hỗ trợ repository linh hoạt của Spring Data, cho phép chúng ta làm việc với những repositories đó một cách không chặn.
Hãy bắt đầu bằng cách xem xét Spring Data R2DBC, một lựa chọn linh hoạt thay thế cho Spring Data JDBC để lưu trữ vào cơ sở dữ liệu liên kết.

13.1 Working with R2DBC

Reactive Relational Database Connectivity, hay R2DBC (https://r2dbc.io/) như người ta thường gọi, là một lựa chọn khá mới để làm việc với dữ quan hệ bằng cách sử dụng các loại reactive. Nó hiệu quả là một sự lựa chọn reactive thay thế cho JDBC, cho phép lưu trữ không chặn đối với cơ sở dữ liệu quan hệ truyền thống như MySQL, PostgreSQL, H2 và Oracle. Do được xây dựng trên Reactive Streams, R2DBC khá khác biệt so với JDBC và là một đặc tả riêng biệt, không liên quan đến Java SE.

Spring Data R2DBC là một dự án con của Spring Data, cung cấp hỗ trợ tự động cho kho lưu trữ cho R2DBC, tương tự như Spring Data JDBC, mà chúng ta đã xem xét ở chương 3. Tuy nhiên, khác với Spring Data JDBC, Spring Data R2DBC không yêu cầu sự tuân thủ nghiêm ngặt với các khái niệm thiết kế dựa trên domain. Trong thực tế, như bạn sẽ thấy ngay sau đây, việc cố gắng lưu trữ dữ liệu thông qua một aggregate root yêu cầu một chút công việc hơn với Spring Data R2DBC so với Spring Data JDBC.

Để sử dụng Spring Data R2DBC, bạn sẽ cần thêm một phụ thuộc khởi động vào dự án của mình. Đối với dự án được xây dựng bằng Maven, phụ thuộc có dạng như sau:

<dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>

Hoặc, nếu bạn đang sử dụng Initializr, hãy chọn hộp kiểm Spring Data R2DBC khi tạo dự án của bạn.

Bạn cũng sẽ cần một cơ sở dữ liệu liên kết để lưu trữ dữ liệu, cùng với một trình điều khiển R2DBC tương ứng. Đối với dự án của chúng ta, chúng ta sẽ sử dụng cơ sở dữ liệu PostgreSql. Do đó, chúng ta cần thêm hai phụ thuộc: thư viện cơ sở dữ liệu PostgreSql chính nó và trình điều khiển PostgreSql R2DBC. Phụ thuộc Maven như sau:

<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
</dependency>

13.1.1 Defining domain entities for R2DBC

Để hiểu về Spring Data R2DBC, chúng ta sẽ chỉ tạo lại lớp lưu trữ của ứng dụng Taco Cloud, chỉ tập trung vào các thành phần cần thiết để lưu trữ dữ liệu taco và đơn đặt hàng. Điều này bao gồm việc tạo ra các đối tượng thực thể cho TacoOrder, Taco, và Ingredient, cùng với các kho lưu trữ tương ứng cho mỗi đối tượng.

Lớp đối tượng thực thể đầu tiên chúng ta sẽ tạo là lớp Ingredient. Nó sẽ trông giống như đoạn mã sau đây:

package r2dbc;

import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.data.annotation.Id;

@Data
@NoArgsConstructor
@RequiredArgsConstructor
@EqualsAndHashCode(exclude = "id")
public class Ingredient {
    @Id
    private Long id;

    private @NotNull String slug;

    private @NotNull String name;
    private @NotNull Type type;

    public enum Type {
        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
    }
}

Như bạn có thể thấy, điều này không khác nhiều so với các phiên bản khác của lớp Ingredient mà chúng ta đã tạo trước đó. Hãy lưu ý hai điểm khác biệt đáng chú ý sau đây:

- Spring Data R2DBC yêu cầu các thuộc tính phải có các phương thức setter, vì vậy thay vì xác định hầu hết các thuộc tính là final, chúng ta phải làm cho chúng không phải là final. Nhưng để giúp Lombok tạo ra một constructor yêu cầu, chúng ta chú thích hầu hết các thuộc tính với @NonNull. Điều này sẽ khiến Lombok và chú thích @RequiredArgsConstructor bao gồm các thuộc tính đó trong constructor.

- Khi lưu một đối tượng thông qua một kho lưu trữ Spring Data R2DBC, nếu thuộc tính ID của đối tượng là 
not null, nó được xử lý như một cập nhật. Trong trường hợp của Ingredient, thuộc tính id trước đây được định dạng là String và được chỉ định khi tạo. Nhưng làm điều đó với Spring Data R2DBC sẽ gây ra lỗi. Vì vậy, ở đây chúng ta chuyển đổi thuộc tính ID String đó thành một thuộc tính mới có tên là slug, đó chỉ là một giả ID cho Ingredient, và sử dụng một thuộc tính ID Long với giá trị được tạo bởi cơ sở dữ liệu.

Bảng cơ sở dữ liệu tương ứng được định nghĩa trong schema.sql như sau:
CREATE TABLE Ingredient (
    id SERIAL PRIMARY KEY,
    slug VARCHAR(4) NOT NULL,
    name VARCHAR(25) NOT NULL,
    type VARCHAR(10) NOT NULL
);
Lớp đối tượng Taco cũng khá giống với phiên bản tương ứng của nó trong Spring Data JDBC, như được thể hiện trong đoạn mã tiếp theo:

package r2dbc;

import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import org.springframework.data.annotation.Id;

import java.util.HashSet;
import java.util.Set;

@Data
@NoArgsConstructor
@RequiredArgsConstructor
public class Taco {
    @Id
    private Long id;

    private @NotNull String name;
    private Set<Long> ingredientIds = new HashSet<>();
    public void addIngredient(Ingredient ingredient) {
        ingredientIds.add(ingredient.getId());
    }

}

Như đã mô tả trong lớp Ingredient, chúng ta phải cho phép các phương thức setter trên các trường của đối tượng, do đó sử dụng @NonNull thay vì final.

Tuy nhiên, điều đặc biệt ở đây là thay vì có một bộ sưu tập các đối tượng Ingredient, Taco có một Set<Long> tham chiếu đến các ID của các đối tượng Ingredient thuộc taco này. Set được chọn thay vì List để đảm bảo tính duy nhất. Nhưng tại sao chúng ta phải sử dụng Set<Long> và không phải Set<Ingredient> cho bộ sưu tập của các thành phần?

Khác với các dự án Spring Data khác, Spring Data R2DBC hiện tại không hỗ trợ trực tiếp mối quan hệ giữa các đối tượng (ít nhất là tại thời điểm hiện tại). Là một dự án khá mới, Spring Data R2DBC đang làm việc qua một số thách thức của việc xử lý mối quan hệ một cách không chặn. Điều này có thể thay đổi trong các phiên bản tương lai của Spring Data R2DBC.

Cho đến khi đó, chúng ta không thể có Taco tham chiếu đến một bộ sưu tập Ingredient và mong đợi rằng lưu trữ sẽ hoạt động. Thay vào đó, chúng ta có các lựa chọn sau khi đối mặt với vấn đề của mối quan hệ:

1. Xác định các thực thể với các tham chiếu đến các ID của các đối tượng liên quan. Trong trường hợp này, cột tương ứng trong bảng cơ sở dữ liệu phải được định nghĩa với một loại mảng, nếu có thể. H2 và PostgreSQL là hai cơ sở dữ liệu hỗ trợ cột mảng, nhưng nhiều cơ sở dữ liệu khác không. Thậm chí nếu cơ sở dữ liệu hỗ trợ cột mảng, có thể không thể định nghĩa các mục làm khóa ngoại đến bảng tham chiếu, làm cho việc thực thi tính toàn vẹn tham chiếu trở nên không thể.
  
2. Xác định các thực thể và các bảng tương ứng để hoàn toàn phù hợp với nhau. Đối với các bộ sưu tập, điều này có nghĩa là đối tượng được tham chiếu sẽ có một cột ánh xạ trở lại bảng tham chiếu. Ví dụ, bảng cho đối tượng Taco sẽ cần có một cột trỏ trở lại TacoOrder mà Taco thuộc về.

3. Chuyển đổi các đối tượng tham chiếu thành JSON và lưu trữ JSON trong một cột VARCHAR lớn. Phương pháp này hoạt động đặc biệt tốt nếu không cần truy vấn đến các đối tượng tham chiếu. Tuy nhiên, nó có các giới hạn tiềm ẩn về cách lớn đối tượng đã được JSON hóa có thể do giới hạn độ dài của cột VARCHAR tương ứng. Hơn nữa, chúng ta sẽ không có cách nào để tận dụng cơ sở dữ liệu để đảm bảo tính toàn vẹn tham chiếu, vì các đối tượng tham chiếu sẽ được lưu trữ như một giá trị chuỗi đơn giản (có thể chứa bất cứ điều gì).

Mặc dù không có lựa chọn nào là lý tưởng, sau khi xem xét chúng, chúng ta sẽ chọn lựa chọn đầu tiên cho đối tượng Taco. Lớp Taco có một Set<Long> tham chiếu đến một hoặc nhiều ID Ingredient. Điều này có nghĩa là bảng tương ứng phải có một cột mảng để lưu trữ những ID đó. Đối với cơ sở dữ liệu PostgreSQL, bảng Taco được định nghĩa như sau:
CREATE TABLE Taco (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    ingredient_ids INTEGER[]
);

Loại mảng sử dụng trong cột ingredient_ids là cụ thể cho H2. Đối với PostgreSQL, cột đó có thể được định nghĩa là integer[]. Kiểm tra tài liệu cơ sở dữ liệu bạn chọn để biết chi tiết về cách định nghĩa các cột mảng. Lưu ý rằng không phải tất cả các cài đặt cơ sở dữ liệu đều hỗ trợ cột mảng, vì vậy bạn có thể cần chọn một trong những lựa chọn khác để mô hình hóa mối quan hệ.

Cuối cùng, lớp TacoOrder, như được hiển thị trong đoạn mã tiếp theo, được định nghĩa bằng cách sử dụng nhiều thành phần mà chúng ta đã sử dụng trước đó khi định nghĩa các thực thể (entities) của chúng ta để lưu trữ dữ liệu với Spring Data R2DBC.



package r2dbc;

import lombok.Data;
import org.springframework.data.annotation.Id;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

@Data
public class TacoOrder {

    @Id
    private Long id;

    private String deliveryName;
    private String deliveryStreet;
    private String deliveryCity;
    private String deliveryState;
    private String deliveryZip;
    private String ccNumber;
    private String ccExpiration;
    private String ccCVV;

    private Set<Long> tacoIds = new LinkedHashSet<>();
    private List<Taco> tacos = new ArrayList<>();
    private void addTaco(Taco taco) {
        this.tacos.add(taco);
    }
}

Như bạn có thể thấy, ngoài việc có một số thuộc tính nhiều hơn, lớp TacoOrder tuân theo cùng một mô hình như lớp Taco. Nó tham chiếu đến các đối tượng Taco con của nó thông qua một Set<Long>.

Tuy nhiên, sau đó, chúng ta sẽ thấy cách để có được các đối tượng Taco đầy đủ vào một TacoOrder, mặc dù Spring Data R2DBC không hỗ trợ trực tiếp mối quan hệ theo cách đó. Bảng cơ sở dữ liệu cho bảng Taco_Order trông như sau: 
CREATE TABLE Taco_Order (
    id SERIAL PRIMARY KEY,
    delivery_name VARCHAR(50) NOT NULL,
    delivery_street VARCHAR(50) NOT NULL,
    delivery_city VARCHAR(50) NOT NULL,
    delivery_state VARCHAR(2) NOT NULL,
    delivery_zip VARCHAR(10) NOT NULL,
    cc_number VARCHAR(16) NOT NULL,
    cc_expiration VARCHAR(5) NOT NULL,
    cc_cvv VARCHAR(3) NOT NULL,
    taco_ids INTEGER[]
);

Tương tự như bảng Taco, có cột mảng tham chiếu đến các thành phần trong bảng Ingredient, bảng Taco-Order cũng tham chiếu đến các Taco con của nó thông qua một cột taco_ids được định nghĩa là một cột mảng. Một lần nữa, mô hình này dành cho cơ sở dữ liệu PostgreSQL; hãy kiểm tra tài liệu cơ sở dữ liệu của bạn để biết chi tiết về hỗ trợ và tạo cột mảng.

Thường thì một ứng dụng sản xuất đã được định nghĩa cấu trúc của nó thông qua các phương tiện khác, và các script như vậy không mong muốn ngoại trừ cho các bài kiểm thử. Do đó, bean này được định nghĩa trong một cấu hình chỉ được tải khi chạy các bài kiểm thử tự động và không có sẵn trong ngữ cảnh ứng dụng chạy thời gian thực. Chúng ta sẽ xem một ví dụ về một bài kiểm thử như vậy để kiểm thử các repository R2DBC sau khi đã định nghĩa các dịch vụ đó.

Hơn nữa, hãy lưu ý rằng bean này chỉ sử dụng tệp schema.sql từ gốc của classpath (dưới src/main/resources trong dự án). Nếu bạn muốn bao gồm các script SQL khác như một phần của khởi tạo cơ sở dữ liệu, thêm nhiều đối tượng ResourceDatabasePopulator trong cuộc gọi populator.addPopulators(). 

Bây giờ, sau khi đã định nghĩa các thực thể và các cấu trúc cơ sở dữ liệu tương ứng, hãy tạo các repository thông qua đó chúng ta sẽ lưu và truy xuất dữ liệu taco.

13.1.2 Defining reactive repositories

Trong các chương 3 và 4, chúng ta đã định nghĩa các repository của mình dưới dạng các giao diện mở rộng từ giao diện CrudRepository của Spring Data. Nhưng giao diện repository cơ bản đó xử lý các đối tượng đơn và các bộ sưu tập Iterable. Ngược lại, chúng ta mong đợi rằng một repository reactive sẽ xử lý các đối tượng Mono và Flux.

Đó là lý do tại sao Spring Data cung cấp ReactiveCrudRepository để định nghĩa các repository reactive. ReactiveCrudRepository hoạt động rất giống như CrudRepository. Để tạo một repository, hãy định nghĩa một giao diện mở rộng từ ReactiveCrudRepository, như sau:

package r2dbc.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import r2dbc.TacoOrder;

public interface OrderRepository extends ReactiveCrudRepository<TacoOrder, Long> {

}

Ở cái nhìn bề ngoài, sự khác biệt duy nhất giữa OrderRepository này và những repository chúng ta đã định nghĩa trong các chương 3 và 4 là nó mở rộng ReactiveCrudRepository thay vì CrudRepository. Nhưng điều quan trọng khác biệt đáng chú ý là các phương thức của nó trả về các loại Mono và Flux thay vì một TacoOrder đơn lẻ hoặc Iterable<TacoOrder>. Hai ví dụ bao gồm phương thức findById(), trả về một Mono<TacoOrder>, và findAll(), trả về một Flux<TacoOrder>.

Để xem cách repository reactive này có thể hoạt động trong thực tế, giả sử bạn muốn lấy tất cả các đối tượng TacoOrder và in delivery name của chúng ra đầu ra tiêu chuẩn. Trong trường hợp đó, bạn có thể viết mã như đoạn mã mẫu sau.

Listing 13.4 Calling a reactive repository method 









@Autowired
OrderRepository orderRepo;

...
orderRepository.findAll()
   .doOnNext(order -> {
       System.out.println("Deliver to: " + order.getDeliveryName());
   })
   .subscribe();
	
Ở đây, cuộc gọi đến findAll() trả về một Flux<TacoOrder> mà chúng ta đã thêm một doOnNext() để in tên giao hàng. Cuối cùng, cuộc gọi đến subscribe() khởi động quá trình dữ liệu thông qua Flux.

Trong ví dụ Spring Data JDBC từ chương 3, TacoOrder là gốc tổng hợp aggregate root, với Taco là một con trong tổng hợp đó. Do đó, đối tượng Taco được lưu trữ như một phần của TacoOrder và không cần phải định nghĩa một repository dành riêng cho việc lưu trữ Taco. Nhưng Spring Data R2DBC không hỗ trợ gốc tổng hợp đúng cách này, vì vậy chúng ta sẽ cần một TacoRepository thông qua đó các đối tượng Taco được lưu trữ. Xem đoạn mã tiếp theo để biết thêm về một repository như vậy.

package r2dbc.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import r2dbc.Taco;

public interface TacoRepository extends ReactiveCrudRepository<Taco, Long> {
}

Như bạn có thể thấy, TacoRepository không khác nhiều so với OrderRepository. Nó mở rộng ReactiveCrudRepository để cung cấp các loại phản ứng khi làm việc với Taco persistence. Không có nhiều điều bất ngờ ở đây.

Ngược lại, IngredientRepository có vẻ thú vị hơn một chút, như được hiển thị trong đoạn mã tiếp theo.

package r2dbc.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import r2dbc.Ingredient;
import reactor.core.publisher.Mono;

public interface IngredientRepository
        extends ReactiveCrudRepository<Ingredient, Long> {

    Mono<Ingredient> findBySlug(String slug);
}

Tương tự như hai repository có tính phản ứng khác, IngredientRepository mở rộng ReactiveCrudRepository. Nhưng vì chúng ta có thể cần một cách để tìm kiếm đối tượng Ingredient dựa trên giá trị slug, IngredientRepository bao gồm một phương thức findBySlug() trả về một Mono<Ingredient>. 

Bây giờ hãy xem cách viết các bài kiểm thử để xác nhận rằng các repository của chúng ta hoạt động.

13.1.3 Testing R2DBC repositories

Spring Data R2DBC bao gồm hỗ trợ viết bài kiểm tra tích hợp cho các repository R2DBC. Cụ thể, chú thích @DataR2dbcTest, khi đặt trên một lớp kiểm tra, làm cho Spring tạo một application context với các repository Spring Data R2DBC được tạo ra như các bean có thể được chèn vào lớp kiểm tra. Cùng với StepVerifier, mà chúng ta đã sử dụng trong các chương trước, điều này cho phép chúng ta viết các bài kiểm tra tự động cho tất cả các repository chúng ta đã tạo.

Vì sự ngắn gọn, chúng ta sẽ tập trung chỉ vào một lớp kiểm tra duy nhất: IngredientRepositoryTest. Điều này sẽ kiểm tra IngredientRepository, xác nhận rằng nó có thể lưu trữ các đối tượng Ingredient, truy xuất một Ingredient duy nhất và truy xuất tất cả các đối tượng Ingredient đã lưu trữ. Đoạn mã mẫu tiếp theo cho thấy lớp kiểm tra này.

package r2dbc;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest;
import r2dbc.data.IngredientRepository;
import reactor.core.publisher.Flux;

import r2dbc.Ingredient.Type;
import reactor.test.StepVerifier;

import java.util.ArrayList;

@DataR2dbcTest
public class IngredientRepositoryTests {

    @Autowired
    IngredientRepository repo;

    @BeforeEach
    public void setup() {
        Flux<Ingredient> deleteAndInsert = repo.deleteAll()
                .thenMany(repo.saveAll(
                        Flux.just(
                                new Ingredient("FLTO", "Flour Tortilla", Type.WRAP),
                                new Ingredient("GRBF", "Ground Beef", Type.PROTEIN),
                                new Ingredient("CHED", "Cheddar Cheese", Type.CHEESE)
                        )));
        StepVerifier.create(deleteAndInsert)
                .expectNextCount(3)
                .verifyComplete();
    }

    @Test
    public void shouldSaveAndFetchIngredients() {
        StepVerifier.create(repo.findAll())
                .recordWith(ArrayList::new)
                .thenConsumeWhile(x -> true)
                .consumeRecordedWith(ingredients -> {
                    assertThat(ingredients).hasSize(3);
                    assertThat(ingredients).contains(
                            new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
                    assertThat(ingredients).contains(
                            new Ingredient("GRBF", "Ground Beef", Type.PROTEIN));
                    assertThat(ingredients).contains(
                            new Ingredient("CHED", "Cheddar Cheese", Type.CHEESE));
                })
                .verifyComplete();

        StepVerifier.create(repo.findBySlug("FLTO"))
                .assertNext(ingredient -> {
                    ingredient.equals(new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
                });
    }
}

Phương thức shouldSaveAndFetchIngredients() bắt đầu bằng cách tạo một Flux của các đối tượng Ingredient thử nghiệm. Từ Flux này, nó sử dụng hoạt động flatMap() để lưu mỗi Ingredient thông qua phương thức save() trên IngredientRepository được chèn vào. Cuộc gọi đến subscribe() mở luồng dữ liệu qua Flux, dẫn đến việc lưu trữ các đối tượng Ingredient.

Tiếp theo, một StepVerifier được tạo từ Mono<Ingredient> được trả về bởi phương thức findBySlug() của repository. Mono<Ingredient> nên chứa một Ingredient duy nhất, điều này được phương thức assertNext() xác nhận, so sánh nó với các giá trị mong đợi cho một Ingredient có slug là "FLTO". Sau đó, nó xác nhận rằng Mono đã hoàn thành.

Cuối cùng, một StepVerifier khác được tạo từ Flux<Ingredient> được trả về bởi phương thức findAll() của repository. Một lần một lần, nó xác nhận rằng mỗi Ingredient chảy từ Flux đó khớp với ba đối tượng Ingredient được lưu ban đầu ở đầu phương thức kiểm tra. Và, giống như với StepVerifier khác, cuộc gọi đến verifyComplete() xác nhận rằng Mono đã hoàn thành và không còn đối tượng Ingredient nào đi qua nữa.

Mặc dù chúng ta chỉ tập trung vào việc kiểm thử IngredientRepository, các kỹ thuật tương tự có thể được sử dụng để kiểm thử bất kỳ repository nào được tạo ra bởi Spring Data R2BDC.

Tính đến đây, mọi thứ trở nên tốt đẹp. Chúng ta đã định nghĩa các loại domain của mình và các repository tương ứng. Và chúng ta đã viết một bài kiểm tra để xác nhận rằng chúng hoạt động. Chúng ta có thể sử dụng chúng như vậy nếu muốn. Tuy nhiên, các repository này làm cho việc lưu trữ một TacoOrder không thuận lợi vì chúng ta phải trước tiên tạo và lưu trữ các đối tượng Taco là một phần của đơn đặt hàng đó và sau đó lưu trữ đối tượng Taco-Order tham chiếu đến các đối tượng Taco con. Và khi đọc TacoOrder, chúng ta chỉ nhận được một bộ sưu tập các ID của Taco và không phải là đối tượng Taco đầy đủ được định nghĩa.
 
Sẽ tốt nếu chúng ta có thể lưu trữ TacoOrder như một gốc tổng hợp và có các đối tượng Taco con của nó được lưu trữ cùng với nó. Tương tự, sẽ tuyệt vời nếu chúng ta có thể truy xuất một TacoOrder và có nó được định nghĩa hoàn toàn với các đối tượng Taco đầy đủ và không chỉ là các ID. Hãy định nghĩa một lớp service nằm trước OrderRepository và TacoRepository để mô phỏng hành vi lưu trữ của OrderRepository trong chương 3.

13.1.4 Defining an OrderRepository aggregate root service
Bước đầu tiên để lưu trữ các đối tượng TacoOrder và Taco cùng nhau sao cho TacoOrder là aggregate root là thêm một thuộc tính collection Taco vào lớp TacoOrder. Đoạn mã sau mô tả điều này.

@Transient
private transient List<Taco> tacos = new ArrayList<>();

private void addTaco(Taco taco)
{
    this.tacos.add(taco);
    if(taco.getId() != null) {
        this.tacoIds.add(taco.getId());
    }
}

Ngoại trừ việc thêm một thuộc tính mới List<Taco> được đặt tên là tacos vào lớp TacoOrder, phương thức addTaco() hiện tại thêm Taco được đưa vào danh sách đó (cũng như thêm id của nó vào tập hợp tacoIds như trước).
Lưu ý, tuy nhiên, rằng thuộc tính tacos được chú thích bằng @Transient (cũng như được đánh dấu bằng transient keyword của Java). Điều này chỉ ra rằng Spring Data R2DBC không nên cố gắng lưu trữ thuộc tính này. Nếu không có chú thích @Transient, Spring Data R2DBC sẽ cố gắng lưu trữ nó và dẫn đến lỗi, do nó không hỗ trợ các mối quan hệ như vậy.
Khi một TacoOrder được lưu trữ, chỉ thuộc tính tacoIds sẽ được ghi vào cơ sở dữ liệu, và thuộc tính tacos sẽ được bỏ qua. Tuy nhiên, ít nhất là bây giờ TacoOrder có một nơi để chứa các đối tượng Taco. Điều này sẽ hữu ích cả khi lưu trữ các đối tượng Taco khi một TacoOrder được lưu trữ và cũng khi đọc các đối tượng Taco khi một TacoOrder được truy xuất.
Bây giờ chúng ta có thể tạo một service bean để lưu trữ và đọc các đối tượng TacoOrder cùng với các đối tượng Taco tương ứng của chúng. Hãy bắt đầu bằng cách lưu trữ một TacoOrder. Lớp TacoOrderAggregateService được định nghĩa trong đoạn mã tiếp theo có một phương thức save() thực hiện chính điều này.
Cấu hình dành cho R2DBC:
spring.r2dbc.url=r2dbc:postgresql://localhost:5432/tacocloud
spring.r2dbc.username=postgres
spring.r2dbc.password=123456



@Service
@RequiredArgsConstructor
public class TacoOrderAggregateService {

    private final TacoRepository tacoRepo;
    private final OrderRepository orderRepo;

    public Mono<TacoOrder> save(TacoOrder tacoOrder) {
        return Mono.just(tacoOrder)
                .flatMap(order -> {
                    List<Taco> tacos = order.getTacos();
                    order.setTacos(new ArrayList<>());
                    return tacoRepo.saveAll(tacos)
                            .map(taco -> {
                                order.addTaco(taco);
                                return order;
                            }).last();
                }).flatMap(orderRepo::save);
    }
}

Mặc dù có vẻ không nhiều dòng code trong đoạn mã 13.9, nhưng có nhiều công việc được thực hiện trong phương thức save() đòi hỏi một số giải thích. Trước tiên, TacoOrder nhận được dưới dạng tham số được bọc trong một Mono bằng cách sử dụng phương thức Mono.just(). Điều này cho phép chúng ta làm việc với nó như một loại reactive trong toàn bộ phương thức save().

Sau đó, chúng ta áp dụng một flatMap() vào Mono<TacoOrder> mà chúng ta vừa tạo ra. Cả map() và flatMap() đều là các lựa chọn để thực hiện các biến đổi trên một đối tượng dữ liệu đi qua một Mono hoặc Flux, nhưng do các hoạt động chúng ta thực hiện trong quá trình biến đổi sẽ dẫn đến một Mono<TacoOrder>, phép toán flatMap() đảm bảo rằng chúng ta tiếp tục làm việc với một Mono<TacoOrder> sau khi ánh xạ và không phải là Mono<Mono<TacoOrder>>, như sẽ xảy ra nếu chúng ta sử dụng map() thay vào đó.

Mục đích của phép ánh xạ là đảm bảo rằng TacoOrder cuối cùng sẽ có các ID của các đối tượng Taco con và lưu các đối tượng Taco đó dọc đường. ID của mỗi đối tượng Taco có thể là null ban đầu đối với một TacoOrder mới, và chúng ta sẽ không biết các ID cho đến sau khi các đối tượng Taco được lưu.

Sau khi lấy danh sách Taco từ TacoOrder, mà chúng ta sẽ sử dụng khi lưu các đối tượng Taco, chúng ta đặt lại thuộc tính tacos thành một danh sách trống. Chúng ta sẽ xây dựng lại danh sách đó với các đối tượng Taco mới đã được gán ID sau khi đã được lưu.

Cuộc gọi đến phương thức saveAll() trên TacoRepository được inject lưu tất cả các đối tượng Taco của chúng ta. Phương thức saveAll() trả về một Flux<Taco> mà chúng ta sau đó lặp qua qua phương thức map(). Trong trường hợp này, phép biến đổi là phụ thuộc vào việc mỗi đối tượng Taco đang được thêm trở lại vào TacoOrder. Nhưng để đảm bảo rằng nó là một TacoOrder và không phải là một Taco cuối cùng trên Flux kết quả, phép toán ánh xạ trả về TacoOrder thay vì Taco. Cuộc gọi đến last() đảm bảo rằng chúng ta sẽ không có các đối tượng TacoOrder trùng lặp (một cho mỗi Taco) do phép toán ánh xạ.

Tại điểm này, tất cả các đối tượng Taco nên đã được lưu và sau đó được đẩy lại vào đối tượng TacoOrder cha, cùng với các ID mới được gán. Tất cả những gì còn lại là lưu TacoOrder, đó là điều mà cuộc gọi flatMap() cuối cùng thực hiện. Một lần nữa, chúng ta chọn flatMap() ở đây để đảm bảo rằng Mono<TacoOrder> trả về từ cuộc gọi đến OrderRepository.save() không được bọc trong một Mono khác. Chúng ta muốn phương thức save() của chúng ta trả về một Mono<TacoOrder>, chứ không phải là Mono<Mono<TacoOrder>>.



Bây giờ hãy xem một phương thức sẽ đọc một TacoOrder theo ID của nó, tái tạo lại tất cả các đối tượng Taco con. Đoạn mã sau đây hiển thị một phương thức mới findById() cho mục đích đó.

public Mono<TacoOrder> findById(Long id) {
    return orderRepo
            .findById(id)
            .flatMap(order -> {
                return tacoRepo.findAllById(order.getTacoIds())
                        .map(taco -> {
                            order.addTaco(taco);
                            return order;
                        }).last();
            });
}

Phương thức mới findById() ngắn hơn một chút so với phương thức save(). Nhưng vẫn có nhiều điều cần phải giải thích trong phương thức nhỏ này.

Điều đầu tiên cần làm là lấy TacoOrder bằng cách gọi phương thức findById() trên OrderRepository. Điều này trả về một Mono<TacoOrder> sau đó được flat-mapped để chuyển đổi nó từ một TacoOrder chỉ có các ID của Taco thành một TacoOrder bao gồm các đối tượng Taco hoàn chỉnh.

Lambda được cung cấp cho phương thức flatMap() thực hiện một cuộc gọi đến phương thức TacoRepository.findAllById() để lấy tất cả các đối tượng Taco được tham chiếu trong thuộc tính tacoIds một lần. Điều này tạo ra một Flux<Taco> được lặp qua thông qua map(), thêm từng Taco vào TacoOrder cha, tương tự như chúng ta đã làm trong phương thức save() sau khi lưu tất cả các đối tượng Taco với saveAll().

Một lần nữa, phép toán map() được sử dụng hơn như một cách để lặp qua các đối tượng Taco hơn là một phép biến đổi. Nhưng lambda được cung cấp cho map() trả về TacoOrder cha mỗi lần để chúng ta cuối cùng có được một Flux<TacoOrder> thay vì một Flux<Taco>. Cuộc gọi đến last() lấy mục cuối cùng trong Flux đó và trả về một Mono<TacoOrder>, đó là điều chúng ta trả về từ phương thức findById().

Đoạn mã trong các phương thức save() và findById() có thể hơi khó hiểu nếu bạn chưa sẵn sàng sử dụng reactive. Lập trình reactive đòi hỏi một tư duy khác và có thể làm rối trí ban đầu, nhưng bạn sẽ nhận ra rằng nó khá thanh lịch khi kỹ năng lập trình reactive của bạn mạnh mẽ hơn.

Như bất kỳ mã nào nhất là mã có thể xuất hiện là khó hiểu như trong TacoOrderAggregateService việc viết các bài kiểm tra để đảm bảo rằng nó hoạt động đúng là một ý tưởng tốt. Bài kiểm tra cũng sẽ đóng vai trò như một ví dụ về cách sử dụng TacoOrderAggregateService. Mã nguồn dưới đây là một ví dụ về bài kiểm tra cho TacoOrderAggregateService.

package r2dbc;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.r2dbc.DataR2dbcTest;
import org.springframework.test.annotation.DirtiesContext;
import r2dbc.data.OrderRepository;
import r2dbc.data.TacoRepository;
import r2dbc.web.api.TacoOrderAggregateService;
import reactor.test.StepVerifier;

@DataR2dbcTest
@DirtiesContext
public class TacoOrderAggregateServiceTest {
    @Autowired
    TacoRepository tacoRepo;

    @Autowired
    OrderRepository orderRepo;

    TacoOrderAggregateService service;

    @BeforeEach
    public void setup() {
        this.service = new TacoOrderAggregateService(tacoRepo, orderRepo);
    }

    @Test
    public void shouldSaveAndFetchOrders() {
        TacoOrder newOrder = new TacoOrder();
        newOrder.setDeliveryName("Test Customer");
        newOrder.setDeliveryStreet("1234 North Street");
        newOrder.setDeliveryCity("Notrees");
        newOrder.setDeliveryState("TX");
        newOrder.setDeliveryZip("79759");
        newOrder.setCcNumber("4111111111111111");
        newOrder.setCcExpiration("12/24");
        newOrder.setCcCVV("123");

        newOrder.addTaco(new Taco("Test Taco One"));
        newOrder.addTaco(new Taco("Test Taco Two"));

        StepVerifier.create(service.save(newOrder))
                .assertNext(this::assertOrder)
                .verifyComplete();

        StepVerifier.create(service.findById(1l))
                .assertNext(this::assertOrder)
                .verifyComplete();
    }

    private void assertOrder(TacoOrder savedOrder) {
        assertThat(savedOrder.getId()).isEqualTo(1l);
        assertThat(savedOrder.getDeliveryName()).isEqualTo("Test Customer");
        assertThat(savedOrder.getDeliveryStreet()).isEqualTo("1234 North Street");
        assertThat(savedOrder.getDeliveryCity()).isEqualTo("Notrees");
        assertThat(savedOrder.getDeliveryState()).isEqualTo("TX");
        assertThat(savedOrder.getDeliveryZip()).isEqualTo("79759");
        assertThat(savedOrder.getCcNumber()).isEqualTo("4111111111111111");
        assertThat(savedOrder.getCcExpiration()).isEqualTo("12/24");
        assertThat(savedOrder.getCcCVV()).isEqualTo("123");

        assertThat(savedOrder.getTacoIds()).hasSize(2);
        assertThat(savedOrder.getTacos().get(0).getId()).isEqualTo(1l);
        assertThat(savedOrder.getTacos().get(0).getName()).isEqualTo("Test Taco One");
        assertThat(savedOrder.getTacos().get(1).getId()).isEqualTo(2l);
        assertThat(savedOrder.getTacos().get(1).getName()).isEqualTo("Test Taco Two");

    }
}

Đoạn mã trong Listing 13.11 chứa nhiều dòng, nhưng phần lớn nó đều là khẳng định nội dung của một TacoOrder trong phương thức assertOrder(). Chúng ta sẽ tập trung vào các phần khác trong khi xem xét bài kiểm tra này.

Lớp kiểm tra được chú thích bằng @DataR2dbcTest để Spring tạo ra một application context với tất cả các repository của chúng ta như là các bean. @DataR2dbcTest (operation) tìm kiếm một lớp cấu hình được chú thích bằng @SpringBootConfiguration để xác định application context Spring. Trong một dự án đơn mô-đun, lớp khởi động được chú thích bằng @SpringBootApplication (chính nó được chú thích bằng @SpringBootConfiguration) phục vụ mục đích này. Nhưng trong dự án đa mô-đun của chúng ta, lớp kiểm tra này không ở trong cùng một dự án với lớp khởi động, vì vậy chúng ta sẽ cần một lớp cấu hình đơn giản như sau:

package tacos;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
@SpringBootConfiguration
@EnableAutoConfiguration
public class TestConfig {
	
}

Không chỉ làm đáp ứng nhu cầu cho một lớp được chú thích bằng @SpringBootConfiguration,
nó cũng kích hoạt tự động cấu hình, đảm bảo rằng (trong số những điều khác) các triển khai repository sẽ được tạo ra.
Một mình, TacoOrderAggregateServiceTests nên chạy tốt. Nhưng trong một IDE có thể chia sẻ JVM và ngữ cảnh ứng dụng Spring giữa các lần chạy kiểm tra, việc chạy kiểm tra này cùng các kiểm tra về sự tồn tại của cơ sở dữ liệu có thể dẫn đến việc ghi dữ liệu xung đột vào cơ sở dữ liệu H2 trong bộ nhớ. @DirtiesContext được sử dụng ở đây để đảm bảo rằng application context Spring được thiết lập lại giữa các lần chạy kiểm thử, dẫn đến một cơ sở dữ liệu H2 mới và trống rỗng ở mỗi lần chạy.

Phương thức setup() tạo một phiên bản của TacoOrderAggregateService bằng cách sử dụng các đối tượng TacoRepository và OrderRepository được tiêm vào lớp kiểm tra. TacoOrderAggregateService được gán cho một biến thể để phương thức kiểm tra có thể sử dụng nó.

Bây giờ chúng ta cuối cùng đã sẵn sàng để kiểm thử service aggregate của chúng ta. Một số dòng đầu tiên của shouldSaveAndFetchOrders() xây dựng một đối tượng TacoOrder và điền nó với một vài đối tượng Taco kiểm tra. Sau đó, TacoOrder được lưu thông qua phương thức save() từ TacoOrderAggregateService, trả về một Mono<TacoOrder> đại diện cho đơn đặt hàng đã được lưu. Sử dụng StepVerifier, chúng ta khẳng định rằng TacoOrder trong Mono trả về khớp với kỳ vọng của chúng ta, bao gồm cả việc nó chứa các đối tượng Taco con.

Tiếp theo, chúng ta gọi phương thức findById() của service, cũng trả về một Mono<TacoOrder>. Như với cuộc gọi save(), chúng ta sử dụng StepVerifier để đi qua từng TacoOrder trong Mono trả về (nên chỉ có một) và khẳng định rằng nó đáp ứng kỳ vọng của chúng ta.
Trong cả hai tình huống StepVerifier, cuộc gọi verifyComplete() đảm bảo rằng không có đối tượng nào khác trong Mono và rằng Mono là hoàn chỉnh.
Có ý định rằng mặc dù chúng ta có thể áp dụng một phép toán tổng hợp tương tự để đảm bảo rằng các đối tượng Taco luôn chứa các đối tượng Ingredient đã được định nghĩa đầy đủ, chúng ta không chọn cách này, vì Ingredient là một gốc tổng hợp riêng của nó, có khả năng được tham chiếu bởi nhiều đối tượng Taco. Do đó, mỗi Taco chỉ mang theo một Set<Long> để tham chiếu các ID của Ingredient, sau đó có thể được tìm kiếm riêng lẻ thông qua IngredientRepository.

Mặc dù có thể cần một số công việc để tổng hợp các thực thể, Spring Data R2DBC cung cấp một cách để làm việc với dữ liệu quan hệ theo cách phản ứng. Nhưng đó không phải là lựa chọn duy nhất về tính linh hoạt cung cấp bởi Spring. Hãy xem cách làm việc với MongoDB bằng cách sử dụng các repository Spring reactive.

13.2 Persisting document data reactively with MongoDB

Bây giờ chúng ta đã thấy cách tạo kho dữ liệu phản ứng cho R2BDC và MongoDB, hãy xem xét một tùy chọn nữa của Spring Data cho reactive persistence: Cassandra.
13.3 Reactively persisting data in Cassandra

Để bắt đầu với reactive persistence đối với cơ sở dữ liệu Cassandra, bạn cần thêm dependency starter sau vào dự án của bạn. Phụ thuộc này sẽ thay thế mọi phụ thuộc Mongo hoặc R2DBC chúng ta đã sử dụng trước đó.



<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-cassandra-reactive</artifactId>
</dependency>


Sau đó, bạn sẽ cần khai báo một số chi tiết về keyspace của Cassandra và cách quản lý schema. Trong tệp application.yml của bạn, thêm các dòng sau:


spring:
  data:
    rest:
      base-path: /data-api
    cassandra:
      keyspace-name: tacocloud
      schema-action: recreate
      local-datacenter: datacenter1
      

Đây là cấu hình YAML giống như chúng ta đã sử dụng trong chương 4 khi làm việc với các repository Cassandra phi phản ứng. Điều quan trọng cần lưu ý là keyspace-name. Quan trọng là bạn phải tạo một keyspace có tên đó trong Cassandra cluster của bạn. Bạn cũng cần phải có một Cassandra cluster đang chạy trên localhost và lắng nghe trên cổng 9042. Cách dễ nhất để làm điều đó là sử dụng Docker, như sau:

$ docker network create cassandra-net
$ docker run --name my-cassandra --network cassandra-net \
-p 9042:9042 -d cassandra:latest

Nếu cụm Cassandra của bạn đang chạy trên máy khác hoặc cổng khác, bạn sẽ cần chỉ định các contact point và port trong tệp application.yml, như được thể hiện trong chương 4. Để tạo keyspace, chạy CQL shell và sử dụng lệnh create keyspace như sau:

$ docker run -it --network cassandra-net --rm cassandra cqlsh my-cassandra
cqlsh> create keyspace tacocloud
WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};

Bây giờ bạn đã có một cụm Cassandra, một keyspace mới mang tên "tacocloud," và bộ khởi động Spring Data Cassandra Reactive trong dự án của mình, bạn đã sẵn sàng bắt đầu định nghĩa các lớp miền (domain classes).

13.3.1 Defining domain classes for Cassandra persistence

Như đã làm khi lưu trữ với MongoDB, sự lựa chọn giữa lưu trữ Cassandra phản ứng (reactive) và không phản ứng (nonreactive) không tạo ra bất kỳ sự khác biệt nào trong cách bạn định nghĩa các lớp domain của mình. Các lớp domain cho Ingredient, Taco, và TacoOrder mà chúng ta sẽ sử dụng giống hệt như những lớp chúng ta đã tạo trong chương 4. Dưới đây là một ví dụ về lớp Ingredient được chú thích bằng Cassandra.

package tacos;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Table("ingredients")
public class Ingredient {

    @PrimaryKey
    private String id;
    private String name;
    private Type type;

    public enum Type {
        WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
    }
}

Đối với lớp Taco, nó được định nghĩa với các chú thích lưu trữ Cassandra tương tự như trong đoạn mã tiếp theo.

@Data
@RestResource(rel = "tacos", path = "tacos")
@Table("tacos")
public class Taco {

    @PrimaryKeyColumn(type = PrimaryKeyType.PARTITIONED)
    private UUID id = Uuids.timeBased();

    @NotNull
    @Size(min = 5, message = "Name must be at least 5 characters long")
    private String name;

    @PrimaryKeyColumn(type = PrimaryKeyType.CLUSTERED,
            ordering = Ordering.DESCENDING)
    private Date createdAt = new Date();

    @Size(min = 1, message = "You must choose at least 1 ingredient")
    @Column("ingredients")
    private List<IngredientUDT> ingredients = new ArrayList<>();

    public void addIngredient(Ingredient ingredient){
        this.ingredients.add(new IngredientUDT(ingredient.getName()
                , ingredient.getType()));
    }
}

Bởi vì lớp Taco tham chiếu đến các đối tượng Ingredient thông qua một user defined type, bạn cũng sẽ cần lớp IngredientUDT, như được hiển thị ở đoạn mã dưới đây.

package tacos;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.cassandra.core.mapping.UserDefinedType;

@Data
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)
@UserDefinedType("ingredient")
public class IngredientUDT {
    private final String name;
    private final Ingredient.Type type;
}

Lớp domain thứ ba của chúng ta, TacoOrder, được chú thích để lưu trữ Cassandra như được hiển thị trong đoạn mã dưới đây.
@Data
@Table("tacoorders")
public class TacoOrder implements Serializable {
    private static final long serialVersionUID = 1L;

    @PrimaryKey
    private UUID id = Uuids.timeBased();
    private Date placedAt = new Date();

    @Column("user")
    private UserUDT user;

    private String deliveryName;
    private String deliveryStreet;
    private String deliveryCity;
    private String deliveryState;
    private String deliveryZip;
    private String ccNumber;
    private String ccExpiration;
    private String ccCVV;
    @Column("tacos")
    private List<TacoUDT> tacos = new ArrayList<>();

    
}

Và, giống như cách Taco tham chiếu đến Ingredient thông qua một user defined type, TacoOrder tham chiếu đến Taco thông qua lớp TacoUDT, như được hiển thị ở đoạn mã tiếp theo.

package tacos;

import lombok.Data;
import org.springframework.data.cassandra.core.mapping.UserDefinedType;

import java.util.List;

@Data
@UserDefinedType("taco")
public class TacoUDT {
    private final String name;
    private final List<IngredientUDT> ingredients;
}

Quan trọng là nhấn mạnh rằng chúng giống hệt nhau với các phiên bản non-reactive của chúng. Tôi chỉ lặp lại chúng ở đây để bạn không cần phải quay lại 11 chương để nhớ chúng trông như thế nào. Bây giờ hãy định nghĩa các kho dữ liệu (repositories) để lưu trữ những đối tượng này.

13.3.2 Creating reactive Cassandra repositories

Đến lúc này, bạn có thể đã mong đợi rằng các kho dữ liệu Cassandra phản ứng sẽ trông khá giống với các kho dữ liệu tương đương phi phản ứng. Nếu có, thì tuyệt vời! Bạn đang nhận ra rằng Spring Data, nếu có thể, cố gắng duy trì một mô hình lập trình tương tự, không phụ thuộc vào việc kho dữ liệu có phải là phản ứng hay không.

Bạn có thể đã đoán được rằng sự khác biệt chính làm cho các kho dữ liệu trở nên phản ứng là các giao diện mở rộng từ ReactiveCrudRepository, như được thể hiện ở đây trong giao diện IngredientRepository:

package tacos.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import tacos.Ingredient;

public interface IngredientRepository
        extends ReactiveCrudRepository<Ingredient, String> {
}

Tự nhiên, điều tương tự cũng đúng cho OrderRepository, như được hiển thị ở phía dưới:

package tacos.data;

import java.util.UUID;

import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import tacos.TacoOrder;
import tacos.User;

public interface OrderRepository
        extends ReactiveCrudRepository<TacoOrder, UUID> {

    Flux<TacoOrder> findByUserOrderByPlacedAtDesc(
            User user, Pageable pageable);

}

Thực tế, không chỉ các repository này gợi nhớ đến các phiên bản non-reactive của chúng, mà chúng cũng không khác biệt nhiều so với các repository MongoDB mà chúng ta đã viết trước đó trong chương này. Ngoại trừ việc Cassandra sử dụng UUID làm loại ID thay vì String cho TacoOrder, chúng gần như giống nhau. Điều này một lần nữa chứng minh sự nhất quán được áp dụng (nếu có thể) trong các dự án Spring Data.

Hãy kết thúc phần xem xét về việc viết các repository Cassandra reactive bằng cách viết một vài bài kiểm thử để xác minh rằng chúng hoạt động.

13.3.3 Testing reactive Cassandra repositories
Tại điểm này, có lẽ không có gì ngạc nhiên khi kiểm thử các kho dữ liệu Cassandra phản ứng khá giống với cách bạn kiểm thử các kho dữ liệu MongoDB phản ứng. Ví dụ, hãy xem xét IngredientRepositoryTest trong đoạn mã tiếp theo và xem liệu bạn có thể nhận diện được sự khác biệt so với đoạn mã 13.15 không.

package tacos;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest;
import reactor.core.publisher.Flux;
import reactor.test.StepVerifier;
import tacos.data.IngredientRepository;

import tacos.Ingredient.Type;

import java.util.ArrayList;

@DataCassandraTest
public class IngredientRepositoryTests {

    @Autowired
    private IngredientRepository repo;

    @BeforeEach
    public void setup() {
        Flux<Ingredient> deleteAndInsert = repo.deleteAll()
                .thenMany(repo.saveAll(
                        Flux.just(
                                new Ingredient("FLTO", "Flour Tortilla", Type.WRAP),
                                new Ingredient("GRBF", "Ground Beef", Type.PROTEIN),
                                new Ingredient("CHED", "Cheddar Cheese", Type.CHEESE)
                        )));
        StepVerifier.create(deleteAndInsert)
                .expectNextCount(3)
                .verifyComplete();
    }

    @Test
    public void shouldSaveAndFetchIngredients() {
        StepVerifier.create(repo.findAll())
                .recordWith(ArrayList::new)
                .thenConsumeWhile(x -> true)
                .consumeRecordedWith(ingredients -> {
                    assertThat(ingredients).hasSize(3);
                    assertThat(ingredients).contains(
                            new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
                    assertThat(ingredients).contains(
                            new Ingredient("GRBF", "Ground Beef", Type.PROTEIN));
                    assertThat(ingredients).contains(
                            new Ingredient("CHED", "Cheddar Cheese", Type.CHEESE));
                })
                .verifyComplete();

        StepVerifier.create(repo.findById("FLTO"))
                .assertNext(ingredient -> {
                    ingredient.equals(new Ingredient("FLTO", "Flour Tortilla", Type.WRAP));
                })
                .verifyComplete();
    }

}


Bạn đã nhận ra chưa? Ở phiên bản MongoDB, chúng ta sử dụng chú thích @DataMongoTest, trong khi phiên bản Cassandra mới này được chú thích bằng @DataCassandraTest. Đó là tất cả! Ngoài ra, các bài kiểm tra là giống nhau.

Điều tương tự cũng đúng cho OrderRepositoryTest. Thay thế @DataMongoTest bằng @DataCassandraTest, và mọi thứ khác đều giống nhau, như sau:
@DataCassandraTest
public class IngredientRepositoryTests {

Một lần nữa, sự nhất quán giữa các dự án Spring Data mở rộng ngay cả vào cách kiểm thử được viết. Điều này giúp dễ dàng chuyển đổi giữa các dự án lưu trữ vào các loại cơ sở dữ liệu khác nhau mà không cần phải nghĩ quá nhiều về cách chúng được phát triển.


Chapter 14 - Working with Rsocket

This chapter covers
 Reactive network communication with RSocket
 Working with each of RSocket’s four
communication models
 Transporting RSocket over WebSocket

Có một thời, trước khi có điện thoại và điện tử hiện đại, khi muốn liên lạc với bạn bè và gia đình ở xa nhất, phương tiện tốt nhất là viết thư và gửi qua dịch vụ bưu điện. Đó không phải là một hình thức giao tiếp nhanh chóng, mất vài ngày hoặc thậm chí một vài tuần trước khi bạn nhận được phản hồi, nhưng nó là phương tiện hiệu quả và thực sự là lựa chọn duy nhất.

Nhờ vào Alexander Graham Bell, điện thoại mang lại một cách mới để trò chuyện với bạn bè và gia đình ở xa, cung cấp giao tiếp gần thời gian thực và đồng bộ. Mặc dù điện thoại đã phát triển khá nhiều kể từ phát minh đầu tiên của ông Bell, nhưng nó vẫn là một phương tiện phổ biến để giữ liên lạc, làm cho việc viết thư gần như trở thành một nghệ thuật bị lãng quên.

Khi nói đến giao tiếp giữa các ứng dụng, request-response model được cung cấp bởi HTTP và các dịch vụ REST khá phổ biến, nhưng nó có nhược điểm. Giống như viết thư, request-response liên quan đến việc gửi một thông điệp và đợi đến khi nhận được phản hồi. Nó không dễ dàng cho việc giao tiếp không đồng bộ asynchronous communication, trong đó một server có thể phản hồi với một luồng các phản hồi stream of responses hoặc cho phép một kênh song hướng mở mà trên đó một client và server có thể lặp đi lặp lại gửi dữ liệu cho nhau.

Trong chương này, chúng ta sẽ tìm hiểu về RSocket, một giao thức tương đối mới cho giao tiếp giữa ứng dụng, cho phép nhiều hơn là giao tiếp đơn giản request-response. Và vì nó có tính reactive, nó có thể hiệu quả hơn đáng kể so với các request HTTP blocking.
Trong quá trình này, chúng ta sẽ thấy cách phát triển giao tiếp RSocket trong Spring. Nhưng trước tiên, hãy nhìn tổng quan về RSocket để hiểu điều gì làm nó khác biệt so với giao tiếp dựa trên HTTP.

14.1 Introducing RSocket

RSocket (https://rsocket.io/) là một binary application protocol giao thức ứng dụng nhị phân có tính bất đồng bộ và dựa trên Reactive Streams. Nói một cách khác, RSocket cung cấp giao tiếp không đồng bộ giữa các ứng dụng và hỗ trợ reactive model nhất quán với các loại phản ứng như Flux và Mono mà chúng ta đã tìm hiểu trong chương 12.

Là một phương tiện thay thế cho giao tiếp dựa trên HTTP, RSocket linh hoạt hơn, cung cấp bốn mô hình giao tiếp khác nhau: request-response, request-stream, fire-and-forget, và channel..

Mô hình request-response là mô hình giao tiếp quen thuộc nhất trong RSocket, mô phỏng cách giao tiếp HTTP thông thường hoạt động. Trong mô hình request-response, một client đưa ra một yêu cầu duy nhất đến máy chủ, và máy chủ phản hồi bằng một phản hồi duy nhất. Điều này được minh họa trong hình 14.1, sử dụng kiểu Mono của Reactor để xác định yêu cầu và phản hồi.

 

Mặc dù mô hình yêu cầu-phản hồi có vẻ tương đương với mô hình giao tiếp được cung cấp bởi HTTP, nhưng quan trọng là hiểu rằng RSocket là một hệ thống không chặn và dựa trên các loại reactive. Mặc dù khách hàng vẫn sẽ đợi một phản hồi từ máy chủ, nhưng ở bên dưới, mọi thứ đều không chặn và phản ứng, tận dụng hiệu quả hơn các luồng.

Mô hình giao tiếp request-stream tương tự như request-response, ngoại trừ việc sau khi client đã gửi một request đơn đến server, server phản hồi bằng một luồng giá trị từ không đến nhiều giá trị trong một luồng. Hình 14.2 minh họa mô hình request-stream bằng cách sử dụng Mono cho yêu cầu và Flux cho phản hồi.

 
Trong một số trường hợp, khách hàng có thể cần gửi dữ liệu đến máy chủ nhưng không cần phản hồi. RSocket cung cấp mô hình fire-and-forget cho những tình huống đó, như được minh họa trong hình 14.3.

 

Trong mô hình fire-and-forget, một khách hàng gửi một yêu cầu đến máy chủ, nhưng máy chủ không gửi phản hồi trở lại.

Cuối cùng, mô hình giao tiếp linh hoạt nhất của RSocket là mô hình kênh. Trong mô hình kênh, khách hàng mở một kênh hai chiều với máy chủ, và mỗi bên có thể gửi dữ liệu cho bên kia bất cứ lúc nào. Hình 14.4 minh họa kiểu giao tiếp qua kênh này.
 

RSocket được hỗ trợ trên nhiều ngôn ngữ và nền tảng khác nhau, bao gồm Java, JavaScript, Kotlin, .NET, Go và C++. Các phiên bản gần đây của Spring cung cấp hỗ trợ chính thức cho RSocket, giúp dễ dàng tạo ra máy chủ và khách hàng bằng cách sử dụng các quy ước quen thuộc của Spring.

Hãy bắt đầu và xem cách tạo server và client RSocket hoạt động với mỗi mô hình giao tiếp trong bốn mô hình đã nêu.
14.2 Creating a simple RSocket server and client

Spring cung cấp sự hỗ trợ đáng kinh ngạc cho việc giao tiếp thông tin với RSocket, bao gồm tất cả bốn mô hình giao tiếp. Để bắt đầu với RSocket, bạn cần thêm Spring Boot RSocket starter vào dự án của mình. Trong một tệp POM của Maven, phụ thuộc vào RSocket starter sẽ có dạng như sau:

Cùng một phụ thuộc này cần thiết cho cả ứng dụng máy chủ và ứng dụng khách tham gia trong giao tiếp RSocket.

**LƯU Ý:** Khi chọn các phụ thuộc từ Spring Initializr, bạn có thể thấy một phụ thuộc WebSocket có tên giống nhau. Mặc dù RSocket và WebSocket có tên giống nhau và mặc dù bạn có thể sử dụng WebSocket như một phương tiện truyền tải cho RSocket (chúng ta sẽ bàn về điều này sau trong chương này), nhưng bạn không cần chọn phụ thuộc WebSocket khi làm việc với RSocket.

Tiếp theo, bạn sẽ cần quyết định mô hình giao tiếp nào phù hợp nhất cho ứng dụng của bạn. Không có một câu trả lời rõ ràng phù hợp với mọi tình huống, nên bạn sẽ muốn cân nhắc lựa chọn dựa trên hành vi giao tiếp mong muốn của ứng dụng của bạn. Tuy nhiên, như bạn sẽ thấy trong một số ví dụ tiếp theo, mô hình phát triển không khác biệt nhiều cho từng mô hình giao tiếp, vì vậy sẽ dễ dàng chuyển đổi nếu bạn chọn sai.

Hãy xem cách tạo máy chủ và khách hàng RSocket trong Spring sử dụng mỗi mô hình giao tiếp. Vì mỗi mô hình giao tiếp của RSocket khác nhau và phù hợp nhất cho các kịch bản sử dụng cụ thể, chúng ta sẽ để ứng dụng Taco Cloud sang một bên tạm thời và xem cách áp dụng RSocket trên các lĩnh vực vấn đề khác nhau. Chúng ta sẽ bắt đầu bằng cách xem cách áp dụng mô hình giao tiếp request - response.

14.2.1 Working with request-response

Tạo một máy chủ RSocket trong Spring cũng đơn giản như việc tạo một lớp controller, tương tự như bạn làm cho một ứng dụng web hoặc dịch vụ REST. Bên dưới là một ví dụ về một controller làm việc như một dịch vụ RSocket, xử lý các lời chào từ khách hàng và phản hồi với một lời chào khác.
package rsocket;

import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.stereotype.Controller;
import reactor.core.publisher.Mono;

@Controller
@Slf4j
public class GreetingController {

    @MessageMapping("greeting")
    public Mono<String> handleGreeting(Mono<String> greetingMono) {
        return greetingMono
                .doOnNext(greeting ->
                        log.info("Received a greeting: {}", greeting))
                .map(greeting -> "Hello back to you!");
    }
    
}


Như bạn có thể thấy, sự khác biệt chính giữa một controller web và một controller RSocket là thay vì xử lý các yêu cầu HTTP cho một đường dẫn cụ thể (sử dụng @GetMapping hoặc @PostMapping), một controller RSocket xử lý các thông điệp đến trên một tuyến đường cụ thể với chú thích @MessageMapping. Trong ví dụ này, phương thức handleGreeting() được gọi khi một yêu cầu được gửi từ khách hàng đến tuyến đường có tên là "greeting".

Phương thức handleGreeting() nhận payload của thông điệp từ client trong một tham số Mono<String>. Trong trường hợp này, lời chào đơn giản đủ sử dụng một String, nhưng payload đầu vào có thể là một loại phức tạp hơn nếu cần. Sau khi nhận được Mono<String>, phương thức đơn giản ghi lại việc nhận lời chào và sau đó sử dụng hàm map() trên Mono để tạo ra một Mono<String> mới để mang theo phản hồi được trả về cho khách hàng.

Mặc dù các controller RSocket không xử lý các yêu cầu HTTP cho một đường dẫn, tên tuyến đường route name có thể được thiết lập để có dạng giống đường dẫn, bao gồm cả các địa chỉ giữ chỗ biến có thể được chuyển vào phương thức xử lý. Ví dụ, xem xét về phương thức handleGreeting() sau đây:
@MessageMapping("greeting/{name}")
public Mono<String> handleGreeting(@DestinationVariable("name") String name,
                                   Mono<String> greetingMono) {
    return greetingMono.doOnNext(greeting ->
            log.info("Received a greeting from {}: {}", name, greeting))
            .map(greeting -> "Hello to you, too, " + name);
}


Trong trường hợp này, tuyến đường được chỉ định trong @MessageMapping chứa một biến giữ chỗ được đặt tên là "name". Nó được biểu thị bằng dấu ngoặc nhọn, cách tương tự như biến đường dẫn trong một controller Spring MVC. Tương tự, phương thức chấp nhận một tham số String được chú thích bằng @DestinationVariable trỏ đến biến giữ chỗ. Giống như chú thích @PathVariable của Spring MVC, @DestinationVariable được sử dụng để trích xuất giá trị được chỉ định trong biến giữ chỗ của tuyến đường và chuyển nó vào phương thức xử lý. Một khi đã vào bên trong phiên bản mới của handleGreeting(), tên được chỉ định trong tuyến đường sẽ được sử dụng để trả về một lời chào cá nhân hóa hơn cho khách hàng.

Còn một điều nữa bạn cần nhớ khi tạo một máy chủ RSocket: xác định cổng để lắng nghe. Theo mặc định, các dịch vụ RSocket là dựa trên TCP và là máy chủ của chính họ lắng nghe trên một cổng cụ thể. Thuộc tính cấu hình spring.rsocket.server.port đặt cổng cho máy chủ RSocket, như được thể hiện dưới đây:

spring:
  rsocket:
    server:
      port: 7000

Thuộc tính spring.rsocket.server.port phục vụ hai mục đích: kích hoạt một máy chủ và xác định máy chủ sẽ lắng nghe ở cổng nào. Nếu nó không được đặt, Spring sẽ giả định rằng ứng dụng của bạn sẽ chỉ hoạt động như một khách hàng, và không có cổng máy chủ nào sẽ lắng nghe. Trong trường hợp này, chúng ta đang bắt đầu một máy chủ, vì vậy việc đặt thuộc tính spring.rsocket.server.port như được thể hiện trong mã trước đó sẽ khởi động một máy chủ lắng nghe ở cổng 7000.

Bây giờ hãy chuyển sự chú ý của chúng ta đến Rsocket client. Trong Spring, Rsocket client được thực hiện bằng cách sử dụng một RSocketRequester. Auto configuration của Spring Boot cho RSocket sẽ tự động tạo một bean kiểu RSocketRequester.Builder trong ngữ cảnh ứng dụng Spring. Bạn có thể tiêm vào bean xây dựng đó vào bất kỳ bean nào khác bạn cần để tạo một phiên bản của RSocketRequester.

Ví dụ, dưới đây là đoạn mã khởi đầu của một bean ApplicationRunner mà được tiêm vào một RSocketRequester.Builder:







@Configuration
@Slf4j
public class RSocketClientConfiguration {

    @Bean
    public ApplicationRunner sender(RSocketRequester.Builder requesterBuilder) {
        return args -> {
            RSocketRequester tcp = requesterBuilder.tcp("localhost", 7000);
            // ... send messages with RSocketRequester
        };
    }
}

Trong trường hợp này, builder được sử dụng để tạo một RSocketRequester lắng nghe trên localhost, cổng 7000. RSocketRequester kết quả có thể được sử dụng để gửi các thông điệp đến máy chủ.

Trong mô hình request - response, yêu cầu sẽ cần phải chỉ định ít nhất là tuyến đường route và dữ liệu payload. Như bạn nhớ, controller của máy chủ của chúng ta đang xử lý yêu cầu cho route có tên là "greeting" và mong đợi một đầu vào String. Nó cũng trả về một đầu ra String. Đoạn mã đầy đủ sau đây cho thấy cách gửi một lời chào đến máy chủ và xử lý phản hồi:

@Configuration
@Slf4j
public class RSocketClientConfiguration {

    @Bean
    public ApplicationRunner sender(RSocketRequester.Builder requesterBuilder) {
        return args -> {
            RSocketRequester tcp = requesterBuilder.tcp("localhost", 7000);
            tcp
                    .route("greeting")
                    .data("Hello RSocket")
                    .retrieveMono(String.class)
                    .subscribe(response -> log.info("Got a response: {}", response));
        };
    }
}

Đoạn mã này gửi một lời chào "Hello RSocket!" đến máy chủ trên tuyến đường "greeting". Lưu ý rằng nó cũng mong đợi một `Mono<String>` trong phản hồi, như được chỉ định trong cuộc gọi đến `retrieveMono()`. Phương thức `subscribe()` đăng ký theo dõi Mono được trả về và xử lý payload của nó bằng cách ghi giá trị vào log.

Bây giờ giả sử bạn muốn gửi một lời chào đến tuyến đường khác chấp nhận một giá trị biến trong tuyến đường của nó. Mã phía client hoạt động khá giống nhau, ngoại trừ việc bạn bao gồm giữ chỗ biến trong giá trị được chuyển vào `route()`, cùng với giá trị mà nó nên chứa, như sau:
String who = "Craig";
tcp
        .route("greeting/{name}", who)
        .data("Hello RSocket!")
        .retrieveMono(String.class)
        .subscribe(response -> log.info("Got a response: {}", response));

14.2.2 Handling request-stream messaging

Không phải tất cả các tương tác đều có một yêu cầu và một phản hồi. Trong một kịch bản báo giá cổ phiếu, ví dụ, có thể hữu ích để yêu cầu một luồng các báo giá cổ phiếu cho một ký hiệu cổ phiếu cụ thể. Trong mô hình request-response, khách hàng sẽ cần liên tục đặt câu hỏi để biết giá cổ phiếu hiện tại. Nhưng trong mô hình request-stream, khách hàng chỉ cần yêu cầu giá cổ phiếu một lần và sau đó đăng ký theo dõi một luồng các cập nhật định kỳ.

	

Để minh họa mô hình request-stream, hãy triển khai server và client cho kịch bản báo giá cổ phiếu. Trước hết, chúng ta sẽ cần định nghĩa một đối tượng có thể mang thông tin về báo giá cổ phiếu. Lớp StockQuote trong đoạn mã tiếp theo sẽ phục vụ mục đích này.

package rsocket.requeststream;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.math.BigDecimal;
import java.time.Instant;

@Data
@AllArgsConstructor
public class StockQuote {
    private String symbol;
    private BigDecimal price;
    private Instant timestamp;
}


Như bạn có thể thấy, một StockQuote chứa ký hiệu cổ phiếu symbol, giá price và một dấu thời gian timestamp mà giá đó là hợp lệ. Vì sự ngắn gọn, chúng ta đang sử dụng Lombok để hỗ trợ các hàm tạo và phương thức truy cập.
Bây giờ hãy viết một controller để xử lý các yêu cầu cho StockQuote. Bạn sẽ thấy rằng StockQuoteController trong đoạn mã tiếp theo khá tương tự như GreetingController từ phần trước.

@Controller
public class StockQuoteController {

    @MessageMapping("stock/{symbol}")
    public Flux<StockQuote> getStockPrice(@DestinationVariable("symbol") String symbol) {
        return Flux
                .interval(Duration.ofSeconds(1))
                .map(i -> {
                    BigDecimal price = BigDecimal.valueOf(Math.random() * 10);
                    return new StockQuote(symbol, price, Instant.now());
                });
    }
}

Ở đây, phương thức getStockPrice() xử lý các yêu cầu đến route "stock/{symbol}", chấp nhận symbol từ tuyến đường bằng chú thích @DestinationVariable. Vì sự đơn giản, thay vì tìm giá cổ phiếu thực tế, giá được tính toán như một giá trị ngẫu nhiên (có thể hoặc không chính xác mô hình động của một số cổ phiếu thực tế).








Tuy nhiên, điều quan trọng nhất của getStockPrice() là nó trả về một Flux<StockQuote> thay vì Mono<StockQuote>. Điều này là một gợi ý cho Spring rằng phương thức xử lý này hỗ trợ mô hình 
request-stream. Nội tại, Flux được tạo ban đầu như là một khoảng thời gian bắn mỗi một giây, nhưng Flux đó được ánh xạ sang một Flux khác tạo ra StockQuote ngẫu nhiên. Nói một cách đơn giản, một yêu cầu duy nhất được xử lý bởi phương thức getStockPrice() trả về nhiều giá trị, mỗi giây một lần.

Một client của service request-stream tương tự như một dịch vụ request-response. Sự khác biệt chính là thay vì gọi retrieveMono() trên requester, nó nên gọi retrieveFlux(). Client của service báo giá cổ phiếu có thể trông giống như sau:
String stockSymbol = "XYZ";
tcp
        .route("stock/{symbol}", stockSymbol)
        .retrieveFlux(StockQuote.class)
        .doOnNext(stockQuote ->
                log.info("Price of {}: {} (at {})"
                        , stockQuote.getSymbol()
                        , stockQuote.getPrice()
                        , stockQuote.getTimestamp())
        ).subscribe();

Ở điểm này, chúng ta đã thấy cách tạo server và client RSocket để xử lý một và nhiều phản hồi. Nhưng nếu máy chủ không có phản hồi để gửi hoặc khách hàng không cần phản hồi? Hãy xem cách xử lý mô hình giao tiếp 
fire-and-forget.

14.2.3 Sending fire-and-forget messages

Hãy tưởng tượng rằng bạn đang ở trên một con tàu vũ trụ vừa bị tấn công bởi một tàu đối phương. Bạn kêu gọi mức độ "báo động đỏ" trên toàn con tàu để tất cả mọi người đều ở chế độ chiến đấu. Bạn không cần phải đợi một phản hồi từ máy tính của con tàu xác nhận trạng thái báo động, cũng như bạn không có thời gian đợi và đọc bất kỳ phản hồi nào trong tình huống này. Bạn thiết lập báo động và sau đó chuyển sang các vấn đề quan trọng hơn.

Đây là một ví dụ về mô hình fire-and-forget. Mặc dù bạn có thể không quên rằng bạn đang ở trạng thái báo động đỏ, nhưng trong hoàn cảnh này, quan trọng hơn là bạn xử lý tình hình khẩn cấp chiến đấu hơn là xử lý một phản hồi từ việc đặt báo động.

Để mô phỏng tình huống này, chúng ta sẽ tạo một máy chủ RSocket xử lý trạng thái báo động nhưng không trả về bất kỳ điều gì. Trước tiên, chúng ta cần định nghĩa một lớp mô tả payload yêu cầu, chẳng hạn như lớp Alert trong đoạn mã sau.

@Data
@AllArgsConstructor
public class Alert {
    private Level level;
    private String orderedBy;
    private Instant orderedAt;

    public enum Level {
        YELLOW, ORANGE, RED, BLACK
    }
}

Đối tượng Alert ghi lại cấp độ báo động, người đã yêu cầu báo động và một dấu thời gian cho việc báo động được yêu cầu (được định nghĩa dưới dạng Instant). Một lần nữa, chúng ta đang sử dụng Lombok cho các hàm tạo và phương thức truy cập để giữ mã ngắn.

Ở phía máy chủ, AlertController trong đoạn mã tiếp theo sẽ xử lý các thông điệp Alert.

@Controller
@Slf4j
public class AlertController {

    @MessageMapping("alert"/*route name*/)
    public Mono<Void> setAlert(Mono<Alert> alertMono) {
        return alertMono.doOnNext(alert ->
                log.info("{} alert ordered by {} at {}",
                        alert.getLevel(),
                        alert.getOrderedBy(),
                        alert.getOrderedAt())
                )
                .thenEmpty(Mono.empty());
    }
}

Phương thức `setAlert()` xử lý các thông điệp Alert trên tuyến đường "alert". Để giữ mọi thứ đơn giản (mặc dù không có ích trong tình huống chiến đấu thực tế), nó chỉ ghi log các cảnh báo. Nhưng điều quan trọng là nó trả về một Mono<Void>, cho biết không có phản hồi, và do đó, phương thức xử lý này hỗ trợ mô hình fire-and-forget.

Trong phía khách hàng, mã code không khác nhiều so với các mô hình request-response hoặc request-stream, như được thể hiện ở đây:

RSocketRequester tcp = requesterBuilder.tcp("localhost", 7000);
tcp
        .route("alert")
        .data(new Alert(Alert.Level.RED, "Craig", Instant.now()))
        .send()
        .subscribe();
log.info("Alert sent");

Lưu ý rằng, thay vì gọi retrieveMono() hoặc retrieveFlux(), khách hàng chỉ đơn giản là gọi send() mà không mong đợi một phản hồi.

Bây giờ hãy xem cách xử lý mô hình giao tiếp theo kênh (channel) trong đó cả máy chủ và khách hàng gửi nhiều thông điệp cho nhau.

14.2.4 Sending messages bidirectionally

Trong tất cả các mô hình giao tiếp mà chúng ta đã thấy cho đến nay, khách hàng gửi một yêu cầu duy nhất, và máy chủ phản hồi với không, một, hoặc nhiều phản hồi. Trong mô hình request-stream, máy chủ có thể truyền nhiều phản hồi về khách hàng, nhưng khách hàng vẫn bị giới hạn chỉ có thể gửi một yêu cầu duy nhất. Nhưng tại sao máy chủ lại được hưởng tất cả niềm vui? Tại sao khách hàng không thể gửi nhiều yêu cầu?
Đó là nơi mô hình giao tiếp theo kênh trở nên hữu ích. Trong mô hình giao tiếp theo kênh, khách hàng có thể truyền nhiều yêu cầu đến máy chủ, máy chủ cũng có thể truyền nhiều phản hồi trong một cuộc trò chuyện hai chiều giữa cả hai bên. Đó là mô hình giao tiếp linh hoạt nhất của RSocket, mặc dù cũng là phức tạp nhất.

Để thể hiện cách làm việc với giao tiếp theo kênh RSocket trong Spring, hãy tạo một dịch vụ tính tiền thưởng cho hóa đơn, nhận một Flux các yêu cầu và phản hồi với một Flux các phản hồi. Đầu tiên, chúng ta cần định nghĩa các đối tượng mô hình đại diện cho yêu cầu và phản hồi. Lớp GratuityIn, được hiển thị sau đây, đại diện cho yêu cầu được gửi bởi khách hàng và nhận bởi máy chủ.
Gratuity: tiền thưởng
package rsocket.channel;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
public class GratuityIn {
    private BigDecimal billTotal;
    private int percent;
}

GratuityIn chứa hai thông tin quan trọng cần thiết để tính tiền thưởng: tổng hóa đơn và một phần trăm. Lớp GratuityOut được hiển thị trong đoạn mã tiếp theo đại diện cho phản hồi, lặp lại các giá trị được cung cấp trong GratuityIn, cùng với một thuộc tính `gratuity` chứa số tiền thưởng được tính toán.
package rsocket.channel;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
public class GratuityOut {
    private BigDecimal billTotal;
    private int percent;
    private BigDecimal gratuity;
}

GratuityController trong đoạn mã tiếp theo xử lý yêu cầu về tiền thưởng và trông khá giống các bộ điều khiển chúng ta đã viết trước đó trong chương này.

@Controller
@Slf4j
public class GratuityController {

    @MessageMapping("gratuity" /*route name*/)
    public Flux<GratuityOut> calculate(Flux<GratuityIn> gratuityInFlux) {
        return gratuityInFlux
                .doOnNext(in -> log.info("Calculating gratuity: {}", in))
                .map(in -> {
                    double percentAsDecimal = in.getPercent() / 100.0;
                    BigDecimal gratuity = in.getBillTotal()
                            .multiply(BigDecimal.valueOf(percentAsDecimal));
                    return new GratuityOut(in.getBillTotal(), in.getPercent(), gratuity);
                });
    }
}

Tuy nhiên, có một khác biệt đáng kể giữa ví dụ trước và các ví dụ trước đó: mã này không chỉ trả về một Flux mà còn chấp nhận một Flux như đầu vào. Giống như mô hình request-stream, Flux được trả về cho phép bộ điều khiển truyền nhiều giá trị đến khách hàng. Nhưng tham số Flux là điều làm cho mô hình channel khác biệt so với mô hình request -stream. Tham số Flux đưa vào cho phép controller xử lý một luồng yêu cầu từ khách hàng đến phương thức xử lý.

Phía khách hàng của mô hình channel khác biệt so với khách hàng của mô hình request-stream chỉ ở chỗ nó gửi một Flux<GratuityIn> đến máy chủ thay vì một Mono<GratuityIn>, như được thể hiện ở đây.

Flux<GratuityIn> gratuityInFlux =
        Flux.fromArray(new GratuityIn[]{
                new GratuityIn(BigDecimal.valueOf(25.50), 18),
                new GratuityIn(BigDecimal.valueOf(10.00), 15),
                new GratuityIn(BigDecimal.valueOf(23.25), 20),
                new GratuityIn(BigDecimal.valueOf(52.75), 18),
                new GratuityIn(BigDecimal.valueOf(80.00), 15)
        }).delayElements(Duration.ofSeconds(1));

tcp
        .route("gratuity")
        .data(gratuityInFlux)
        .retrieveFlux(GratuityOut.class)
        .subscribe(out -> {
                    log.info(out.getPercent() + "% gratuity on "
                            + out.getBillTotal() + " is "
                            + out.getGratuity());
        });


Trong trường hợp này, Flux<GratuityIn> được tạo tĩnh bằng cách sử dụng phương thức fromArray(), nhưng nó có thể là một Flux được tạo từ bất kỳ nguồn dữ liệu nào, có thể được lấy từ một kho dữ liệu phản ứng.

Bạn có thể đã nhận thức được một mô hình trong cách các loại phản ứng được chấp nhận và trả về bởi các phương thức xử lý của máy chủ xác định mô hình giao tiếp RSocket được hỗ trợ. Bảng 14.1 tóm tắt mối quan hệ giữa các loại đầu vào/đầu ra của máy chủ và các mô hình giao tiếp RSocket.

 
Bạn có thể tự hỏi liệu có khả năng cho một máy chủ chấp nhận một Flux và trả về một Mono. Ngắn gọn, đó không phải là một lựa chọn. Mặc dù bạn có thể tưởng tượng xử lý nhiều yêu cầu trên một Flux đầu vào và phản hồi với một Mono<Void> trong một sự kết hợp kỳ cục của mô hình kênh và fire-and-forget, nhưng không có mô hình RSocket nào tương ứng với tình huống đó. Do đó, điều này không được hỗ trợ.

14.3 Transporting RSocket over WebSocket

Mặc định, giao tiếp RSocket diễn ra qua một kết nối socket TCP. Nhưng trong một số trường hợp, TCP không phải là một lựa chọn. Xem xét hai tình huống sau đây:

- Khách hàng được viết bằng JavaScript và đang chạy trong trình duyệt web của người dùng.
- Khách hàng phải vượt qua ranh giới hoặc tường lửa để đến máy chủ, và tường lửa không cho phép giao tiếp qua các cổng tùy ý.

Hơn nữa, WebSocket chính nó không có bất kỳ hỗ trợ định tuyến (route) nào, yêu cầu rằng các chi tiết định tuyến phải được xác định ở mức ứng dụng. Bằng cách lớp RSocket trên WebSocket, WebSocket sẽ hưởng lợi từ việc hỗ trợ định tuyến tích hợp sẵn của RSocket.

Trong những tình huống này, RSocket có thể được truyền qua WebSocket. Giao tiếp WebSocket diễn ra qua HTTP, đây là phương tiện chính của giao tiếp trong tất cả các trình duyệt web và thường được phép qua tường lửa.

Để chuyển từ giao tiếp qua TCP sang giao tiếp qua WebSocket, bạn chỉ cần thực hiện một số thay đổi nhỏ trong server và client. Đầu tiên, vì WebSocket được truyền qua HTTP, bạn cần đảm bảo rằng ứng dụng máy chủ hỗ trợ xử lý các yêu cầu HTTP. Đơn giản, bạn cần thêm phụ thuộc khởi đầu WebFlux sau đây vào dự án (nếu chưa có):

<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

Bạn cũng cần chỉ định rằng bạn muốn sử dụng giao tiếp qua WebSocket trong cấu hình máy chủ bằng cách thiết lập thuộc tính spring.rsocket.server.transport. Ngoài ra, bạn cần đặt đường dẫn HTTP mà giao tiếp RSocket sẽ diễn ra bằng cách thiết lập spring.rsocket.server.mapping-path. Cấu hình máy chủ sẽ trông như sau trong application.yml:

 



spring:
  rsocket:
    server:
      transport: websocket
      mapping-path: /rsocket

Khác với giao tiếp qua TCP, mà giao tiếp qua một cổng cụ thể, giao tiếp qua WebSocket hoạt động qua một đường dẫn HTTP cụ thể. Do đó, không cần thiết lập spring.rsocket.server.port như với RSocket qua TCP.

Đó là tất cả những gì bạn cần thực hiện ở phía máy chủ để kích hoạt giao tiếp qua WebSocket cho RSocket. Mọi thứ khác sẽ hoạt động đúng như với TCP.

Ở phía khách hàng, chỉ có một thay đổi nhỏ cần thiết. Thay vì tạo một người gửi dựa trên TCP, bạn muốn tạo một người gửi dựa trên WebSocket bằng cách gọi phương thức websocket() trên RSocketRequester.Builder như sau:

RSocketRequester requester =
        requesterBuilder.websocket(URI.create("http://localhost:8080/rsocket"));
requester
        .route("greeting")
        .data("Hello RSocket")
        .retrieveMono(String.class)
        .subscribe(response -> log.info("Got a response: {}", response));



Part 4 - Deployed Spring
Trong phần 4, bạn sẽ chuẩn bị ứng dụng để triển khai vào môi trường sản xuất và tìm hiểu cách triển khai nó. Chương 15 giới thiệu Spring Boot Actuator, một phần mở rộng của Spring Boot mà mở ra các nội dung bên trong của ứng dụng Spring đang chạy dưới dạng các end point REST và JMX MBeans. Trong chương 16, bạn sẽ tìm hiểu cách sử dụng Spring Boot Admin để đặt một ứng dụng quản trị dựa trên trình duyệt thân thiện với người dùng lên trên của Actuator. Bạn cũng sẽ tìm hiểu cách đăng ký ứng dụng khách với Admin Server và làm thế nào để bảo mật nó. Chương 17 thảo luận về cách tiếp cận và sử dụng các Spring bean như JMX MBeans. Cuối cùng, trong chương 18, bạn sẽ tìm hiểu cách triển khai ứng dụng Spring của mình trong nhiều môi trường sản xuất khác nhau, bao gồm ứng dụng Spring đóng gói trong container có thể chạy trên Kubernetes.


